// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"metar.gg/ent"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Airport struct {
		Continent        func(childComplexity int) int
		Country          func(childComplexity int) int
		Elevation        func(childComplexity int) int
		Frequencies      func(childComplexity int) int
		GpsCode          func(childComplexity int) int
		ID               func(childComplexity int) int
		IataCode         func(childComplexity int) int
		Identifier       func(childComplexity int) int
		Keywords         func(childComplexity int) int
		Latitude         func(childComplexity int) int
		LocalCode        func(childComplexity int) int
		Longitude        func(childComplexity int) int
		Municipality     func(childComplexity int) int
		Name             func(childComplexity int) int
		Region           func(childComplexity int) int
		Runways          func(childComplexity int) int
		ScheduledService func(childComplexity int) int
		Type             func(childComplexity int) int
		Website          func(childComplexity int) int
		Wikipedia        func(childComplexity int) int
	}

	AirportConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AirportEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Frequency struct {
		Airport     func(childComplexity int) int
		Description func(childComplexity int) int
		Frequency   func(childComplexity int) int
		ID          func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		GetAirports func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, identifier *string) int
	}

	Runway struct {
		Airport                      func(childComplexity int) int
		Closed                       func(childComplexity int) int
		HighRunwayDisplacedThreshold func(childComplexity int) int
		HighRunwayElevation          func(childComplexity int) int
		HighRunwayHeading            func(childComplexity int) int
		HighRunwayIdentifier         func(childComplexity int) int
		HighRunwayLatitude           func(childComplexity int) int
		HighRunwayLongitude          func(childComplexity int) int
		ID                           func(childComplexity int) int
		Length                       func(childComplexity int) int
		Lighted                      func(childComplexity int) int
		LowRunwayDisplacedThreshold  func(childComplexity int) int
		LowRunwayElevation           func(childComplexity int) int
		LowRunwayHeading             func(childComplexity int) int
		LowRunwayIdentifier          func(childComplexity int) int
		LowRunwayLatitude            func(childComplexity int) int
		LowRunwayLongitude           func(childComplexity int) int
		Surface                      func(childComplexity int) int
		Width                        func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Airport.continent":
		if e.complexity.Airport.Continent == nil {
			break
		}

		return e.complexity.Airport.Continent(childComplexity), true

	case "Airport.country":
		if e.complexity.Airport.Country == nil {
			break
		}

		return e.complexity.Airport.Country(childComplexity), true

	case "Airport.elevation":
		if e.complexity.Airport.Elevation == nil {
			break
		}

		return e.complexity.Airport.Elevation(childComplexity), true

	case "Airport.frequencies":
		if e.complexity.Airport.Frequencies == nil {
			break
		}

		return e.complexity.Airport.Frequencies(childComplexity), true

	case "Airport.gpsCode":
		if e.complexity.Airport.GpsCode == nil {
			break
		}

		return e.complexity.Airport.GpsCode(childComplexity), true

	case "Airport.id":
		if e.complexity.Airport.ID == nil {
			break
		}

		return e.complexity.Airport.ID(childComplexity), true

	case "Airport.iataCode":
		if e.complexity.Airport.IataCode == nil {
			break
		}

		return e.complexity.Airport.IataCode(childComplexity), true

	case "Airport.identifier":
		if e.complexity.Airport.Identifier == nil {
			break
		}

		return e.complexity.Airport.Identifier(childComplexity), true

	case "Airport.keywords":
		if e.complexity.Airport.Keywords == nil {
			break
		}

		return e.complexity.Airport.Keywords(childComplexity), true

	case "Airport.latitude":
		if e.complexity.Airport.Latitude == nil {
			break
		}

		return e.complexity.Airport.Latitude(childComplexity), true

	case "Airport.localCode":
		if e.complexity.Airport.LocalCode == nil {
			break
		}

		return e.complexity.Airport.LocalCode(childComplexity), true

	case "Airport.longitude":
		if e.complexity.Airport.Longitude == nil {
			break
		}

		return e.complexity.Airport.Longitude(childComplexity), true

	case "Airport.municipality":
		if e.complexity.Airport.Municipality == nil {
			break
		}

		return e.complexity.Airport.Municipality(childComplexity), true

	case "Airport.name":
		if e.complexity.Airport.Name == nil {
			break
		}

		return e.complexity.Airport.Name(childComplexity), true

	case "Airport.region":
		if e.complexity.Airport.Region == nil {
			break
		}

		return e.complexity.Airport.Region(childComplexity), true

	case "Airport.runways":
		if e.complexity.Airport.Runways == nil {
			break
		}

		return e.complexity.Airport.Runways(childComplexity), true

	case "Airport.scheduledService":
		if e.complexity.Airport.ScheduledService == nil {
			break
		}

		return e.complexity.Airport.ScheduledService(childComplexity), true

	case "Airport.type":
		if e.complexity.Airport.Type == nil {
			break
		}

		return e.complexity.Airport.Type(childComplexity), true

	case "Airport.website":
		if e.complexity.Airport.Website == nil {
			break
		}

		return e.complexity.Airport.Website(childComplexity), true

	case "Airport.wikipedia":
		if e.complexity.Airport.Wikipedia == nil {
			break
		}

		return e.complexity.Airport.Wikipedia(childComplexity), true

	case "AirportConnection.edges":
		if e.complexity.AirportConnection.Edges == nil {
			break
		}

		return e.complexity.AirportConnection.Edges(childComplexity), true

	case "AirportConnection.pageInfo":
		if e.complexity.AirportConnection.PageInfo == nil {
			break
		}

		return e.complexity.AirportConnection.PageInfo(childComplexity), true

	case "AirportConnection.totalCount":
		if e.complexity.AirportConnection.TotalCount == nil {
			break
		}

		return e.complexity.AirportConnection.TotalCount(childComplexity), true

	case "AirportEdge.cursor":
		if e.complexity.AirportEdge.Cursor == nil {
			break
		}

		return e.complexity.AirportEdge.Cursor(childComplexity), true

	case "AirportEdge.node":
		if e.complexity.AirportEdge.Node == nil {
			break
		}

		return e.complexity.AirportEdge.Node(childComplexity), true

	case "Frequency.airport":
		if e.complexity.Frequency.Airport == nil {
			break
		}

		return e.complexity.Frequency.Airport(childComplexity), true

	case "Frequency.description":
		if e.complexity.Frequency.Description == nil {
			break
		}

		return e.complexity.Frequency.Description(childComplexity), true

	case "Frequency.frequency":
		if e.complexity.Frequency.Frequency == nil {
			break
		}

		return e.complexity.Frequency.Frequency(childComplexity), true

	case "Frequency.id":
		if e.complexity.Frequency.ID == nil {
			break
		}

		return e.complexity.Frequency.ID(childComplexity), true

	case "Frequency.type":
		if e.complexity.Frequency.Type == nil {
			break
		}

		return e.complexity.Frequency.Type(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.getAirports":
		if e.complexity.Query.GetAirports == nil {
			break
		}

		args, err := ec.field_Query_getAirports_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAirports(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["identifier"].(*string)), true

	case "Runway.airport":
		if e.complexity.Runway.Airport == nil {
			break
		}

		return e.complexity.Runway.Airport(childComplexity), true

	case "Runway.closed":
		if e.complexity.Runway.Closed == nil {
			break
		}

		return e.complexity.Runway.Closed(childComplexity), true

	case "Runway.highRunwayDisplacedThreshold":
		if e.complexity.Runway.HighRunwayDisplacedThreshold == nil {
			break
		}

		return e.complexity.Runway.HighRunwayDisplacedThreshold(childComplexity), true

	case "Runway.highRunwayElevation":
		if e.complexity.Runway.HighRunwayElevation == nil {
			break
		}

		return e.complexity.Runway.HighRunwayElevation(childComplexity), true

	case "Runway.highRunwayHeading":
		if e.complexity.Runway.HighRunwayHeading == nil {
			break
		}

		return e.complexity.Runway.HighRunwayHeading(childComplexity), true

	case "Runway.highRunwayIdentifier":
		if e.complexity.Runway.HighRunwayIdentifier == nil {
			break
		}

		return e.complexity.Runway.HighRunwayIdentifier(childComplexity), true

	case "Runway.highRunwayLatitude":
		if e.complexity.Runway.HighRunwayLatitude == nil {
			break
		}

		return e.complexity.Runway.HighRunwayLatitude(childComplexity), true

	case "Runway.highRunwayLongitude":
		if e.complexity.Runway.HighRunwayLongitude == nil {
			break
		}

		return e.complexity.Runway.HighRunwayLongitude(childComplexity), true

	case "Runway.id":
		if e.complexity.Runway.ID == nil {
			break
		}

		return e.complexity.Runway.ID(childComplexity), true

	case "Runway.length":
		if e.complexity.Runway.Length == nil {
			break
		}

		return e.complexity.Runway.Length(childComplexity), true

	case "Runway.lighted":
		if e.complexity.Runway.Lighted == nil {
			break
		}

		return e.complexity.Runway.Lighted(childComplexity), true

	case "Runway.lowRunwayDisplacedThreshold":
		if e.complexity.Runway.LowRunwayDisplacedThreshold == nil {
			break
		}

		return e.complexity.Runway.LowRunwayDisplacedThreshold(childComplexity), true

	case "Runway.lowRunwayElevation":
		if e.complexity.Runway.LowRunwayElevation == nil {
			break
		}

		return e.complexity.Runway.LowRunwayElevation(childComplexity), true

	case "Runway.lowRunwayHeading":
		if e.complexity.Runway.LowRunwayHeading == nil {
			break
		}

		return e.complexity.Runway.LowRunwayHeading(childComplexity), true

	case "Runway.lowRunwayIdentifier":
		if e.complexity.Runway.LowRunwayIdentifier == nil {
			break
		}

		return e.complexity.Runway.LowRunwayIdentifier(childComplexity), true

	case "Runway.lowRunwayLatitude":
		if e.complexity.Runway.LowRunwayLatitude == nil {
			break
		}

		return e.complexity.Runway.LowRunwayLatitude(childComplexity), true

	case "Runway.lowRunwayLongitude":
		if e.complexity.Runway.LowRunwayLongitude == nil {
			break
		}

		return e.complexity.Runway.LowRunwayLongitude(childComplexity), true

	case "Runway.surface":
		if e.complexity.Runway.Surface == nil {
			break
		}

		return e.complexity.Runway.Surface(childComplexity), true

	case "Runway.width":
		if e.complexity.Runway.Width == nil {
			break
		}

		return e.complexity.Runway.Width(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Airport {
  id: ID!
  """This will be the ICAO code if available. Otherwise, it will be a local airport code (if no conflict), or if nothing else is available, an internally-generated code starting with the ISO2 country code, followed by a dash and a four-digit number."""
  identifier: String!
  """Type of airport."""
  type: AirportType!
  """The official airport name, including "Airport", "Airstrip", etc."""
  name: String!
  """Latitude of the airport in decimal degrees (positive is north)."""
  latitude: Float!
  """Longitude of the airport in decimal degrees (positive is east)."""
  longitude: Float!
  """Elevation of the airport, in feet."""
  elevation: Int
  """Where the airport is (primarily) located."""
  continent: AirportContinent!
  country: String!
  region: String!
  """The primary municipality that the airport serves (when available). Note that this is not necessarily the municipality where the airport is physically located."""
  municipality: String
  """Whether the airport has scheduled airline service."""
  scheduledService: Boolean!
  """The code that an aviation GPS database (such as Jeppesen's or Garmin's) would normally use for the airport. This will always be the ICAO code if one exists. Note that, unlike the ident column, this is not guaranteed to be globally unique."""
  gpsCode: String
  """The three-letter IATA code for the airport."""
  iataCode: String
  """The local country code for the airport, if different from the gps_code and iata_code fields (used mainly for US airports)."""
  localCode: String
  """The URL of the airport's website."""
  website: String
  """The URL of the airport's Wikipedia page."""
  wikipedia: String
  """Extra keywords/phrases to assist with search. May include former names for the airport, alternate codes, names in other languages, nearby tourist destinations, etc."""
  keywords: [String!]!
  runways: [Runway!]
  frequencies: [Frequency!]
}
"""AirportContinent is enum for the field continent"""
enum AirportContinent @goModel(model: "metar.gg/ent/airport.Continent") {
  AF
  AN
  AS
  EU
  NA
  SA
  OC
}
"""AirportType is enum for the field type"""
enum AirportType @goModel(model: "metar.gg/ent/airport.Type") {
  large_airport
  medium_airport
  small_airport
  closed_airport
  heliport
  seaplane_base
}
type Frequency {
  id: ID!
  """A code for the frequency type. Some common values are "TWR" (tower), "ATF" or "CTAF" (common traffic frequency), "GND" (ground control), "RMP" (ramp control), "ATIS" (automated weather), "RCO" (remote radio outlet), "ARR" (arrivals), "DEP" (departures), "UNICOM" (monitored ground station), and "RDO" (a flight-service station)."""
  type: String!
  """A description of the frequency."""
  description: String!
  """Radio frequency in megahertz. Note that the same frequency may appear multiple times for an airport, serving different functions"""
  frequency: Float!
  airport: Airport
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
type Runway {
  id: ID!
  """Length of the runway in feet."""
  length: Int!
  """Width of the runway surface in feet."""
  width: Int!
  """Code for the runway surface type. This is not yet a controlled vocabulary, but probably will be soon. Some common values include "ASP" (asphalt), "TURF" (turf), "CON" (concrete), "GRS" (grass), "GRE" (gravel), "WATER" (water), and "UNK" (unknown)."""
  surface: String
  """Whether the runway is lighted at night or not."""
  lighted: Boolean!
  """Whether the runway is currently closed or not."""
  closed: Boolean!
  """Low numbered runway identifier, like 18R."""
  lowRunwayIdentifier: String!
  """Latitude of the low numbered runway end, in decimal degrees (positive is north)."""
  lowRunwayLatitude: Float
  """Longitude of the low numbered runway end, in decimal degrees (positive is east)."""
  lowRunwayLongitude: Float
  """Elevation of the low numbered runway end, in feet."""
  lowRunwayElevation: Int
  """True (not magnetic) heading of the lower numbered runway."""
  lowRunwayHeading: Float
  """Displaced threshold length of the lower numbered runway end, in feet."""
  lowRunwayDisplacedThreshold: Int
  """High numbered runway identifier, like 01L."""
  highRunwayIdentifier: String!
  """Latitude of the high numbered runway end, in decimal degrees (positive is north)."""
  highRunwayLatitude: Float
  """Longitude of the high numbered runway end, in decimal degrees (positive is east)."""
  highRunwayLongitude: Float
  """Elevation of the high numbered runway end, in feet."""
  highRunwayElevation: Int
  """True (not magnetic) heading of the higher numbered runway."""
  highRunwayHeading: Float
  """Displaced threshold length of the higher numbered runway end, in feet."""
  highRunwayDisplacedThreshold: Int
  airport: Airport
}
`, BuiltIn: false},
	{Name: "../../metar.graphql", Input: `scalar Cursor

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: Cursor!
    endCursor: Cursor!
}

type AirportConnection {
    totalCount: Int!
    pageInfo: PageInfo!
    edges: [AirportEdge!]!
}

type AirportEdge {
    node: Airport!
    cursor: Cursor!
}

type Query {
    getAirports(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        identifier: String
    ): AirportConnection!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
