// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"metar.gg/ent"
	"metar.gg/ent/airport"
	"metar.gg/graph/model"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Airport() AirportResolver
	Forecast() ForecastResolver
	IcingCondition() IcingConditionResolver
	Metar() MetarResolver
	Query() QueryResolver
	SkyCondition() SkyConditionResolver
	TemperatureData() TemperatureDataResolver
	TurbulenceCondition() TurbulenceConditionResolver
	WeatherStation() WeatherStationResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Airport struct {
		Country          func(childComplexity int) int
		Elevation        func(childComplexity int) int
		Frequencies      func(childComplexity int) int
		GpsCode          func(childComplexity int) int
		ID               func(childComplexity int) int
		IataCode         func(childComplexity int) int
		IcaoCode         func(childComplexity int) int
		Identifier       func(childComplexity int) int
		ImportID         func(childComplexity int) int
		Importance       func(childComplexity int) int
		Keywords         func(childComplexity int) int
		LastUpdated      func(childComplexity int) int
		Latitude         func(childComplexity int) int
		LocalCode        func(childComplexity int) int
		Longitude        func(childComplexity int) int
		Municipality     func(childComplexity int) int
		Name             func(childComplexity int) int
		Region           func(childComplexity int) int
		Runways          func(childComplexity int, closed *bool) int
		ScheduledService func(childComplexity int) int
		Station          func(childComplexity int) int
		StationsVicinity func(childComplexity int, first *int, radius *float64) int
		Timezone         func(childComplexity int) int
		Type             func(childComplexity int) int
		Website          func(childComplexity int) int
		Wikipedia        func(childComplexity int) int
	}

	AirportConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AirportEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Country struct {
		Code          func(childComplexity int) int
		Continent     func(childComplexity int) int
		ID            func(childComplexity int) int
		ImportID      func(childComplexity int) int
		Keywords      func(childComplexity int) int
		LastUpdated   func(childComplexity int) int
		Name          func(childComplexity int) int
		WikipediaLink func(childComplexity int) int
	}

	Forecast struct {
		Altimeter            func(childComplexity int, unit model.PressureUnit) int
		ChangeIndicator      func(childComplexity int) int
		ChangeProbability    func(childComplexity int) int
		ChangeTime           func(childComplexity int) int
		FromTime             func(childComplexity int) int
		ID                   func(childComplexity int) int
		IcingConditions      func(childComplexity int) int
		NotDecoded           func(childComplexity int) int
		SkyConditions        func(childComplexity int) int
		TemperatureData      func(childComplexity int) int
		ToTime               func(childComplexity int) int
		TurbulenceConditions func(childComplexity int) int
		VisibilityHorizontal func(childComplexity int, unit model.LengthUnit) int
		VisibilityVertical   func(childComplexity int, unit model.LengthUnit) int
		Weather              func(childComplexity int) int
		WindDirection        func(childComplexity int) int
		WindGust             func(childComplexity int, unit model.SpeedUnit) int
		WindShearDirection   func(childComplexity int) int
		WindShearHeight      func(childComplexity int, unit model.LengthUnit) int
		WindShearSpeed       func(childComplexity int, unit model.SpeedUnit) int
		WindSpeed            func(childComplexity int, unit model.SpeedUnit) int
	}

	Frequency struct {
		Airport     func(childComplexity int) int
		Description func(childComplexity int) int
		Frequency   func(childComplexity int) int
		ID          func(childComplexity int) int
		ImportID    func(childComplexity int) int
		LastUpdated func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	IcingCondition struct {
		ID          func(childComplexity int) int
		Intensity   func(childComplexity int) int
		MaxAltitude func(childComplexity int, unit model.LengthUnit) int
		MinAltitude func(childComplexity int, unit model.LengthUnit) int
	}

	Metar struct {
		Altimeter                             func(childComplexity int, unit model.PressureUnit) int
		Dewpoint                              func(childComplexity int, unit model.TemperatureUnit) int
		FlightCategory                        func(childComplexity int) int
		ID                                    func(childComplexity int) int
		ImportTime                            func(childComplexity int) int
		MaxTemp24                             func(childComplexity int) int
		MaxTemp6                              func(childComplexity int) int
		MetarType                             func(childComplexity int) int
		MinTemp24                             func(childComplexity int) int
		MinTemp6                              func(childComplexity int) int
		ObservationTime                       func(childComplexity int) int
		Precipitation                         func(childComplexity int) int
		Precipitation24                       func(childComplexity int) int
		Precipitation3                        func(childComplexity int) int
		Precipitation6                        func(childComplexity int) int
		PresentWeather                        func(childComplexity int) int
		PressureTendency                      func(childComplexity int, unit model.PressureUnit) int
		QualityControlAutoStation             func(childComplexity int) int
		QualityControlCorrected               func(childComplexity int) int
		QualityControlFreezingRainSensorOff   func(childComplexity int) int
		QualityControlLightningSensorOff      func(childComplexity int) int
		QualityControlMaintenanceIndicatorOn  func(childComplexity int) int
		QualityControlNoSignal                func(childComplexity int) int
		QualityControlPresentWeatherSensorOff func(childComplexity int) int
		RawText                               func(childComplexity int) int
		SeaLevelPressure                      func(childComplexity int, unit model.PressureUnit) int
		SkyConditions                         func(childComplexity int) int
		SnowDepth                             func(childComplexity int, unit model.SmallLengthUnit) int
		Station                               func(childComplexity int) int
		Temperature                           func(childComplexity int, unit model.TemperatureUnit) int
		VerticalVisibility                    func(childComplexity int, unit model.LengthUnit) int
		Visibility                            func(childComplexity int, unit model.LengthUnit) int
		WindDirection                         func(childComplexity int) int
		WindGust                              func(childComplexity int, unit model.SpeedUnit) int
		WindSpeed                             func(childComplexity int, unit model.SpeedUnit) int
	}

	MetarConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MetarEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		GetAirport  func(childComplexity int, id *string, identifier *string, icao *string, iata *string) int
		GetAirports func(childComplexity int, first *int, after *ent.Cursor, before *ent.Cursor, last *int, identifier *string, icao *string, iata *string, typeArg *airport.Type, search *string, hasWeather *bool, order []*ent.AirportOrder) int
		GetStation  func(childComplexity int, id *string, identifier *string) int
		GetStations func(childComplexity int, first *int, after *ent.Cursor, before *ent.Cursor, last *int, identifier *string) int
	}

	Region struct {
		Code          func(childComplexity int) int
		ID            func(childComplexity int) int
		ImportID      func(childComplexity int) int
		Keywords      func(childComplexity int) int
		LastUpdated   func(childComplexity int) int
		LocalCode     func(childComplexity int) int
		Name          func(childComplexity int) int
		WikipediaLink func(childComplexity int) int
	}

	Runway struct {
		Airport                      func(childComplexity int) int
		Closed                       func(childComplexity int) int
		HighRunwayDisplacedThreshold func(childComplexity int) int
		HighRunwayElevation          func(childComplexity int) int
		HighRunwayHeading            func(childComplexity int) int
		HighRunwayIdentifier         func(childComplexity int) int
		HighRunwayLatitude           func(childComplexity int) int
		HighRunwayLongitude          func(childComplexity int) int
		ID                           func(childComplexity int) int
		ImportID                     func(childComplexity int) int
		LastUpdated                  func(childComplexity int) int
		Length                       func(childComplexity int) int
		Lighted                      func(childComplexity int) int
		LowRunwayDisplacedThreshold  func(childComplexity int) int
		LowRunwayElevation           func(childComplexity int) int
		LowRunwayHeading             func(childComplexity int) int
		LowRunwayIdentifier          func(childComplexity int) int
		LowRunwayLatitude            func(childComplexity int) int
		LowRunwayLongitude           func(childComplexity int) int
		Surface                      func(childComplexity int) int
		Width                        func(childComplexity int) int
	}

	SkyCondition struct {
		CloudBase func(childComplexity int, unit model.LengthUnit) int
		CloudType func(childComplexity int) int
		ID        func(childComplexity int) int
		SkyCover  func(childComplexity int) int
	}

	StationWithDistance struct {
		Distance func(childComplexity int) int
		Station  func(childComplexity int) int
	}

	Taf struct {
		BulletinTime  func(childComplexity int) int
		Forecast      func(childComplexity int) int
		ID            func(childComplexity int) int
		ImportTime    func(childComplexity int) int
		IssueTime     func(childComplexity int) int
		RawText       func(childComplexity int) int
		Remarks       func(childComplexity int) int
		SkyConditions func(childComplexity int) int
		Station       func(childComplexity int) int
		ValidFromTime func(childComplexity int) int
		ValidToTime   func(childComplexity int) int
	}

	TafConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TafEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TemperatureData struct {
		ID             func(childComplexity int) int
		MaxTemperature func(childComplexity int, unit model.TemperatureUnit) int
		MinTemperature func(childComplexity int, unit model.TemperatureUnit) int
		Temperature    func(childComplexity int, unit model.TemperatureUnit) int
		ValidTime      func(childComplexity int) int
	}

	TurbulenceCondition struct {
		ID          func(childComplexity int) int
		Intensity   func(childComplexity int) int
		MaxAltitude func(childComplexity int, unit model.LengthUnit) int
		MinAltitude func(childComplexity int, unit model.LengthUnit) int
	}

	WeatherStation struct {
		Airport   func(childComplexity int) int
		Elevation func(childComplexity int) int
		ID        func(childComplexity int) int
		Latitude  func(childComplexity int) int
		Longitude func(childComplexity int) int
		Metars    func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int) int
		StationID func(childComplexity int) int
		Tafs      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int) int
	}

	WeatherStationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	WeatherStationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Airport.country":
		if e.complexity.Airport.Country == nil {
			break
		}

		return e.complexity.Airport.Country(childComplexity), true

	case "Airport.elevation":
		if e.complexity.Airport.Elevation == nil {
			break
		}

		return e.complexity.Airport.Elevation(childComplexity), true

	case "Airport.frequencies":
		if e.complexity.Airport.Frequencies == nil {
			break
		}

		return e.complexity.Airport.Frequencies(childComplexity), true

	case "Airport.gpsCode":
		if e.complexity.Airport.GpsCode == nil {
			break
		}

		return e.complexity.Airport.GpsCode(childComplexity), true

	case "Airport.id":
		if e.complexity.Airport.ID == nil {
			break
		}

		return e.complexity.Airport.ID(childComplexity), true

	case "Airport.iataCode":
		if e.complexity.Airport.IataCode == nil {
			break
		}

		return e.complexity.Airport.IataCode(childComplexity), true

	case "Airport.icaoCode":
		if e.complexity.Airport.IcaoCode == nil {
			break
		}

		return e.complexity.Airport.IcaoCode(childComplexity), true

	case "Airport.identifier":
		if e.complexity.Airport.Identifier == nil {
			break
		}

		return e.complexity.Airport.Identifier(childComplexity), true

	case "Airport.importID":
		if e.complexity.Airport.ImportID == nil {
			break
		}

		return e.complexity.Airport.ImportID(childComplexity), true

	case "Airport.importance":
		if e.complexity.Airport.Importance == nil {
			break
		}

		return e.complexity.Airport.Importance(childComplexity), true

	case "Airport.keywords":
		if e.complexity.Airport.Keywords == nil {
			break
		}

		return e.complexity.Airport.Keywords(childComplexity), true

	case "Airport.lastUpdated":
		if e.complexity.Airport.LastUpdated == nil {
			break
		}

		return e.complexity.Airport.LastUpdated(childComplexity), true

	case "Airport.latitude":
		if e.complexity.Airport.Latitude == nil {
			break
		}

		return e.complexity.Airport.Latitude(childComplexity), true

	case "Airport.localCode":
		if e.complexity.Airport.LocalCode == nil {
			break
		}

		return e.complexity.Airport.LocalCode(childComplexity), true

	case "Airport.longitude":
		if e.complexity.Airport.Longitude == nil {
			break
		}

		return e.complexity.Airport.Longitude(childComplexity), true

	case "Airport.municipality":
		if e.complexity.Airport.Municipality == nil {
			break
		}

		return e.complexity.Airport.Municipality(childComplexity), true

	case "Airport.name":
		if e.complexity.Airport.Name == nil {
			break
		}

		return e.complexity.Airport.Name(childComplexity), true

	case "Airport.region":
		if e.complexity.Airport.Region == nil {
			break
		}

		return e.complexity.Airport.Region(childComplexity), true

	case "Airport.runways":
		if e.complexity.Airport.Runways == nil {
			break
		}

		args, err := ec.field_Airport_runways_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Airport.Runways(childComplexity, args["closed"].(*bool)), true

	case "Airport.scheduledService":
		if e.complexity.Airport.ScheduledService == nil {
			break
		}

		return e.complexity.Airport.ScheduledService(childComplexity), true

	case "Airport.station":
		if e.complexity.Airport.Station == nil {
			break
		}

		return e.complexity.Airport.Station(childComplexity), true

	case "Airport.stationsVicinity":
		if e.complexity.Airport.StationsVicinity == nil {
			break
		}

		args, err := ec.field_Airport_stationsVicinity_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Airport.StationsVicinity(childComplexity, args["first"].(*int), args["radius"].(*float64)), true

	case "Airport.timezone":
		if e.complexity.Airport.Timezone == nil {
			break
		}

		return e.complexity.Airport.Timezone(childComplexity), true

	case "Airport.type":
		if e.complexity.Airport.Type == nil {
			break
		}

		return e.complexity.Airport.Type(childComplexity), true

	case "Airport.website":
		if e.complexity.Airport.Website == nil {
			break
		}

		return e.complexity.Airport.Website(childComplexity), true

	case "Airport.wikipedia":
		if e.complexity.Airport.Wikipedia == nil {
			break
		}

		return e.complexity.Airport.Wikipedia(childComplexity), true

	case "AirportConnection.edges":
		if e.complexity.AirportConnection.Edges == nil {
			break
		}

		return e.complexity.AirportConnection.Edges(childComplexity), true

	case "AirportConnection.pageInfo":
		if e.complexity.AirportConnection.PageInfo == nil {
			break
		}

		return e.complexity.AirportConnection.PageInfo(childComplexity), true

	case "AirportConnection.totalCount":
		if e.complexity.AirportConnection.TotalCount == nil {
			break
		}

		return e.complexity.AirportConnection.TotalCount(childComplexity), true

	case "AirportEdge.cursor":
		if e.complexity.AirportEdge.Cursor == nil {
			break
		}

		return e.complexity.AirportEdge.Cursor(childComplexity), true

	case "AirportEdge.node":
		if e.complexity.AirportEdge.Node == nil {
			break
		}

		return e.complexity.AirportEdge.Node(childComplexity), true

	case "Country.code":
		if e.complexity.Country.Code == nil {
			break
		}

		return e.complexity.Country.Code(childComplexity), true

	case "Country.continent":
		if e.complexity.Country.Continent == nil {
			break
		}

		return e.complexity.Country.Continent(childComplexity), true

	case "Country.id":
		if e.complexity.Country.ID == nil {
			break
		}

		return e.complexity.Country.ID(childComplexity), true

	case "Country.importID":
		if e.complexity.Country.ImportID == nil {
			break
		}

		return e.complexity.Country.ImportID(childComplexity), true

	case "Country.keywords":
		if e.complexity.Country.Keywords == nil {
			break
		}

		return e.complexity.Country.Keywords(childComplexity), true

	case "Country.lastUpdated":
		if e.complexity.Country.LastUpdated == nil {
			break
		}

		return e.complexity.Country.LastUpdated(childComplexity), true

	case "Country.name":
		if e.complexity.Country.Name == nil {
			break
		}

		return e.complexity.Country.Name(childComplexity), true

	case "Country.wikipediaLink":
		if e.complexity.Country.WikipediaLink == nil {
			break
		}

		return e.complexity.Country.WikipediaLink(childComplexity), true

	case "Forecast.altimeter":
		if e.complexity.Forecast.Altimeter == nil {
			break
		}

		args, err := ec.field_Forecast_altimeter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Forecast.Altimeter(childComplexity, args["unit"].(model.PressureUnit)), true

	case "Forecast.changeIndicator":
		if e.complexity.Forecast.ChangeIndicator == nil {
			break
		}

		return e.complexity.Forecast.ChangeIndicator(childComplexity), true

	case "Forecast.changeProbability":
		if e.complexity.Forecast.ChangeProbability == nil {
			break
		}

		return e.complexity.Forecast.ChangeProbability(childComplexity), true

	case "Forecast.changeTime":
		if e.complexity.Forecast.ChangeTime == nil {
			break
		}

		return e.complexity.Forecast.ChangeTime(childComplexity), true

	case "Forecast.fromTime":
		if e.complexity.Forecast.FromTime == nil {
			break
		}

		return e.complexity.Forecast.FromTime(childComplexity), true

	case "Forecast.id":
		if e.complexity.Forecast.ID == nil {
			break
		}

		return e.complexity.Forecast.ID(childComplexity), true

	case "Forecast.icingConditions":
		if e.complexity.Forecast.IcingConditions == nil {
			break
		}

		return e.complexity.Forecast.IcingConditions(childComplexity), true

	case "Forecast.notDecoded":
		if e.complexity.Forecast.NotDecoded == nil {
			break
		}

		return e.complexity.Forecast.NotDecoded(childComplexity), true

	case "Forecast.skyConditions":
		if e.complexity.Forecast.SkyConditions == nil {
			break
		}

		return e.complexity.Forecast.SkyConditions(childComplexity), true

	case "Forecast.temperatureData":
		if e.complexity.Forecast.TemperatureData == nil {
			break
		}

		return e.complexity.Forecast.TemperatureData(childComplexity), true

	case "Forecast.toTime":
		if e.complexity.Forecast.ToTime == nil {
			break
		}

		return e.complexity.Forecast.ToTime(childComplexity), true

	case "Forecast.turbulenceConditions":
		if e.complexity.Forecast.TurbulenceConditions == nil {
			break
		}

		return e.complexity.Forecast.TurbulenceConditions(childComplexity), true

	case "Forecast.visibilityHorizontal":
		if e.complexity.Forecast.VisibilityHorizontal == nil {
			break
		}

		args, err := ec.field_Forecast_visibilityHorizontal_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Forecast.VisibilityHorizontal(childComplexity, args["unit"].(model.LengthUnit)), true

	case "Forecast.visibilityVertical":
		if e.complexity.Forecast.VisibilityVertical == nil {
			break
		}

		args, err := ec.field_Forecast_visibilityVertical_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Forecast.VisibilityVertical(childComplexity, args["unit"].(model.LengthUnit)), true

	case "Forecast.weather":
		if e.complexity.Forecast.Weather == nil {
			break
		}

		return e.complexity.Forecast.Weather(childComplexity), true

	case "Forecast.windDirection":
		if e.complexity.Forecast.WindDirection == nil {
			break
		}

		return e.complexity.Forecast.WindDirection(childComplexity), true

	case "Forecast.windGust":
		if e.complexity.Forecast.WindGust == nil {
			break
		}

		args, err := ec.field_Forecast_windGust_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Forecast.WindGust(childComplexity, args["unit"].(model.SpeedUnit)), true

	case "Forecast.windShearDirection":
		if e.complexity.Forecast.WindShearDirection == nil {
			break
		}

		return e.complexity.Forecast.WindShearDirection(childComplexity), true

	case "Forecast.windShearHeight":
		if e.complexity.Forecast.WindShearHeight == nil {
			break
		}

		args, err := ec.field_Forecast_windShearHeight_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Forecast.WindShearHeight(childComplexity, args["unit"].(model.LengthUnit)), true

	case "Forecast.windShearSpeed":
		if e.complexity.Forecast.WindShearSpeed == nil {
			break
		}

		args, err := ec.field_Forecast_windShearSpeed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Forecast.WindShearSpeed(childComplexity, args["unit"].(model.SpeedUnit)), true

	case "Forecast.windSpeed":
		if e.complexity.Forecast.WindSpeed == nil {
			break
		}

		args, err := ec.field_Forecast_windSpeed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Forecast.WindSpeed(childComplexity, args["unit"].(model.SpeedUnit)), true

	case "Frequency.airport":
		if e.complexity.Frequency.Airport == nil {
			break
		}

		return e.complexity.Frequency.Airport(childComplexity), true

	case "Frequency.description":
		if e.complexity.Frequency.Description == nil {
			break
		}

		return e.complexity.Frequency.Description(childComplexity), true

	case "Frequency.frequency":
		if e.complexity.Frequency.Frequency == nil {
			break
		}

		return e.complexity.Frequency.Frequency(childComplexity), true

	case "Frequency.id":
		if e.complexity.Frequency.ID == nil {
			break
		}

		return e.complexity.Frequency.ID(childComplexity), true

	case "Frequency.importID":
		if e.complexity.Frequency.ImportID == nil {
			break
		}

		return e.complexity.Frequency.ImportID(childComplexity), true

	case "Frequency.lastUpdated":
		if e.complexity.Frequency.LastUpdated == nil {
			break
		}

		return e.complexity.Frequency.LastUpdated(childComplexity), true

	case "Frequency.type":
		if e.complexity.Frequency.Type == nil {
			break
		}

		return e.complexity.Frequency.Type(childComplexity), true

	case "IcingCondition.id":
		if e.complexity.IcingCondition.ID == nil {
			break
		}

		return e.complexity.IcingCondition.ID(childComplexity), true

	case "IcingCondition.intensity":
		if e.complexity.IcingCondition.Intensity == nil {
			break
		}

		return e.complexity.IcingCondition.Intensity(childComplexity), true

	case "IcingCondition.maxAltitude":
		if e.complexity.IcingCondition.MaxAltitude == nil {
			break
		}

		args, err := ec.field_IcingCondition_maxAltitude_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.IcingCondition.MaxAltitude(childComplexity, args["unit"].(model.LengthUnit)), true

	case "IcingCondition.minAltitude":
		if e.complexity.IcingCondition.MinAltitude == nil {
			break
		}

		args, err := ec.field_IcingCondition_minAltitude_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.IcingCondition.MinAltitude(childComplexity, args["unit"].(model.LengthUnit)), true

	case "Metar.altimeter":
		if e.complexity.Metar.Altimeter == nil {
			break
		}

		args, err := ec.field_Metar_altimeter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.Altimeter(childComplexity, args["unit"].(model.PressureUnit)), true

	case "Metar.dewpoint":
		if e.complexity.Metar.Dewpoint == nil {
			break
		}

		args, err := ec.field_Metar_dewpoint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.Dewpoint(childComplexity, args["unit"].(model.TemperatureUnit)), true

	case "Metar.flightCategory":
		if e.complexity.Metar.FlightCategory == nil {
			break
		}

		return e.complexity.Metar.FlightCategory(childComplexity), true

	case "Metar.id":
		if e.complexity.Metar.ID == nil {
			break
		}

		return e.complexity.Metar.ID(childComplexity), true

	case "Metar.importTime":
		if e.complexity.Metar.ImportTime == nil {
			break
		}

		return e.complexity.Metar.ImportTime(childComplexity), true

	case "Metar.maxTemp24":
		if e.complexity.Metar.MaxTemp24 == nil {
			break
		}

		return e.complexity.Metar.MaxTemp24(childComplexity), true

	case "Metar.maxTemp6":
		if e.complexity.Metar.MaxTemp6 == nil {
			break
		}

		return e.complexity.Metar.MaxTemp6(childComplexity), true

	case "Metar.metarType":
		if e.complexity.Metar.MetarType == nil {
			break
		}

		return e.complexity.Metar.MetarType(childComplexity), true

	case "Metar.minTemp24":
		if e.complexity.Metar.MinTemp24 == nil {
			break
		}

		return e.complexity.Metar.MinTemp24(childComplexity), true

	case "Metar.minTemp6":
		if e.complexity.Metar.MinTemp6 == nil {
			break
		}

		return e.complexity.Metar.MinTemp6(childComplexity), true

	case "Metar.observationTime":
		if e.complexity.Metar.ObservationTime == nil {
			break
		}

		return e.complexity.Metar.ObservationTime(childComplexity), true

	case "Metar.precipitation":
		if e.complexity.Metar.Precipitation == nil {
			break
		}

		return e.complexity.Metar.Precipitation(childComplexity), true

	case "Metar.precipitation24":
		if e.complexity.Metar.Precipitation24 == nil {
			break
		}

		return e.complexity.Metar.Precipitation24(childComplexity), true

	case "Metar.precipitation3":
		if e.complexity.Metar.Precipitation3 == nil {
			break
		}

		return e.complexity.Metar.Precipitation3(childComplexity), true

	case "Metar.precipitation6":
		if e.complexity.Metar.Precipitation6 == nil {
			break
		}

		return e.complexity.Metar.Precipitation6(childComplexity), true

	case "Metar.presentWeather":
		if e.complexity.Metar.PresentWeather == nil {
			break
		}

		return e.complexity.Metar.PresentWeather(childComplexity), true

	case "Metar.pressureTendency":
		if e.complexity.Metar.PressureTendency == nil {
			break
		}

		args, err := ec.field_Metar_pressureTendency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.PressureTendency(childComplexity, args["unit"].(model.PressureUnit)), true

	case "Metar.qualityControlAutoStation":
		if e.complexity.Metar.QualityControlAutoStation == nil {
			break
		}

		return e.complexity.Metar.QualityControlAutoStation(childComplexity), true

	case "Metar.qualityControlCorrected":
		if e.complexity.Metar.QualityControlCorrected == nil {
			break
		}

		return e.complexity.Metar.QualityControlCorrected(childComplexity), true

	case "Metar.qualityControlFreezingRainSensorOff":
		if e.complexity.Metar.QualityControlFreezingRainSensorOff == nil {
			break
		}

		return e.complexity.Metar.QualityControlFreezingRainSensorOff(childComplexity), true

	case "Metar.qualityControlLightningSensorOff":
		if e.complexity.Metar.QualityControlLightningSensorOff == nil {
			break
		}

		return e.complexity.Metar.QualityControlLightningSensorOff(childComplexity), true

	case "Metar.qualityControlMaintenanceIndicatorOn":
		if e.complexity.Metar.QualityControlMaintenanceIndicatorOn == nil {
			break
		}

		return e.complexity.Metar.QualityControlMaintenanceIndicatorOn(childComplexity), true

	case "Metar.qualityControlNoSignal":
		if e.complexity.Metar.QualityControlNoSignal == nil {
			break
		}

		return e.complexity.Metar.QualityControlNoSignal(childComplexity), true

	case "Metar.qualityControlPresentWeatherSensorOff":
		if e.complexity.Metar.QualityControlPresentWeatherSensorOff == nil {
			break
		}

		return e.complexity.Metar.QualityControlPresentWeatherSensorOff(childComplexity), true

	case "Metar.rawText":
		if e.complexity.Metar.RawText == nil {
			break
		}

		return e.complexity.Metar.RawText(childComplexity), true

	case "Metar.seaLevelPressure":
		if e.complexity.Metar.SeaLevelPressure == nil {
			break
		}

		args, err := ec.field_Metar_seaLevelPressure_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.SeaLevelPressure(childComplexity, args["unit"].(model.PressureUnit)), true

	case "Metar.skyConditions":
		if e.complexity.Metar.SkyConditions == nil {
			break
		}

		return e.complexity.Metar.SkyConditions(childComplexity), true

	case "Metar.snowDepth":
		if e.complexity.Metar.SnowDepth == nil {
			break
		}

		args, err := ec.field_Metar_snowDepth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.SnowDepth(childComplexity, args["unit"].(model.SmallLengthUnit)), true

	case "Metar.station":
		if e.complexity.Metar.Station == nil {
			break
		}

		return e.complexity.Metar.Station(childComplexity), true

	case "Metar.temperature":
		if e.complexity.Metar.Temperature == nil {
			break
		}

		args, err := ec.field_Metar_temperature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.Temperature(childComplexity, args["unit"].(model.TemperatureUnit)), true

	case "Metar.verticalVisibility":
		if e.complexity.Metar.VerticalVisibility == nil {
			break
		}

		args, err := ec.field_Metar_verticalVisibility_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.VerticalVisibility(childComplexity, args["unit"].(model.LengthUnit)), true

	case "Metar.visibility":
		if e.complexity.Metar.Visibility == nil {
			break
		}

		args, err := ec.field_Metar_visibility_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.Visibility(childComplexity, args["unit"].(model.LengthUnit)), true

	case "Metar.windDirection":
		if e.complexity.Metar.WindDirection == nil {
			break
		}

		return e.complexity.Metar.WindDirection(childComplexity), true

	case "Metar.windGust":
		if e.complexity.Metar.WindGust == nil {
			break
		}

		args, err := ec.field_Metar_windGust_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.WindGust(childComplexity, args["unit"].(model.SpeedUnit)), true

	case "Metar.windSpeed":
		if e.complexity.Metar.WindSpeed == nil {
			break
		}

		args, err := ec.field_Metar_windSpeed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Metar.WindSpeed(childComplexity, args["unit"].(model.SpeedUnit)), true

	case "MetarConnection.edges":
		if e.complexity.MetarConnection.Edges == nil {
			break
		}

		return e.complexity.MetarConnection.Edges(childComplexity), true

	case "MetarConnection.pageInfo":
		if e.complexity.MetarConnection.PageInfo == nil {
			break
		}

		return e.complexity.MetarConnection.PageInfo(childComplexity), true

	case "MetarConnection.totalCount":
		if e.complexity.MetarConnection.TotalCount == nil {
			break
		}

		return e.complexity.MetarConnection.TotalCount(childComplexity), true

	case "MetarEdge.cursor":
		if e.complexity.MetarEdge.Cursor == nil {
			break
		}

		return e.complexity.MetarEdge.Cursor(childComplexity), true

	case "MetarEdge.node":
		if e.complexity.MetarEdge.Node == nil {
			break
		}

		return e.complexity.MetarEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.getAirport":
		if e.complexity.Query.GetAirport == nil {
			break
		}

		args, err := ec.field_Query_getAirport_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAirport(childComplexity, args["id"].(*string), args["identifier"].(*string), args["icao"].(*string), args["iata"].(*string)), true

	case "Query.getAirports":
		if e.complexity.Query.GetAirports == nil {
			break
		}

		args, err := ec.field_Query_getAirports_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAirports(childComplexity, args["first"].(*int), args["after"].(*ent.Cursor), args["before"].(*ent.Cursor), args["last"].(*int), args["identifier"].(*string), args["icao"].(*string), args["iata"].(*string), args["type"].(*airport.Type), args["search"].(*string), args["hasWeather"].(*bool), args["order"].([]*ent.AirportOrder)), true

	case "Query.getStation":
		if e.complexity.Query.GetStation == nil {
			break
		}

		args, err := ec.field_Query_getStation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStation(childComplexity, args["id"].(*string), args["identifier"].(*string)), true

	case "Query.getStations":
		if e.complexity.Query.GetStations == nil {
			break
		}

		args, err := ec.field_Query_getStations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStations(childComplexity, args["first"].(*int), args["after"].(*ent.Cursor), args["before"].(*ent.Cursor), args["last"].(*int), args["identifier"].(*string)), true

	case "Region.code":
		if e.complexity.Region.Code == nil {
			break
		}

		return e.complexity.Region.Code(childComplexity), true

	case "Region.id":
		if e.complexity.Region.ID == nil {
			break
		}

		return e.complexity.Region.ID(childComplexity), true

	case "Region.importID":
		if e.complexity.Region.ImportID == nil {
			break
		}

		return e.complexity.Region.ImportID(childComplexity), true

	case "Region.keywords":
		if e.complexity.Region.Keywords == nil {
			break
		}

		return e.complexity.Region.Keywords(childComplexity), true

	case "Region.lastUpdated":
		if e.complexity.Region.LastUpdated == nil {
			break
		}

		return e.complexity.Region.LastUpdated(childComplexity), true

	case "Region.localCode":
		if e.complexity.Region.LocalCode == nil {
			break
		}

		return e.complexity.Region.LocalCode(childComplexity), true

	case "Region.name":
		if e.complexity.Region.Name == nil {
			break
		}

		return e.complexity.Region.Name(childComplexity), true

	case "Region.wikipediaLink":
		if e.complexity.Region.WikipediaLink == nil {
			break
		}

		return e.complexity.Region.WikipediaLink(childComplexity), true

	case "Runway.airport":
		if e.complexity.Runway.Airport == nil {
			break
		}

		return e.complexity.Runway.Airport(childComplexity), true

	case "Runway.closed":
		if e.complexity.Runway.Closed == nil {
			break
		}

		return e.complexity.Runway.Closed(childComplexity), true

	case "Runway.highRunwayDisplacedThreshold":
		if e.complexity.Runway.HighRunwayDisplacedThreshold == nil {
			break
		}

		return e.complexity.Runway.HighRunwayDisplacedThreshold(childComplexity), true

	case "Runway.highRunwayElevation":
		if e.complexity.Runway.HighRunwayElevation == nil {
			break
		}

		return e.complexity.Runway.HighRunwayElevation(childComplexity), true

	case "Runway.highRunwayHeading":
		if e.complexity.Runway.HighRunwayHeading == nil {
			break
		}

		return e.complexity.Runway.HighRunwayHeading(childComplexity), true

	case "Runway.highRunwayIdentifier":
		if e.complexity.Runway.HighRunwayIdentifier == nil {
			break
		}

		return e.complexity.Runway.HighRunwayIdentifier(childComplexity), true

	case "Runway.highRunwayLatitude":
		if e.complexity.Runway.HighRunwayLatitude == nil {
			break
		}

		return e.complexity.Runway.HighRunwayLatitude(childComplexity), true

	case "Runway.highRunwayLongitude":
		if e.complexity.Runway.HighRunwayLongitude == nil {
			break
		}

		return e.complexity.Runway.HighRunwayLongitude(childComplexity), true

	case "Runway.id":
		if e.complexity.Runway.ID == nil {
			break
		}

		return e.complexity.Runway.ID(childComplexity), true

	case "Runway.importID":
		if e.complexity.Runway.ImportID == nil {
			break
		}

		return e.complexity.Runway.ImportID(childComplexity), true

	case "Runway.lastUpdated":
		if e.complexity.Runway.LastUpdated == nil {
			break
		}

		return e.complexity.Runway.LastUpdated(childComplexity), true

	case "Runway.length":
		if e.complexity.Runway.Length == nil {
			break
		}

		return e.complexity.Runway.Length(childComplexity), true

	case "Runway.lighted":
		if e.complexity.Runway.Lighted == nil {
			break
		}

		return e.complexity.Runway.Lighted(childComplexity), true

	case "Runway.lowRunwayDisplacedThreshold":
		if e.complexity.Runway.LowRunwayDisplacedThreshold == nil {
			break
		}

		return e.complexity.Runway.LowRunwayDisplacedThreshold(childComplexity), true

	case "Runway.lowRunwayElevation":
		if e.complexity.Runway.LowRunwayElevation == nil {
			break
		}

		return e.complexity.Runway.LowRunwayElevation(childComplexity), true

	case "Runway.lowRunwayHeading":
		if e.complexity.Runway.LowRunwayHeading == nil {
			break
		}

		return e.complexity.Runway.LowRunwayHeading(childComplexity), true

	case "Runway.lowRunwayIdentifier":
		if e.complexity.Runway.LowRunwayIdentifier == nil {
			break
		}

		return e.complexity.Runway.LowRunwayIdentifier(childComplexity), true

	case "Runway.lowRunwayLatitude":
		if e.complexity.Runway.LowRunwayLatitude == nil {
			break
		}

		return e.complexity.Runway.LowRunwayLatitude(childComplexity), true

	case "Runway.lowRunwayLongitude":
		if e.complexity.Runway.LowRunwayLongitude == nil {
			break
		}

		return e.complexity.Runway.LowRunwayLongitude(childComplexity), true

	case "Runway.surface":
		if e.complexity.Runway.Surface == nil {
			break
		}

		return e.complexity.Runway.Surface(childComplexity), true

	case "Runway.width":
		if e.complexity.Runway.Width == nil {
			break
		}

		return e.complexity.Runway.Width(childComplexity), true

	case "SkyCondition.cloudBase":
		if e.complexity.SkyCondition.CloudBase == nil {
			break
		}

		args, err := ec.field_SkyCondition_cloudBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SkyCondition.CloudBase(childComplexity, args["unit"].(model.LengthUnit)), true

	case "SkyCondition.cloudType":
		if e.complexity.SkyCondition.CloudType == nil {
			break
		}

		return e.complexity.SkyCondition.CloudType(childComplexity), true

	case "SkyCondition.id":
		if e.complexity.SkyCondition.ID == nil {
			break
		}

		return e.complexity.SkyCondition.ID(childComplexity), true

	case "SkyCondition.skyCover":
		if e.complexity.SkyCondition.SkyCover == nil {
			break
		}

		return e.complexity.SkyCondition.SkyCover(childComplexity), true

	case "StationWithDistance.distance":
		if e.complexity.StationWithDistance.Distance == nil {
			break
		}

		return e.complexity.StationWithDistance.Distance(childComplexity), true

	case "StationWithDistance.station":
		if e.complexity.StationWithDistance.Station == nil {
			break
		}

		return e.complexity.StationWithDistance.Station(childComplexity), true

	case "Taf.bulletinTime":
		if e.complexity.Taf.BulletinTime == nil {
			break
		}

		return e.complexity.Taf.BulletinTime(childComplexity), true

	case "Taf.forecast":
		if e.complexity.Taf.Forecast == nil {
			break
		}

		return e.complexity.Taf.Forecast(childComplexity), true

	case "Taf.id":
		if e.complexity.Taf.ID == nil {
			break
		}

		return e.complexity.Taf.ID(childComplexity), true

	case "Taf.importTime":
		if e.complexity.Taf.ImportTime == nil {
			break
		}

		return e.complexity.Taf.ImportTime(childComplexity), true

	case "Taf.issueTime":
		if e.complexity.Taf.IssueTime == nil {
			break
		}

		return e.complexity.Taf.IssueTime(childComplexity), true

	case "Taf.rawText":
		if e.complexity.Taf.RawText == nil {
			break
		}

		return e.complexity.Taf.RawText(childComplexity), true

	case "Taf.remarks":
		if e.complexity.Taf.Remarks == nil {
			break
		}

		return e.complexity.Taf.Remarks(childComplexity), true

	case "Taf.skyConditions":
		if e.complexity.Taf.SkyConditions == nil {
			break
		}

		return e.complexity.Taf.SkyConditions(childComplexity), true

	case "Taf.station":
		if e.complexity.Taf.Station == nil {
			break
		}

		return e.complexity.Taf.Station(childComplexity), true

	case "Taf.validFromTime":
		if e.complexity.Taf.ValidFromTime == nil {
			break
		}

		return e.complexity.Taf.ValidFromTime(childComplexity), true

	case "Taf.validToTime":
		if e.complexity.Taf.ValidToTime == nil {
			break
		}

		return e.complexity.Taf.ValidToTime(childComplexity), true

	case "TafConnection.edges":
		if e.complexity.TafConnection.Edges == nil {
			break
		}

		return e.complexity.TafConnection.Edges(childComplexity), true

	case "TafConnection.pageInfo":
		if e.complexity.TafConnection.PageInfo == nil {
			break
		}

		return e.complexity.TafConnection.PageInfo(childComplexity), true

	case "TafConnection.totalCount":
		if e.complexity.TafConnection.TotalCount == nil {
			break
		}

		return e.complexity.TafConnection.TotalCount(childComplexity), true

	case "TafEdge.cursor":
		if e.complexity.TafEdge.Cursor == nil {
			break
		}

		return e.complexity.TafEdge.Cursor(childComplexity), true

	case "TafEdge.node":
		if e.complexity.TafEdge.Node == nil {
			break
		}

		return e.complexity.TafEdge.Node(childComplexity), true

	case "TemperatureData.id":
		if e.complexity.TemperatureData.ID == nil {
			break
		}

		return e.complexity.TemperatureData.ID(childComplexity), true

	case "TemperatureData.maxTemperature":
		if e.complexity.TemperatureData.MaxTemperature == nil {
			break
		}

		args, err := ec.field_TemperatureData_maxTemperature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TemperatureData.MaxTemperature(childComplexity, args["unit"].(model.TemperatureUnit)), true

	case "TemperatureData.minTemperature":
		if e.complexity.TemperatureData.MinTemperature == nil {
			break
		}

		args, err := ec.field_TemperatureData_minTemperature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TemperatureData.MinTemperature(childComplexity, args["unit"].(model.TemperatureUnit)), true

	case "TemperatureData.temperature":
		if e.complexity.TemperatureData.Temperature == nil {
			break
		}

		args, err := ec.field_TemperatureData_temperature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TemperatureData.Temperature(childComplexity, args["unit"].(model.TemperatureUnit)), true

	case "TemperatureData.validTime":
		if e.complexity.TemperatureData.ValidTime == nil {
			break
		}

		return e.complexity.TemperatureData.ValidTime(childComplexity), true

	case "TurbulenceCondition.id":
		if e.complexity.TurbulenceCondition.ID == nil {
			break
		}

		return e.complexity.TurbulenceCondition.ID(childComplexity), true

	case "TurbulenceCondition.intensity":
		if e.complexity.TurbulenceCondition.Intensity == nil {
			break
		}

		return e.complexity.TurbulenceCondition.Intensity(childComplexity), true

	case "TurbulenceCondition.maxAltitude":
		if e.complexity.TurbulenceCondition.MaxAltitude == nil {
			break
		}

		args, err := ec.field_TurbulenceCondition_maxAltitude_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TurbulenceCondition.MaxAltitude(childComplexity, args["unit"].(model.LengthUnit)), true

	case "TurbulenceCondition.minAltitude":
		if e.complexity.TurbulenceCondition.MinAltitude == nil {
			break
		}

		args, err := ec.field_TurbulenceCondition_minAltitude_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TurbulenceCondition.MinAltitude(childComplexity, args["unit"].(model.LengthUnit)), true

	case "WeatherStation.airport":
		if e.complexity.WeatherStation.Airport == nil {
			break
		}

		return e.complexity.WeatherStation.Airport(childComplexity), true

	case "WeatherStation.elevation":
		if e.complexity.WeatherStation.Elevation == nil {
			break
		}

		return e.complexity.WeatherStation.Elevation(childComplexity), true

	case "WeatherStation.id":
		if e.complexity.WeatherStation.ID == nil {
			break
		}

		return e.complexity.WeatherStation.ID(childComplexity), true

	case "WeatherStation.latitude":
		if e.complexity.WeatherStation.Latitude == nil {
			break
		}

		return e.complexity.WeatherStation.Latitude(childComplexity), true

	case "WeatherStation.longitude":
		if e.complexity.WeatherStation.Longitude == nil {
			break
		}

		return e.complexity.WeatherStation.Longitude(childComplexity), true

	case "WeatherStation.metars":
		if e.complexity.WeatherStation.Metars == nil {
			break
		}

		args, err := ec.field_WeatherStation_metars_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WeatherStation.Metars(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int)), true

	case "WeatherStation.stationID":
		if e.complexity.WeatherStation.StationID == nil {
			break
		}

		return e.complexity.WeatherStation.StationID(childComplexity), true

	case "WeatherStation.tafs":
		if e.complexity.WeatherStation.Tafs == nil {
			break
		}

		args, err := ec.field_WeatherStation_tafs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WeatherStation.Tafs(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int)), true

	case "WeatherStationConnection.edges":
		if e.complexity.WeatherStationConnection.Edges == nil {
			break
		}

		return e.complexity.WeatherStationConnection.Edges(childComplexity), true

	case "WeatherStationConnection.pageInfo":
		if e.complexity.WeatherStationConnection.PageInfo == nil {
			break
		}

		return e.complexity.WeatherStationConnection.PageInfo(childComplexity), true

	case "WeatherStationConnection.totalCount":
		if e.complexity.WeatherStationConnection.TotalCount == nil {
			break
		}

		return e.complexity.WeatherStationConnection.TotalCount(childComplexity), true

	case "WeatherStationEdge.cursor":
		if e.complexity.WeatherStationEdge.Cursor == nil {
			break
		}

		return e.complexity.WeatherStationEdge.Cursor(childComplexity), true

	case "WeatherStationEdge.node":
		if e.complexity.WeatherStationEdge.Node == nil {
			break
		}

		return e.complexity.WeatherStationEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAirportOrder,
		ec.unmarshalInputTafOrder,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Airport {
  """The unique identifier of the record."""
  id: ID!
  """The unique identifier of the import."""
  importID: Int!
  """The last time the record was updated/created."""
  lastUpdated: Time!
  """The four-letter ICAO code of the airport."""
  icaoCode: String
  """The three-letter IATA code for the airport."""
  iataCode: String
  """This will be the ICAO code if available. Otherwise, it will be a local airport code (if no conflict), or if nothing else is available, an internally-generated code starting with the ISO2 country code, followed by a dash and a four-digit number."""
  identifier: String!
  """Type of airport."""
  type: AirportType!
  """Importance of the airport."""
  importance: Int!
  """The official airport name, including "Airport", "Airstrip", etc."""
  name: String!
  """Latitude of the airport in decimal degrees (positive is north)."""
  latitude: Float!
  """Longitude of the airport in decimal degrees (positive is east)."""
  longitude: Float!
  """The timezone of the airport."""
  timezone: String
  """Elevation of the airport, in feet."""
  elevation: Int
  """The primary municipality that the airport serves (when available). Note that this is not necessarily the municipality where the airport is physically located."""
  municipality: String
  """Whether the airport has scheduled airline service."""
  scheduledService: Boolean!
  """The code that an aviation GPS database (such as Jeppesen's or Garmin's) would normally use for the airport. This will always be the ICAO code if one exists. Note that, unlike the ident column, this is not guaranteed to be globally unique."""
  gpsCode: String
  """The local country code for the airport, if different from the gps_code and iata_code fields (used mainly for US airports)."""
  localCode: String
  """The URL of the airport's website."""
  website: String
  """The URL of the airport's Wikipedia page."""
  wikipedia: String
  """Extra keywords/phrases to assist with search. May include former names for the airport, alternate codes, names in other languages, nearby tourist destinations, etc."""
  keywords: [String!]!
  region: Region
  country: Country
  frequencies: [Frequency!]
  station: WeatherStation
}
"""Ordering options for Airport connections"""
input AirportOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Airports."""
  field: AirportOrderField!
}
"""Properties by which Airport connections can be ordered."""
enum AirportOrderField {
  ICAO_CODE
  IMPORTANCE
}
"""AirportType is enum for the field type"""
enum AirportType @goModel(model: "metar.gg/ent/airport.Type") {
  large_airport
  medium_airport
  small_airport
  closed_airport
  heliport
  seaplane_base
}
type Country {
  """The unique identifier of the record."""
  id: ID!
  """The unique identifier of the import."""
  importID: Int!
  """The last time the record was updated/created."""
  lastUpdated: Time!
  """The ISO 3166-1 alpha-2 code of the country. A handful of unofficial, non-ISO codes are also in use, such as "XK" for Kosovo."""
  code: String!
  """The name of the country."""
  name: String!
  """Where the airport is (primarily) located."""
  continent: CountryContinent!
  """The wikipedia link of the country."""
  wikipediaLink: String!
  """Keywords that can be used to search for the country."""
  keywords: [String!]!
}
"""CountryContinent is enum for the field continent"""
enum CountryContinent @goModel(model: "metar.gg/ent/country.Continent") {
  AF
  AN
  AS
  EU
  NA
  SA
  OC
}
type Forecast {
  """The unique identifier of the record."""
  id: ID!
  """The start time of the forecast period."""
  fromTime: Time!
  """The end time of the forecast period."""
  toTime: Time!
  """The change indicator."""
  changeIndicator: ForecastChangeIndicator
  """The time of the change."""
  changeTime: Time
  """The probability of the change."""
  changeProbability: Int
  """The wind direction in degrees."""
  windDirection: Int
  """The wind shear direction in degrees."""
  windShearDirection: Int
  """The weather string."""
  weather: String
  """The not decoded string."""
  notDecoded: String
  skyConditions: [SkyCondition!]
  turbulenceConditions: [TurbulenceCondition!]
  icingConditions: [IcingCondition!]
  temperatureData: [TemperatureData!]
}
"""ForecastChangeIndicator is enum for the field change_indicator"""
enum ForecastChangeIndicator @goModel(model: "metar.gg/ent/forecast.ChangeIndicator") {
  BECMG
  FM
  TEMPO
  PROB
}
type Frequency {
  """The unique identifier of the record."""
  id: ID!
  """The unique identifier of the import."""
  importID: Int!
  """The last time the record was updated/created."""
  lastUpdated: Time!
  """A code for the frequency type. Some common values are "TWR" (tower), "ATF" or "CTAF" (common traffic frequency), "GND" (ground control), "RMP" (ramp control), "ATIS" (automated weather), "RCO" (remote radio outlet), "ARR" (arrivals), "DEP" (departures), "UNICOM" (monitored ground station), and "RDO" (a flight-service station)."""
  type: String!
  """A description of the frequency."""
  description: String!
  """Radio frequency in megahertz. Note that the same frequency may appear multiple times for an airport, serving different functions"""
  frequency: Float!
  airport: Airport
}
type IcingCondition {
  """The unique identifier of the record."""
  id: ID!
  """The intensity of the icing."""
  intensity: String!
}
type Metar {
  """The unique identifier of the record."""
  id: ID!
  """The raw METAR text."""
  rawText: String!
  """The time the METAR was observed."""
  observationTime: Time!
  """The time the METAR was imported."""
  importTime: Time!
  """The wind direction in degrees, or 0 if calm."""
  windDirection: Int!
  """The present weather string."""
  presentWeather: String
  flightCategory: MetarFlightCategory
  """Quality control corrected."""
  qualityControlCorrected: Boolean
  """Whether it's an automated station, of one of the following types A01|A01A|A02|A02A|AOA|AWOS."""
  qualityControlAutoStation: Boolean!
  """Maintenance check indicator - maintenance is needed."""
  qualityControlMaintenanceIndicatorOn: Boolean!
  """No signal."""
  qualityControlNoSignal: Boolean!
  """Whether Lightning sensor is off."""
  qualityControlLightningSensorOff: Boolean!
  """Whether Freezing rain sensor is off."""
  qualityControlFreezingRainSensorOff: Boolean!
  """Whether Present weather sensor is off."""
  qualityControlPresentWeatherSensorOff: Boolean!
  """The maximum air temperature in Celsius from the past 6 hours."""
  maxTemp6: Float
  """The minimum air temperature in Celsius from the past 6 hours."""
  minTemp6: Float
  """The maximum air temperature in Celsius from the past 24 hours."""
  maxTemp24: Float
  """The minimum air temperature in Celsius from the past 24 hours."""
  minTemp24: Float
  """The precipitation in inches from since the last observation. 0.0005 in = trace precipitation."""
  precipitation: Float
  """The precipitation in inches from the past 3 hours. 0.0005 in = trace precipitation."""
  precipitation3: Float
  """The precipitation in inches from the past 6 hours. 0.0005 in = trace precipitation."""
  precipitation6: Float
  """The precipitation in inches from the past 24 hours. 0.0005 in = trace precipitation."""
  precipitation24: Float
  """The type of METAR."""
  metarType: MetarMetarType!
  station: WeatherStation!
  skyConditions: [SkyCondition!]
}
"""MetarFlightCategory is enum for the field flight_category"""
enum MetarFlightCategory @goModel(model: "metar.gg/ent/metar.FlightCategory") {
  VFR
  MVFR
  IFR
  LIFR
}
"""MetarMetarType is enum for the field metar_type"""
enum MetarMetarType @goModel(model: "metar.gg/ent/metar.MetarType") {
  METAR
  SPECI
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
type Region {
  """The unique identifier of the record."""
  id: ID!
  """The unique identifier of the import."""
  importID: Int!
  """The last time the record was updated/created."""
  lastUpdated: Time!
  """local_code prefixed with the country code to make a globally-unique identifier."""
  code: String!
  """The local code for the administrative subdivision. Whenever possible, these are official ISO 3166:2, at the highest level available, but in some cases OurAirports has to use unofficial codes. There is also a pseudo code "U-A" for each country, which means that the airport has not yet been assigned to a region (or perhaps can't be, as in the case of a deep-sea oil platform)."""
  localCode: String!
  name: String!
  """The wikipedia link of the region."""
  wikipediaLink: String!
  """Keywords that can be used to search for the region."""
  keywords: [String!]!
}
type Runway {
  """The unique identifier of the record."""
  id: ID!
  """The unique identifier of the import."""
  importID: Int!
  """The last time the record was updated/created."""
  lastUpdated: Time!
  """Length of the runway in feet."""
  length: Int!
  """Width of the runway surface in feet."""
  width: Int!
  """Code for the runway surface type. This is not yet a controlled vocabulary, but probably will be soon. Some common values include "ASP" (asphalt), "TURF" (turf), "CON" (concrete), "GRS" (grass), "GRE" (gravel), "WATER" (water), and "UNK" (unknown)."""
  surface: String
  """Whether the runway is lighted at night or not."""
  lighted: Boolean!
  """Whether the runway is currently closed or not."""
  closed: Boolean!
  """Low numbered runway identifier, like 18R."""
  lowRunwayIdentifier: String!
  """Latitude of the low numbered runway end, in decimal degrees (positive is north)."""
  lowRunwayLatitude: Float
  """Longitude of the low numbered runway end, in decimal degrees (positive is east)."""
  lowRunwayLongitude: Float
  """Elevation of the low numbered runway end, in feet."""
  lowRunwayElevation: Int
  """True (not magnetic) heading of the lower numbered runway."""
  lowRunwayHeading: Float
  """Displaced threshold length of the lower numbered runway end, in feet."""
  lowRunwayDisplacedThreshold: Int
  """High numbered runway identifier, like 01L."""
  highRunwayIdentifier: String!
  """Latitude of the high numbered runway end, in decimal degrees (positive is north)."""
  highRunwayLatitude: Float
  """Longitude of the high numbered runway end, in decimal degrees (positive is east)."""
  highRunwayLongitude: Float
  """Elevation of the high numbered runway end, in feet."""
  highRunwayElevation: Int
  """True (not magnetic) heading of the higher numbered runway."""
  highRunwayHeading: Float
  """Displaced threshold length of the higher numbered runway end, in feet."""
  highRunwayDisplacedThreshold: Int
  airport: Airport
}
type SkyCondition {
  """The unique identifier of the record."""
  id: ID!
  skyCover: SkyConditionSkyCover!
  """Cloud type. Only present in TAFs."""
  cloudType: SkyConditionCloudType
}
"""SkyConditionCloudType is enum for the field cloud_type"""
enum SkyConditionCloudType @goModel(model: "metar.gg/ent/skycondition.CloudType") {
  CB
  CU
  TCU
}
"""SkyConditionSkyCover is enum for the field sky_cover"""
enum SkyConditionSkyCover @goModel(model: "metar.gg/ent/skycondition.SkyCover") {
  SKC
  FEW
  SCT
  CLR
  NSC
  BKN
  OVC
  OVCX
  OVX
  CAVOK
}
type Taf {
  """The unique identifier of the record."""
  id: ID!
  """The raw TAF text."""
  rawText: String!
  """The time the TAF was issued."""
  issueTime: Time!
  """The time the TAF was imported."""
  importTime: Time!
  """TAF bulletin time."""
  bulletinTime: Time!
  """The start time of the TAF validity period."""
  validFromTime: Time!
  """The end time of the TAF validity period."""
  validToTime: Time!
  """Remarks."""
  remarks: String!
  station: WeatherStation!
  skyConditions: [SkyCondition!]
  forecast: [Forecast!]
}
"""Ordering options for Taf connections"""
input TafOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tafs."""
  field: TafOrderField!
}
"""Properties by which Taf connections can be ordered."""
enum TafOrderField {
  valid_from_time
}
type TemperatureData {
  """The unique identifier of the record."""
  id: ID!
  """The time the temperature data is valid."""
  validTime: Time!
}
type TurbulenceCondition {
  """The unique identifier of the record."""
  id: ID!
  """The intensity of the turbulence."""
  intensity: String!
}
type WeatherStation {
  """The unique identifier of the record."""
  id: ID!
  """The ICAO identifier of the station that provided the weather data or identifier of the weather station."""
  stationID: String!
  """The latitude in decimal degrees of the station."""
  latitude: Float
  """The longitude in decimal degrees of the station."""
  longitude: Float
  """The elevation in meters of the station."""
  elevation: Float
  airport: Airport
}
`, BuiltIn: false},
	{Name: "../schema.queries.graphql", Input: `"""The cursor string to use for pagination."""
scalar Cursor

"""Time string, in RFC3339 format."""
scalar Time

type PageInfo {
    """Whether there is at least one more page."""
    hasNextPage: Boolean!

    """Whether there is a previous page."""
    hasPreviousPage: Boolean!

    """The cursor to the first element of the current page."""
    startCursor: Cursor

    """The cursor to the last element of the current page."""
    endCursor: Cursor
}

type AirportConnection {
    """Total number of airports."""
    totalCount: Int!

    """Page info of this connection."""
    pageInfo: PageInfo!

    """List of airport edges."""
    edges: [AirportEdge!]!
}

type AirportEdge {
    """The airport object."""
    node: Airport!

    """The cursor of this airport."""
    cursor: Cursor!
}

type MetarConnection {
    """Total number of airports."""
    totalCount: Int!

    """Page info of this connection."""
    pageInfo: PageInfo!

    """List of metar edges."""
    edges: [MetarEdge!]!
}

type MetarEdge {
    """The metar object."""
    node: Metar!

    """The cursor of this metar."""
    cursor: Cursor!
}

type TafConnection {
    """Total number of tafs."""
    totalCount: Int!

    """Page info of this connection."""
    pageInfo: PageInfo!

    """List of taf edges."""
    edges: [TafEdge!]!
}

type TafEdge {
    """The taf object."""
    node: Taf!

    """The cursor of this taf."""
    cursor: Cursor!
}

type WeatherStationConnection {
    """Total number of weather stations."""
    totalCount: Int!

    """Page info of this connection."""
    pageInfo: PageInfo!

    """List of weather station edges."""
    edges: [WeatherStationEdge!]!
}

type WeatherStationEdge {
    """The weather station object."""
    node: WeatherStation!

    """The cursor of this weather station."""
    cursor: Cursor!
}

type Query {
    """Search for airports by a variety of criteria."""
    getAirports(
        first: Int
        after: Cursor
        before: Cursor
        last: Int

        """Search the airport by its ICAO code if available. Otherwise, it will be a local airport code (if no conflict), or if nothing else is available, an internally-generated code starting with the ISO2 country code, followed by a dash and a four-digit number."""
        identifier: String

        """Search the airport by its ICAO code."""
        icao: String,

        """Search the airport by its IATA code."""
        iata: String,

        """Filter by airport type."""
        type: AirportType

        """Search the airport by its name, ICAO, IATA, GPS code, municipality, local code and keywords."""
        search: String,

        """Filter whether the airport provides METARs and has recent ones."""
        hasWeather: Boolean

        order: [AirportOrder!]
    ): AirportConnection!

    """Get a single airport by it's id, identifier, icao code or iata code."""
    getAirport(id: String, identifier: String, icao: String, iata: String,): Airport

    """Search for weather stations by it's identifier."""
    getStations(
        first: Int
        after: Cursor
        before: Cursor
        last: Int

        """Search the weather station by it's identifier, this is usually the ICAO code of the airport it is located at."""
        identifier: String
    ): WeatherStationConnection!

    """Get a single weather station by it's id or identifier."""
    getStation(id: String, identifier: String): WeatherStation
}`, BuiltIn: false},
	{Name: "../schema.models.graphql", Input: `type StationWithDistance {
    """The distance in meters from the given location to the airport."""
    distance: Float!

    """The METAR for the station."""
    station: WeatherStation!
}

extend type Airport {
    """Returns all Runways for this Airport. They can be filtered with the closed parameter."""
    runways(closed: Boolean): [Runway!]! @goField(forceResolver: true)

    """Returns the closest weather stations to the airport, within the given radius (in km)."""
    stationsVicinity(first: Int = 1, radius: Float = 50.0): [StationWithDistance!]! @goField(forceResolver: true)
}

extend type WeatherStation {
    """Returns the latest METARs for this station sorted by their observation time."""
    metars(after: Cursor, first: Int, before: Cursor, last: Int): MetarConnection!

    """Returns the latest TAFs for this station sorted by their issued time."""
    tafs(after: Cursor, first: Int, before: Cursor, last: Int): TafConnection!
}`, BuiltIn: false},
	{Name: "../schema.units.graphql", Input: `enum LengthUnit {
    KILOMETER
    METER
    STATUTE_MILE
    NAUTICAL_MILE
    FOOT
}

enum SmallLengthUnit {
    INCH
    CENTIMETER
}

enum TemperatureUnit {
    CELSIUS
    FAHRENHEIT
}

enum PressureUnit {
    HECTOPASCAL
    INCH_OF_MERCURY
}

enum SpeedUnit {
    KILOMETER_PER_HOUR
    KNOT
}

extend type Metar {
    """The altimeter in the specified unit."""
    altimeter(unit: PressureUnit! = HECTOPASCAL): Float! @goField(forceResolver: true)

    """The temperature in the specified unit."""
    temperature(unit: TemperatureUnit! = CELSIUS): Float! @goField(forceResolver: true)

    """The dew point in the specified unit."""
    dewpoint(unit: TemperatureUnit! = CELSIUS): Float! @goField(forceResolver: true)

    """The wind speed in the specified unit."""
    windSpeed(unit: SpeedUnit! = KNOT): Float! @goField(forceResolver: true)

    """Wind gust speed in the specified unit."""
    windGust(unit: SpeedUnit! = KNOT): Float! @goField(forceResolver: true)

    """The visibility in the specified unit."""
    visibility(unit: LengthUnit! = KILOMETER): Float! @goField(forceResolver: true)

    """Vertical visibility in the specified unit."""
    verticalVisibility(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)

    """Snow depth in the specified unit."""
    snowDepth(unit: SmallLengthUnit! = CENTIMETER): Float @goField(forceResolver: true)

    """Sea level pressure in the specified unit."""
    seaLevelPressure(unit: PressureUnit! = HECTOPASCAL): Float @goField(forceResolver: true)

    """Pressure tendency in the specified unit."""
    pressureTendency(unit: PressureUnit! = HECTOPASCAL): Float @goField(forceResolver: true)
}

extend type SkyCondition {
    """The cloud base in the specified unit."""
    cloudBase(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)
}

extend type Forecast {
    """The altimeter in the specified unit."""
    altimeter(unit: PressureUnit! = HECTOPASCAL): Float @goField(forceResolver: true)

    """The wind speed in the specified unit."""
    windSpeed(unit: SpeedUnit! = KNOT): Float @goField(forceResolver: true)

    """Wind gust speed in the specified unit."""
    windGust(unit: SpeedUnit! = KNOT): Float @goField(forceResolver: true)

    """Visibility horizontal in the specified unit."""
    visibilityHorizontal(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)

    """Visibility vertical in the specified unit."""
    visibilityVertical(unit: LengthUnit! = KILOMETER): Float @goField(forceResolver: true)

    """The height of the wind shear in the specified unit above ground level."""
    windShearHeight(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)

    """Wind shear speed in the specified unit."""
    windShearSpeed(unit: SpeedUnit! = KNOT): Float @goField(forceResolver: true)
}

extend type TemperatureData {
    """The temperature in the specified unit."""
    temperature(unit: TemperatureUnit! = CELSIUS): Float! @goField(forceResolver: true)

    """Min temperature in the specified unit."""
    minTemperature(unit: TemperatureUnit! = CELSIUS): Float @goField(forceResolver: true)

    """Max temperature in the specified unit."""
    maxTemperature(unit: TemperatureUnit! = CELSIUS): Float @goField(forceResolver: true)
}

extend type IcingCondition {
    """Min altitude in the specified unit."""
    minAltitude(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)

    """Max altitude in the specified unit."""
    maxAltitude(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)
}

extend type TurbulenceCondition {
    """Min altitude in the specified unit."""
    minAltitude(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)

    """Max altitude in the specified unit."""
    maxAltitude(unit: LengthUnit! = FOOT): Float @goField(forceResolver: true)
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
