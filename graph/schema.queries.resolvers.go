package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strings"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"metar.gg/ent"
	"metar.gg/ent/airport"
	"metar.gg/ent/predicate"
	"metar.gg/ent/weatherstation"
	"metar.gg/graph/generated"
)

// GetAirports is the resolver for the getAirports field.
func (r *queryResolver) GetAirports(ctx context.Context, first *int, after *entgql.Cursor[uuid.UUID], before *entgql.Cursor[uuid.UUID], last *int, identifier *string, icao *string, iata *string, typeArg *airport.Type, search *string, hasWeather *bool, order []*ent.AirportOrder) (*ent.AirportConnection, error) {
	first, last = BoundsForPagination(first, last)

	var where []predicate.Airport
	if identifier != nil {
		where = append(where, airport.Or(airport.IdentifierEqualFold(*identifier), airport.IdentifierHasPrefix(*identifier)))
	}

	if icao != nil {
		where = append(where, airport.Or(airport.IcaoCodeEqualFold(*icao), airport.IcaoCodeHasPrefix(*icao)))
	}

	if iata != nil {
		where = append(where, airport.Or(airport.IataCodeEqualFold(*iata), airport.IataCodeHasPrefix(*iata)))
	}

	if typeArg != nil {
		where = append(where, airport.TypeEQ(*typeArg))
	}

	if hasWeather != nil && *hasWeather {
		where = append(where, airport.HasStationWith(weatherstation.HasMetars()))
	} else if hasWeather != nil && !*hasWeather {
		where = append(where, airport.Not(airport.HasStationWith(weatherstation.HasMetars())))
	}

	var airportPaginateOptions []ent.AirportPaginateOption

	if len(order) == 0 {
		airportPaginateOptions = append(airportPaginateOptions, ent.WithAirportOrder(&ent.AirportOrder{Field: ent.AirportOrderFieldImportance, Direction: entgql.OrderDirectionDesc}))
	}

	for _, airportOrder := range order {
		airportPaginateOptions = append(airportPaginateOptions, ent.WithAirportOrder(airportOrder))
	}

	// If there was a search argument we want to search the db
	safeSearch := ""
	if search != nil {
		compile, err := regexp.Compile("\\w+")
		if err != nil {
			log.Panic(err)
		}

		searchStringResult := compile.FindAllString(*search, 10)
		if len(searchStringResult) == 0 {
			return &ent.AirportConnection{}, nil
		}

		safeSearch = strings.Join(searchStringResult, " ")

		airportPaginateOptions = append(airportPaginateOptions, ent.WithAirportFilter(func(query *ent.AirportQuery) (*ent.AirportQuery, error) {
			query.Modify(func(s *sql.Selector) {
				if safeSearch != "" {
					p := fmt.Sprintf("*%s*", safeSearch)
					matchStatement := "MATCH(name, municipality, icao_code, iata_code, local_code, identifier) AGAINST (? IN BOOLEAN MODE)"

					s.AppendSelectExpr(sql.ExprP(fmt.Sprintf("%s AS relevance", matchStatement), p))
					s.Where(sql.ExprP(fmt.Sprintf(matchStatement), p))
					s.ClearOrder()
					s.OrderExpr(sql.Expr("relevance DESC, importance DESC, airports.id ASC"))
				}
			})

			return query, nil
		}))
	}

	connection, err := r.client.Airport.Query().Where(
		airport.And(where...),
	).Paginate(ctx, after, first, before, last, airportPaginateOptions...)
	if err != nil {
		return nil, err
	}

	// A bit dirty, but we want to at least calculate the correct total count
	if safeSearch != "" {
		count, err := r.client.Airport.Query().Where(
			airport.And(where...),
		).Modify(func(s *sql.Selector) {
			if safeSearch != "" {
				p := fmt.Sprintf("*%s*", safeSearch)
				matchStatement := "MATCH(name, municipality, icao_code, iata_code, local_code, identifier) AGAINST (? IN BOOLEAN MODE)"

				s.Where(sql.ExprP(fmt.Sprintf(matchStatement), p))
			}
		}).Count(ctx)
		if err != nil {
			return nil, err
		}

		connection.TotalCount = count
	}
	return connection, nil
}

// GetAirport is the resolver for the getAirport field.
func (r *queryResolver) GetAirport(ctx context.Context, id *string, identifier *string, icao *string, iata *string) (*ent.Airport, error) {
	var where []predicate.Airport
	if id != nil {
		uid, err := uuid.Parse(*id)
		if err != nil {
			return nil, err
		}

		where = append(where, airport.ID(uid))
	}

	if identifier != nil {
		where = append(where, airport.IdentifierEqualFold(*identifier))
	}

	if icao != nil {
		where = append(where, airport.IcaoCodeEqualFold(*icao))
	}

	if iata != nil {
		where = append(where, airport.IataCodeEqualFold(*iata))
	}

	a, err := r.client.Airport.Query().Where(airport.Or(where...)).First(ctx)
	if err != nil {
		return nil, err
	}

	return a, nil
}

// GetStations is the resolver for the getStations field.
func (r *queryResolver) GetStations(ctx context.Context, first *int, after *entgql.Cursor[uuid.UUID], before *entgql.Cursor[uuid.UUID], last *int, identifier *string) (*ent.WeatherStationConnection, error) {
	first, last = BoundsForPagination(first, last)

	var where []predicate.WeatherStation
	if identifier != nil {
		where = append(where, weatherstation.Or(weatherstation.StationIDEqualFold(*identifier), weatherstation.StationIDHasPrefix(*identifier)))
	}

	connection, err := r.client.WeatherStation.Query().Where(
		where...,
	).Paginate(ctx, after, first, before, last)
	if err != nil {
		return nil, err
	}

	return connection, nil
}

// GetStation is the resolver for the getStation field.
func (r *queryResolver) GetStation(ctx context.Context, id *string, identifier *string) (*ent.WeatherStation, error) {
	var orPredicates []predicate.WeatherStation

	if id != nil {
		uid, err := uuid.Parse(*id)
		if err != nil {
			return nil, err
		}

		orPredicates = append(orPredicates, weatherstation.ID(uid))
	}

	if identifier != nil {
		orPredicates = append(orPredicates, weatherstation.StationIDEqualFold(*identifier))
	}

	return r.client.WeatherStation.Query().Where(weatherstation.Or(orPredicates...)).First(ctx)
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
