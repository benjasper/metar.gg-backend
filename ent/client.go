// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/google/uuid"
	"metar.gg/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"metar.gg/ent/airport"
	"metar.gg/ent/country"
	"metar.gg/ent/forecast"
	"metar.gg/ent/frequency"
	"metar.gg/ent/icingcondition"
	"metar.gg/ent/metar"
	"metar.gg/ent/region"
	"metar.gg/ent/runway"
	"metar.gg/ent/skycondition"
	"metar.gg/ent/taf"
	"metar.gg/ent/temperaturedata"
	"metar.gg/ent/turbulencecondition"
	"metar.gg/ent/weatherstation"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Airport is the client for interacting with the Airport builders.
	Airport *AirportClient
	// Country is the client for interacting with the Country builders.
	Country *CountryClient
	// Forecast is the client for interacting with the Forecast builders.
	Forecast *ForecastClient
	// Frequency is the client for interacting with the Frequency builders.
	Frequency *FrequencyClient
	// IcingCondition is the client for interacting with the IcingCondition builders.
	IcingCondition *IcingConditionClient
	// Metar is the client for interacting with the Metar builders.
	Metar *MetarClient
	// Region is the client for interacting with the Region builders.
	Region *RegionClient
	// Runway is the client for interacting with the Runway builders.
	Runway *RunwayClient
	// SkyCondition is the client for interacting with the SkyCondition builders.
	SkyCondition *SkyConditionClient
	// Taf is the client for interacting with the Taf builders.
	Taf *TafClient
	// TemperatureData is the client for interacting with the TemperatureData builders.
	TemperatureData *TemperatureDataClient
	// TurbulenceCondition is the client for interacting with the TurbulenceCondition builders.
	TurbulenceCondition *TurbulenceConditionClient
	// WeatherStation is the client for interacting with the WeatherStation builders.
	WeatherStation *WeatherStationClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Airport = NewAirportClient(c.config)
	c.Country = NewCountryClient(c.config)
	c.Forecast = NewForecastClient(c.config)
	c.Frequency = NewFrequencyClient(c.config)
	c.IcingCondition = NewIcingConditionClient(c.config)
	c.Metar = NewMetarClient(c.config)
	c.Region = NewRegionClient(c.config)
	c.Runway = NewRunwayClient(c.config)
	c.SkyCondition = NewSkyConditionClient(c.config)
	c.Taf = NewTafClient(c.config)
	c.TemperatureData = NewTemperatureDataClient(c.config)
	c.TurbulenceCondition = NewTurbulenceConditionClient(c.config)
	c.WeatherStation = NewWeatherStationClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Airport:             NewAirportClient(cfg),
		Country:             NewCountryClient(cfg),
		Forecast:            NewForecastClient(cfg),
		Frequency:           NewFrequencyClient(cfg),
		IcingCondition:      NewIcingConditionClient(cfg),
		Metar:               NewMetarClient(cfg),
		Region:              NewRegionClient(cfg),
		Runway:              NewRunwayClient(cfg),
		SkyCondition:        NewSkyConditionClient(cfg),
		Taf:                 NewTafClient(cfg),
		TemperatureData:     NewTemperatureDataClient(cfg),
		TurbulenceCondition: NewTurbulenceConditionClient(cfg),
		WeatherStation:      NewWeatherStationClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Airport:             NewAirportClient(cfg),
		Country:             NewCountryClient(cfg),
		Forecast:            NewForecastClient(cfg),
		Frequency:           NewFrequencyClient(cfg),
		IcingCondition:      NewIcingConditionClient(cfg),
		Metar:               NewMetarClient(cfg),
		Region:              NewRegionClient(cfg),
		Runway:              NewRunwayClient(cfg),
		SkyCondition:        NewSkyConditionClient(cfg),
		Taf:                 NewTafClient(cfg),
		TemperatureData:     NewTemperatureDataClient(cfg),
		TurbulenceCondition: NewTurbulenceConditionClient(cfg),
		WeatherStation:      NewWeatherStationClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Airport.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Airport, c.Country, c.Forecast, c.Frequency, c.IcingCondition, c.Metar,
		c.Region, c.Runway, c.SkyCondition, c.Taf, c.TemperatureData,
		c.TurbulenceCondition, c.WeatherStation,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Airport, c.Country, c.Forecast, c.Frequency, c.IcingCondition, c.Metar,
		c.Region, c.Runway, c.SkyCondition, c.Taf, c.TemperatureData,
		c.TurbulenceCondition, c.WeatherStation,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AirportMutation:
		return c.Airport.mutate(ctx, m)
	case *CountryMutation:
		return c.Country.mutate(ctx, m)
	case *ForecastMutation:
		return c.Forecast.mutate(ctx, m)
	case *FrequencyMutation:
		return c.Frequency.mutate(ctx, m)
	case *IcingConditionMutation:
		return c.IcingCondition.mutate(ctx, m)
	case *MetarMutation:
		return c.Metar.mutate(ctx, m)
	case *RegionMutation:
		return c.Region.mutate(ctx, m)
	case *RunwayMutation:
		return c.Runway.mutate(ctx, m)
	case *SkyConditionMutation:
		return c.SkyCondition.mutate(ctx, m)
	case *TafMutation:
		return c.Taf.mutate(ctx, m)
	case *TemperatureDataMutation:
		return c.TemperatureData.mutate(ctx, m)
	case *TurbulenceConditionMutation:
		return c.TurbulenceCondition.mutate(ctx, m)
	case *WeatherStationMutation:
		return c.WeatherStation.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AirportClient is a client for the Airport schema.
type AirportClient struct {
	config
}

// NewAirportClient returns a client for the Airport from the given config.
func NewAirportClient(c config) *AirportClient {
	return &AirportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `airport.Hooks(f(g(h())))`.
func (c *AirportClient) Use(hooks ...Hook) {
	c.hooks.Airport = append(c.hooks.Airport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `airport.Intercept(f(g(h())))`.
func (c *AirportClient) Intercept(interceptors ...Interceptor) {
	c.inters.Airport = append(c.inters.Airport, interceptors...)
}

// Create returns a builder for creating a Airport entity.
func (c *AirportClient) Create() *AirportCreate {
	mutation := newAirportMutation(c.config, OpCreate)
	return &AirportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Airport entities.
func (c *AirportClient) CreateBulk(builders ...*AirportCreate) *AirportCreateBulk {
	return &AirportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Airport.
func (c *AirportClient) Update() *AirportUpdate {
	mutation := newAirportMutation(c.config, OpUpdate)
	return &AirportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AirportClient) UpdateOne(a *Airport) *AirportUpdateOne {
	mutation := newAirportMutation(c.config, OpUpdateOne, withAirport(a))
	return &AirportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AirportClient) UpdateOneID(id uuid.UUID) *AirportUpdateOne {
	mutation := newAirportMutation(c.config, OpUpdateOne, withAirportID(id))
	return &AirportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Airport.
func (c *AirportClient) Delete() *AirportDelete {
	mutation := newAirportMutation(c.config, OpDelete)
	return &AirportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AirportClient) DeleteOne(a *Airport) *AirportDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AirportClient) DeleteOneID(id uuid.UUID) *AirportDeleteOne {
	builder := c.Delete().Where(airport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AirportDeleteOne{builder}
}

// Query returns a query builder for Airport.
func (c *AirportClient) Query() *AirportQuery {
	return &AirportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAirport},
		inters: c.Interceptors(),
	}
}

// Get returns a Airport entity by its id.
func (c *AirportClient) Get(ctx context.Context, id uuid.UUID) (*Airport, error) {
	return c.Query().Where(airport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AirportClient) GetX(ctx context.Context, id uuid.UUID) *Airport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRegion queries the region edge of a Airport.
func (c *AirportClient) QueryRegion(a *Airport) *RegionQuery {
	query := (&RegionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(airport.Table, airport.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, airport.RegionTable, airport.RegionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCountry queries the country edge of a Airport.
func (c *AirportClient) QueryCountry(a *Airport) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(airport.Table, airport.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, airport.CountryTable, airport.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRunways queries the runways edge of a Airport.
func (c *AirportClient) QueryRunways(a *Airport) *RunwayQuery {
	query := (&RunwayClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(airport.Table, airport.FieldID, id),
			sqlgraph.To(runway.Table, runway.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, airport.RunwaysTable, airport.RunwaysColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFrequencies queries the frequencies edge of a Airport.
func (c *AirportClient) QueryFrequencies(a *Airport) *FrequencyQuery {
	query := (&FrequencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(airport.Table, airport.FieldID, id),
			sqlgraph.To(frequency.Table, frequency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, airport.FrequenciesTable, airport.FrequenciesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStation queries the station edge of a Airport.
func (c *AirportClient) QueryStation(a *Airport) *WeatherStationQuery {
	query := (&WeatherStationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(airport.Table, airport.FieldID, id),
			sqlgraph.To(weatherstation.Table, weatherstation.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, airport.StationTable, airport.StationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AirportClient) Hooks() []Hook {
	return c.hooks.Airport
}

// Interceptors returns the client interceptors.
func (c *AirportClient) Interceptors() []Interceptor {
	return c.inters.Airport
}

func (c *AirportClient) mutate(ctx context.Context, m *AirportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AirportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AirportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AirportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AirportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Airport mutation op: %q", m.Op())
	}
}

// CountryClient is a client for the Country schema.
type CountryClient struct {
	config
}

// NewCountryClient returns a client for the Country from the given config.
func NewCountryClient(c config) *CountryClient {
	return &CountryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `country.Hooks(f(g(h())))`.
func (c *CountryClient) Use(hooks ...Hook) {
	c.hooks.Country = append(c.hooks.Country, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `country.Intercept(f(g(h())))`.
func (c *CountryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Country = append(c.inters.Country, interceptors...)
}

// Create returns a builder for creating a Country entity.
func (c *CountryClient) Create() *CountryCreate {
	mutation := newCountryMutation(c.config, OpCreate)
	return &CountryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Country entities.
func (c *CountryClient) CreateBulk(builders ...*CountryCreate) *CountryCreateBulk {
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Country.
func (c *CountryClient) Update() *CountryUpdate {
	mutation := newCountryMutation(c.config, OpUpdate)
	return &CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CountryClient) UpdateOne(co *Country) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountry(co))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CountryClient) UpdateOneID(id uuid.UUID) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountryID(id))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Country.
func (c *CountryClient) Delete() *CountryDelete {
	mutation := newCountryMutation(c.config, OpDelete)
	return &CountryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CountryClient) DeleteOne(co *Country) *CountryDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CountryClient) DeleteOneID(id uuid.UUID) *CountryDeleteOne {
	builder := c.Delete().Where(country.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CountryDeleteOne{builder}
}

// Query returns a query builder for Country.
func (c *CountryClient) Query() *CountryQuery {
	return &CountryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCountry},
		inters: c.Interceptors(),
	}
}

// Get returns a Country entity by its id.
func (c *CountryClient) Get(ctx context.Context, id uuid.UUID) (*Country, error) {
	return c.Query().Where(country.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CountryClient) GetX(ctx context.Context, id uuid.UUID) *Country {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAirports queries the airports edge of a Country.
func (c *CountryClient) QueryAirports(co *Country) *AirportQuery {
	query := (&AirportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(airport.Table, airport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.AirportsTable, country.AirportsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CountryClient) Hooks() []Hook {
	return c.hooks.Country
}

// Interceptors returns the client interceptors.
func (c *CountryClient) Interceptors() []Interceptor {
	return c.inters.Country
}

func (c *CountryClient) mutate(ctx context.Context, m *CountryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CountryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CountryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Country mutation op: %q", m.Op())
	}
}

// ForecastClient is a client for the Forecast schema.
type ForecastClient struct {
	config
}

// NewForecastClient returns a client for the Forecast from the given config.
func NewForecastClient(c config) *ForecastClient {
	return &ForecastClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `forecast.Hooks(f(g(h())))`.
func (c *ForecastClient) Use(hooks ...Hook) {
	c.hooks.Forecast = append(c.hooks.Forecast, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `forecast.Intercept(f(g(h())))`.
func (c *ForecastClient) Intercept(interceptors ...Interceptor) {
	c.inters.Forecast = append(c.inters.Forecast, interceptors...)
}

// Create returns a builder for creating a Forecast entity.
func (c *ForecastClient) Create() *ForecastCreate {
	mutation := newForecastMutation(c.config, OpCreate)
	return &ForecastCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Forecast entities.
func (c *ForecastClient) CreateBulk(builders ...*ForecastCreate) *ForecastCreateBulk {
	return &ForecastCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Forecast.
func (c *ForecastClient) Update() *ForecastUpdate {
	mutation := newForecastMutation(c.config, OpUpdate)
	return &ForecastUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ForecastClient) UpdateOne(f *Forecast) *ForecastUpdateOne {
	mutation := newForecastMutation(c.config, OpUpdateOne, withForecast(f))
	return &ForecastUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ForecastClient) UpdateOneID(id uuid.UUID) *ForecastUpdateOne {
	mutation := newForecastMutation(c.config, OpUpdateOne, withForecastID(id))
	return &ForecastUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Forecast.
func (c *ForecastClient) Delete() *ForecastDelete {
	mutation := newForecastMutation(c.config, OpDelete)
	return &ForecastDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ForecastClient) DeleteOne(f *Forecast) *ForecastDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ForecastClient) DeleteOneID(id uuid.UUID) *ForecastDeleteOne {
	builder := c.Delete().Where(forecast.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ForecastDeleteOne{builder}
}

// Query returns a query builder for Forecast.
func (c *ForecastClient) Query() *ForecastQuery {
	return &ForecastQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeForecast},
		inters: c.Interceptors(),
	}
}

// Get returns a Forecast entity by its id.
func (c *ForecastClient) Get(ctx context.Context, id uuid.UUID) (*Forecast, error) {
	return c.Query().Where(forecast.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ForecastClient) GetX(ctx context.Context, id uuid.UUID) *Forecast {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySkyConditions queries the sky_conditions edge of a Forecast.
func (c *ForecastClient) QuerySkyConditions(f *Forecast) *SkyConditionQuery {
	query := (&SkyConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(forecast.Table, forecast.FieldID, id),
			sqlgraph.To(skycondition.Table, skycondition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, forecast.SkyConditionsTable, forecast.SkyConditionsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTurbulenceConditions queries the turbulence_conditions edge of a Forecast.
func (c *ForecastClient) QueryTurbulenceConditions(f *Forecast) *TurbulenceConditionQuery {
	query := (&TurbulenceConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(forecast.Table, forecast.FieldID, id),
			sqlgraph.To(turbulencecondition.Table, turbulencecondition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, forecast.TurbulenceConditionsTable, forecast.TurbulenceConditionsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIcingConditions queries the icing_conditions edge of a Forecast.
func (c *ForecastClient) QueryIcingConditions(f *Forecast) *IcingConditionQuery {
	query := (&IcingConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(forecast.Table, forecast.FieldID, id),
			sqlgraph.To(icingcondition.Table, icingcondition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, forecast.IcingConditionsTable, forecast.IcingConditionsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemperatureData queries the temperature_data edge of a Forecast.
func (c *ForecastClient) QueryTemperatureData(f *Forecast) *TemperatureDataQuery {
	query := (&TemperatureDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(forecast.Table, forecast.FieldID, id),
			sqlgraph.To(temperaturedata.Table, temperaturedata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, forecast.TemperatureDataTable, forecast.TemperatureDataColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ForecastClient) Hooks() []Hook {
	return c.hooks.Forecast
}

// Interceptors returns the client interceptors.
func (c *ForecastClient) Interceptors() []Interceptor {
	return c.inters.Forecast
}

func (c *ForecastClient) mutate(ctx context.Context, m *ForecastMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ForecastCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ForecastUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ForecastUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ForecastDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Forecast mutation op: %q", m.Op())
	}
}

// FrequencyClient is a client for the Frequency schema.
type FrequencyClient struct {
	config
}

// NewFrequencyClient returns a client for the Frequency from the given config.
func NewFrequencyClient(c config) *FrequencyClient {
	return &FrequencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `frequency.Hooks(f(g(h())))`.
func (c *FrequencyClient) Use(hooks ...Hook) {
	c.hooks.Frequency = append(c.hooks.Frequency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `frequency.Intercept(f(g(h())))`.
func (c *FrequencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Frequency = append(c.inters.Frequency, interceptors...)
}

// Create returns a builder for creating a Frequency entity.
func (c *FrequencyClient) Create() *FrequencyCreate {
	mutation := newFrequencyMutation(c.config, OpCreate)
	return &FrequencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Frequency entities.
func (c *FrequencyClient) CreateBulk(builders ...*FrequencyCreate) *FrequencyCreateBulk {
	return &FrequencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Frequency.
func (c *FrequencyClient) Update() *FrequencyUpdate {
	mutation := newFrequencyMutation(c.config, OpUpdate)
	return &FrequencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FrequencyClient) UpdateOne(f *Frequency) *FrequencyUpdateOne {
	mutation := newFrequencyMutation(c.config, OpUpdateOne, withFrequency(f))
	return &FrequencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FrequencyClient) UpdateOneID(id uuid.UUID) *FrequencyUpdateOne {
	mutation := newFrequencyMutation(c.config, OpUpdateOne, withFrequencyID(id))
	return &FrequencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Frequency.
func (c *FrequencyClient) Delete() *FrequencyDelete {
	mutation := newFrequencyMutation(c.config, OpDelete)
	return &FrequencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FrequencyClient) DeleteOne(f *Frequency) *FrequencyDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FrequencyClient) DeleteOneID(id uuid.UUID) *FrequencyDeleteOne {
	builder := c.Delete().Where(frequency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FrequencyDeleteOne{builder}
}

// Query returns a query builder for Frequency.
func (c *FrequencyClient) Query() *FrequencyQuery {
	return &FrequencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFrequency},
		inters: c.Interceptors(),
	}
}

// Get returns a Frequency entity by its id.
func (c *FrequencyClient) Get(ctx context.Context, id uuid.UUID) (*Frequency, error) {
	return c.Query().Where(frequency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FrequencyClient) GetX(ctx context.Context, id uuid.UUID) *Frequency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAirport queries the airport edge of a Frequency.
func (c *FrequencyClient) QueryAirport(f *Frequency) *AirportQuery {
	query := (&AirportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frequency.Table, frequency.FieldID, id),
			sqlgraph.To(airport.Table, airport.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, frequency.AirportTable, frequency.AirportColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FrequencyClient) Hooks() []Hook {
	return c.hooks.Frequency
}

// Interceptors returns the client interceptors.
func (c *FrequencyClient) Interceptors() []Interceptor {
	return c.inters.Frequency
}

func (c *FrequencyClient) mutate(ctx context.Context, m *FrequencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FrequencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FrequencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FrequencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FrequencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Frequency mutation op: %q", m.Op())
	}
}

// IcingConditionClient is a client for the IcingCondition schema.
type IcingConditionClient struct {
	config
}

// NewIcingConditionClient returns a client for the IcingCondition from the given config.
func NewIcingConditionClient(c config) *IcingConditionClient {
	return &IcingConditionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `icingcondition.Hooks(f(g(h())))`.
func (c *IcingConditionClient) Use(hooks ...Hook) {
	c.hooks.IcingCondition = append(c.hooks.IcingCondition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `icingcondition.Intercept(f(g(h())))`.
func (c *IcingConditionClient) Intercept(interceptors ...Interceptor) {
	c.inters.IcingCondition = append(c.inters.IcingCondition, interceptors...)
}

// Create returns a builder for creating a IcingCondition entity.
func (c *IcingConditionClient) Create() *IcingConditionCreate {
	mutation := newIcingConditionMutation(c.config, OpCreate)
	return &IcingConditionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IcingCondition entities.
func (c *IcingConditionClient) CreateBulk(builders ...*IcingConditionCreate) *IcingConditionCreateBulk {
	return &IcingConditionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IcingCondition.
func (c *IcingConditionClient) Update() *IcingConditionUpdate {
	mutation := newIcingConditionMutation(c.config, OpUpdate)
	return &IcingConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IcingConditionClient) UpdateOne(ic *IcingCondition) *IcingConditionUpdateOne {
	mutation := newIcingConditionMutation(c.config, OpUpdateOne, withIcingCondition(ic))
	return &IcingConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IcingConditionClient) UpdateOneID(id uuid.UUID) *IcingConditionUpdateOne {
	mutation := newIcingConditionMutation(c.config, OpUpdateOne, withIcingConditionID(id))
	return &IcingConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IcingCondition.
func (c *IcingConditionClient) Delete() *IcingConditionDelete {
	mutation := newIcingConditionMutation(c.config, OpDelete)
	return &IcingConditionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IcingConditionClient) DeleteOne(ic *IcingCondition) *IcingConditionDeleteOne {
	return c.DeleteOneID(ic.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IcingConditionClient) DeleteOneID(id uuid.UUID) *IcingConditionDeleteOne {
	builder := c.Delete().Where(icingcondition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IcingConditionDeleteOne{builder}
}

// Query returns a query builder for IcingCondition.
func (c *IcingConditionClient) Query() *IcingConditionQuery {
	return &IcingConditionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIcingCondition},
		inters: c.Interceptors(),
	}
}

// Get returns a IcingCondition entity by its id.
func (c *IcingConditionClient) Get(ctx context.Context, id uuid.UUID) (*IcingCondition, error) {
	return c.Query().Where(icingcondition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IcingConditionClient) GetX(ctx context.Context, id uuid.UUID) *IcingCondition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *IcingConditionClient) Hooks() []Hook {
	return c.hooks.IcingCondition
}

// Interceptors returns the client interceptors.
func (c *IcingConditionClient) Interceptors() []Interceptor {
	return c.inters.IcingCondition
}

func (c *IcingConditionClient) mutate(ctx context.Context, m *IcingConditionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IcingConditionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IcingConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IcingConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IcingConditionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IcingCondition mutation op: %q", m.Op())
	}
}

// MetarClient is a client for the Metar schema.
type MetarClient struct {
	config
}

// NewMetarClient returns a client for the Metar from the given config.
func NewMetarClient(c config) *MetarClient {
	return &MetarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metar.Hooks(f(g(h())))`.
func (c *MetarClient) Use(hooks ...Hook) {
	c.hooks.Metar = append(c.hooks.Metar, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metar.Intercept(f(g(h())))`.
func (c *MetarClient) Intercept(interceptors ...Interceptor) {
	c.inters.Metar = append(c.inters.Metar, interceptors...)
}

// Create returns a builder for creating a Metar entity.
func (c *MetarClient) Create() *MetarCreate {
	mutation := newMetarMutation(c.config, OpCreate)
	return &MetarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metar entities.
func (c *MetarClient) CreateBulk(builders ...*MetarCreate) *MetarCreateBulk {
	return &MetarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metar.
func (c *MetarClient) Update() *MetarUpdate {
	mutation := newMetarMutation(c.config, OpUpdate)
	return &MetarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetarClient) UpdateOne(m *Metar) *MetarUpdateOne {
	mutation := newMetarMutation(c.config, OpUpdateOne, withMetar(m))
	return &MetarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetarClient) UpdateOneID(id uuid.UUID) *MetarUpdateOne {
	mutation := newMetarMutation(c.config, OpUpdateOne, withMetarID(id))
	return &MetarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metar.
func (c *MetarClient) Delete() *MetarDelete {
	mutation := newMetarMutation(c.config, OpDelete)
	return &MetarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetarClient) DeleteOne(m *Metar) *MetarDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetarClient) DeleteOneID(id uuid.UUID) *MetarDeleteOne {
	builder := c.Delete().Where(metar.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetarDeleteOne{builder}
}

// Query returns a query builder for Metar.
func (c *MetarClient) Query() *MetarQuery {
	return &MetarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetar},
		inters: c.Interceptors(),
	}
}

// Get returns a Metar entity by its id.
func (c *MetarClient) Get(ctx context.Context, id uuid.UUID) (*Metar, error) {
	return c.Query().Where(metar.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetarClient) GetX(ctx context.Context, id uuid.UUID) *Metar {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStation queries the station edge of a Metar.
func (c *MetarClient) QueryStation(m *Metar) *WeatherStationQuery {
	query := (&WeatherStationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metar.Table, metar.FieldID, id),
			sqlgraph.To(weatherstation.Table, weatherstation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, metar.StationTable, metar.StationColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySkyConditions queries the sky_conditions edge of a Metar.
func (c *MetarClient) QuerySkyConditions(m *Metar) *SkyConditionQuery {
	query := (&SkyConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metar.Table, metar.FieldID, id),
			sqlgraph.To(skycondition.Table, skycondition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metar.SkyConditionsTable, metar.SkyConditionsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetarClient) Hooks() []Hook {
	return c.hooks.Metar
}

// Interceptors returns the client interceptors.
func (c *MetarClient) Interceptors() []Interceptor {
	return c.inters.Metar
}

func (c *MetarClient) mutate(ctx context.Context, m *MetarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Metar mutation op: %q", m.Op())
	}
}

// RegionClient is a client for the Region schema.
type RegionClient struct {
	config
}

// NewRegionClient returns a client for the Region from the given config.
func NewRegionClient(c config) *RegionClient {
	return &RegionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `region.Hooks(f(g(h())))`.
func (c *RegionClient) Use(hooks ...Hook) {
	c.hooks.Region = append(c.hooks.Region, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `region.Intercept(f(g(h())))`.
func (c *RegionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Region = append(c.inters.Region, interceptors...)
}

// Create returns a builder for creating a Region entity.
func (c *RegionClient) Create() *RegionCreate {
	mutation := newRegionMutation(c.config, OpCreate)
	return &RegionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Region entities.
func (c *RegionClient) CreateBulk(builders ...*RegionCreate) *RegionCreateBulk {
	return &RegionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Region.
func (c *RegionClient) Update() *RegionUpdate {
	mutation := newRegionMutation(c.config, OpUpdate)
	return &RegionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RegionClient) UpdateOne(r *Region) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegion(r))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RegionClient) UpdateOneID(id uuid.UUID) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegionID(id))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Region.
func (c *RegionClient) Delete() *RegionDelete {
	mutation := newRegionMutation(c.config, OpDelete)
	return &RegionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RegionClient) DeleteOne(r *Region) *RegionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RegionClient) DeleteOneID(id uuid.UUID) *RegionDeleteOne {
	builder := c.Delete().Where(region.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RegionDeleteOne{builder}
}

// Query returns a query builder for Region.
func (c *RegionClient) Query() *RegionQuery {
	return &RegionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRegion},
		inters: c.Interceptors(),
	}
}

// Get returns a Region entity by its id.
func (c *RegionClient) Get(ctx context.Context, id uuid.UUID) (*Region, error) {
	return c.Query().Where(region.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RegionClient) GetX(ctx context.Context, id uuid.UUID) *Region {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAirports queries the airports edge of a Region.
func (c *RegionClient) QueryAirports(r *Region) *AirportQuery {
	query := (&AirportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(airport.Table, airport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, region.AirportsTable, region.AirportsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RegionClient) Hooks() []Hook {
	return c.hooks.Region
}

// Interceptors returns the client interceptors.
func (c *RegionClient) Interceptors() []Interceptor {
	return c.inters.Region
}

func (c *RegionClient) mutate(ctx context.Context, m *RegionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RegionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RegionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RegionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Region mutation op: %q", m.Op())
	}
}

// RunwayClient is a client for the Runway schema.
type RunwayClient struct {
	config
}

// NewRunwayClient returns a client for the Runway from the given config.
func NewRunwayClient(c config) *RunwayClient {
	return &RunwayClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `runway.Hooks(f(g(h())))`.
func (c *RunwayClient) Use(hooks ...Hook) {
	c.hooks.Runway = append(c.hooks.Runway, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `runway.Intercept(f(g(h())))`.
func (c *RunwayClient) Intercept(interceptors ...Interceptor) {
	c.inters.Runway = append(c.inters.Runway, interceptors...)
}

// Create returns a builder for creating a Runway entity.
func (c *RunwayClient) Create() *RunwayCreate {
	mutation := newRunwayMutation(c.config, OpCreate)
	return &RunwayCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Runway entities.
func (c *RunwayClient) CreateBulk(builders ...*RunwayCreate) *RunwayCreateBulk {
	return &RunwayCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Runway.
func (c *RunwayClient) Update() *RunwayUpdate {
	mutation := newRunwayMutation(c.config, OpUpdate)
	return &RunwayUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RunwayClient) UpdateOne(r *Runway) *RunwayUpdateOne {
	mutation := newRunwayMutation(c.config, OpUpdateOne, withRunway(r))
	return &RunwayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RunwayClient) UpdateOneID(id uuid.UUID) *RunwayUpdateOne {
	mutation := newRunwayMutation(c.config, OpUpdateOne, withRunwayID(id))
	return &RunwayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Runway.
func (c *RunwayClient) Delete() *RunwayDelete {
	mutation := newRunwayMutation(c.config, OpDelete)
	return &RunwayDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RunwayClient) DeleteOne(r *Runway) *RunwayDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RunwayClient) DeleteOneID(id uuid.UUID) *RunwayDeleteOne {
	builder := c.Delete().Where(runway.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RunwayDeleteOne{builder}
}

// Query returns a query builder for Runway.
func (c *RunwayClient) Query() *RunwayQuery {
	return &RunwayQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRunway},
		inters: c.Interceptors(),
	}
}

// Get returns a Runway entity by its id.
func (c *RunwayClient) Get(ctx context.Context, id uuid.UUID) (*Runway, error) {
	return c.Query().Where(runway.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RunwayClient) GetX(ctx context.Context, id uuid.UUID) *Runway {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAirport queries the airport edge of a Runway.
func (c *RunwayClient) QueryAirport(r *Runway) *AirportQuery {
	query := (&AirportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(runway.Table, runway.FieldID, id),
			sqlgraph.To(airport.Table, airport.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, runway.AirportTable, runway.AirportColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RunwayClient) Hooks() []Hook {
	return c.hooks.Runway
}

// Interceptors returns the client interceptors.
func (c *RunwayClient) Interceptors() []Interceptor {
	return c.inters.Runway
}

func (c *RunwayClient) mutate(ctx context.Context, m *RunwayMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RunwayCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RunwayUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RunwayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RunwayDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Runway mutation op: %q", m.Op())
	}
}

// SkyConditionClient is a client for the SkyCondition schema.
type SkyConditionClient struct {
	config
}

// NewSkyConditionClient returns a client for the SkyCondition from the given config.
func NewSkyConditionClient(c config) *SkyConditionClient {
	return &SkyConditionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `skycondition.Hooks(f(g(h())))`.
func (c *SkyConditionClient) Use(hooks ...Hook) {
	c.hooks.SkyCondition = append(c.hooks.SkyCondition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `skycondition.Intercept(f(g(h())))`.
func (c *SkyConditionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SkyCondition = append(c.inters.SkyCondition, interceptors...)
}

// Create returns a builder for creating a SkyCondition entity.
func (c *SkyConditionClient) Create() *SkyConditionCreate {
	mutation := newSkyConditionMutation(c.config, OpCreate)
	return &SkyConditionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SkyCondition entities.
func (c *SkyConditionClient) CreateBulk(builders ...*SkyConditionCreate) *SkyConditionCreateBulk {
	return &SkyConditionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SkyCondition.
func (c *SkyConditionClient) Update() *SkyConditionUpdate {
	mutation := newSkyConditionMutation(c.config, OpUpdate)
	return &SkyConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SkyConditionClient) UpdateOne(sc *SkyCondition) *SkyConditionUpdateOne {
	mutation := newSkyConditionMutation(c.config, OpUpdateOne, withSkyCondition(sc))
	return &SkyConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SkyConditionClient) UpdateOneID(id uuid.UUID) *SkyConditionUpdateOne {
	mutation := newSkyConditionMutation(c.config, OpUpdateOne, withSkyConditionID(id))
	return &SkyConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SkyCondition.
func (c *SkyConditionClient) Delete() *SkyConditionDelete {
	mutation := newSkyConditionMutation(c.config, OpDelete)
	return &SkyConditionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SkyConditionClient) DeleteOne(sc *SkyCondition) *SkyConditionDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SkyConditionClient) DeleteOneID(id uuid.UUID) *SkyConditionDeleteOne {
	builder := c.Delete().Where(skycondition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SkyConditionDeleteOne{builder}
}

// Query returns a query builder for SkyCondition.
func (c *SkyConditionClient) Query() *SkyConditionQuery {
	return &SkyConditionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSkyCondition},
		inters: c.Interceptors(),
	}
}

// Get returns a SkyCondition entity by its id.
func (c *SkyConditionClient) Get(ctx context.Context, id uuid.UUID) (*SkyCondition, error) {
	return c.Query().Where(skycondition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SkyConditionClient) GetX(ctx context.Context, id uuid.UUID) *SkyCondition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SkyConditionClient) Hooks() []Hook {
	return c.hooks.SkyCondition
}

// Interceptors returns the client interceptors.
func (c *SkyConditionClient) Interceptors() []Interceptor {
	return c.inters.SkyCondition
}

func (c *SkyConditionClient) mutate(ctx context.Context, m *SkyConditionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SkyConditionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SkyConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SkyConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SkyConditionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SkyCondition mutation op: %q", m.Op())
	}
}

// TafClient is a client for the Taf schema.
type TafClient struct {
	config
}

// NewTafClient returns a client for the Taf from the given config.
func NewTafClient(c config) *TafClient {
	return &TafClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taf.Hooks(f(g(h())))`.
func (c *TafClient) Use(hooks ...Hook) {
	c.hooks.Taf = append(c.hooks.Taf, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taf.Intercept(f(g(h())))`.
func (c *TafClient) Intercept(interceptors ...Interceptor) {
	c.inters.Taf = append(c.inters.Taf, interceptors...)
}

// Create returns a builder for creating a Taf entity.
func (c *TafClient) Create() *TafCreate {
	mutation := newTafMutation(c.config, OpCreate)
	return &TafCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Taf entities.
func (c *TafClient) CreateBulk(builders ...*TafCreate) *TafCreateBulk {
	return &TafCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Taf.
func (c *TafClient) Update() *TafUpdate {
	mutation := newTafMutation(c.config, OpUpdate)
	return &TafUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TafClient) UpdateOne(t *Taf) *TafUpdateOne {
	mutation := newTafMutation(c.config, OpUpdateOne, withTaf(t))
	return &TafUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TafClient) UpdateOneID(id uuid.UUID) *TafUpdateOne {
	mutation := newTafMutation(c.config, OpUpdateOne, withTafID(id))
	return &TafUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Taf.
func (c *TafClient) Delete() *TafDelete {
	mutation := newTafMutation(c.config, OpDelete)
	return &TafDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TafClient) DeleteOne(t *Taf) *TafDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TafClient) DeleteOneID(id uuid.UUID) *TafDeleteOne {
	builder := c.Delete().Where(taf.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TafDeleteOne{builder}
}

// Query returns a query builder for Taf.
func (c *TafClient) Query() *TafQuery {
	return &TafQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaf},
		inters: c.Interceptors(),
	}
}

// Get returns a Taf entity by its id.
func (c *TafClient) Get(ctx context.Context, id uuid.UUID) (*Taf, error) {
	return c.Query().Where(taf.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TafClient) GetX(ctx context.Context, id uuid.UUID) *Taf {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStation queries the station edge of a Taf.
func (c *TafClient) QueryStation(t *Taf) *WeatherStationQuery {
	query := (&WeatherStationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taf.Table, taf.FieldID, id),
			sqlgraph.To(weatherstation.Table, weatherstation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, taf.StationTable, taf.StationColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryForecast queries the forecast edge of a Taf.
func (c *TafClient) QueryForecast(t *Taf) *ForecastQuery {
	query := (&ForecastClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taf.Table, taf.FieldID, id),
			sqlgraph.To(forecast.Table, forecast.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, taf.ForecastTable, taf.ForecastColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TafClient) Hooks() []Hook {
	return c.hooks.Taf
}

// Interceptors returns the client interceptors.
func (c *TafClient) Interceptors() []Interceptor {
	return c.inters.Taf
}

func (c *TafClient) mutate(ctx context.Context, m *TafMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TafCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TafUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TafUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TafDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Taf mutation op: %q", m.Op())
	}
}

// TemperatureDataClient is a client for the TemperatureData schema.
type TemperatureDataClient struct {
	config
}

// NewTemperatureDataClient returns a client for the TemperatureData from the given config.
func NewTemperatureDataClient(c config) *TemperatureDataClient {
	return &TemperatureDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `temperaturedata.Hooks(f(g(h())))`.
func (c *TemperatureDataClient) Use(hooks ...Hook) {
	c.hooks.TemperatureData = append(c.hooks.TemperatureData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `temperaturedata.Intercept(f(g(h())))`.
func (c *TemperatureDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.TemperatureData = append(c.inters.TemperatureData, interceptors...)
}

// Create returns a builder for creating a TemperatureData entity.
func (c *TemperatureDataClient) Create() *TemperatureDataCreate {
	mutation := newTemperatureDataMutation(c.config, OpCreate)
	return &TemperatureDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TemperatureData entities.
func (c *TemperatureDataClient) CreateBulk(builders ...*TemperatureDataCreate) *TemperatureDataCreateBulk {
	return &TemperatureDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TemperatureData.
func (c *TemperatureDataClient) Update() *TemperatureDataUpdate {
	mutation := newTemperatureDataMutation(c.config, OpUpdate)
	return &TemperatureDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemperatureDataClient) UpdateOne(td *TemperatureData) *TemperatureDataUpdateOne {
	mutation := newTemperatureDataMutation(c.config, OpUpdateOne, withTemperatureData(td))
	return &TemperatureDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemperatureDataClient) UpdateOneID(id uuid.UUID) *TemperatureDataUpdateOne {
	mutation := newTemperatureDataMutation(c.config, OpUpdateOne, withTemperatureDataID(id))
	return &TemperatureDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TemperatureData.
func (c *TemperatureDataClient) Delete() *TemperatureDataDelete {
	mutation := newTemperatureDataMutation(c.config, OpDelete)
	return &TemperatureDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemperatureDataClient) DeleteOne(td *TemperatureData) *TemperatureDataDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemperatureDataClient) DeleteOneID(id uuid.UUID) *TemperatureDataDeleteOne {
	builder := c.Delete().Where(temperaturedata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemperatureDataDeleteOne{builder}
}

// Query returns a query builder for TemperatureData.
func (c *TemperatureDataClient) Query() *TemperatureDataQuery {
	return &TemperatureDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemperatureData},
		inters: c.Interceptors(),
	}
}

// Get returns a TemperatureData entity by its id.
func (c *TemperatureDataClient) Get(ctx context.Context, id uuid.UUID) (*TemperatureData, error) {
	return c.Query().Where(temperaturedata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemperatureDataClient) GetX(ctx context.Context, id uuid.UUID) *TemperatureData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TemperatureDataClient) Hooks() []Hook {
	return c.hooks.TemperatureData
}

// Interceptors returns the client interceptors.
func (c *TemperatureDataClient) Interceptors() []Interceptor {
	return c.inters.TemperatureData
}

func (c *TemperatureDataClient) mutate(ctx context.Context, m *TemperatureDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemperatureDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemperatureDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemperatureDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemperatureDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TemperatureData mutation op: %q", m.Op())
	}
}

// TurbulenceConditionClient is a client for the TurbulenceCondition schema.
type TurbulenceConditionClient struct {
	config
}

// NewTurbulenceConditionClient returns a client for the TurbulenceCondition from the given config.
func NewTurbulenceConditionClient(c config) *TurbulenceConditionClient {
	return &TurbulenceConditionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `turbulencecondition.Hooks(f(g(h())))`.
func (c *TurbulenceConditionClient) Use(hooks ...Hook) {
	c.hooks.TurbulenceCondition = append(c.hooks.TurbulenceCondition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `turbulencecondition.Intercept(f(g(h())))`.
func (c *TurbulenceConditionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TurbulenceCondition = append(c.inters.TurbulenceCondition, interceptors...)
}

// Create returns a builder for creating a TurbulenceCondition entity.
func (c *TurbulenceConditionClient) Create() *TurbulenceConditionCreate {
	mutation := newTurbulenceConditionMutation(c.config, OpCreate)
	return &TurbulenceConditionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TurbulenceCondition entities.
func (c *TurbulenceConditionClient) CreateBulk(builders ...*TurbulenceConditionCreate) *TurbulenceConditionCreateBulk {
	return &TurbulenceConditionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TurbulenceCondition.
func (c *TurbulenceConditionClient) Update() *TurbulenceConditionUpdate {
	mutation := newTurbulenceConditionMutation(c.config, OpUpdate)
	return &TurbulenceConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TurbulenceConditionClient) UpdateOne(tc *TurbulenceCondition) *TurbulenceConditionUpdateOne {
	mutation := newTurbulenceConditionMutation(c.config, OpUpdateOne, withTurbulenceCondition(tc))
	return &TurbulenceConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TurbulenceConditionClient) UpdateOneID(id uuid.UUID) *TurbulenceConditionUpdateOne {
	mutation := newTurbulenceConditionMutation(c.config, OpUpdateOne, withTurbulenceConditionID(id))
	return &TurbulenceConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TurbulenceCondition.
func (c *TurbulenceConditionClient) Delete() *TurbulenceConditionDelete {
	mutation := newTurbulenceConditionMutation(c.config, OpDelete)
	return &TurbulenceConditionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TurbulenceConditionClient) DeleteOne(tc *TurbulenceCondition) *TurbulenceConditionDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TurbulenceConditionClient) DeleteOneID(id uuid.UUID) *TurbulenceConditionDeleteOne {
	builder := c.Delete().Where(turbulencecondition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TurbulenceConditionDeleteOne{builder}
}

// Query returns a query builder for TurbulenceCondition.
func (c *TurbulenceConditionClient) Query() *TurbulenceConditionQuery {
	return &TurbulenceConditionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTurbulenceCondition},
		inters: c.Interceptors(),
	}
}

// Get returns a TurbulenceCondition entity by its id.
func (c *TurbulenceConditionClient) Get(ctx context.Context, id uuid.UUID) (*TurbulenceCondition, error) {
	return c.Query().Where(turbulencecondition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TurbulenceConditionClient) GetX(ctx context.Context, id uuid.UUID) *TurbulenceCondition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TurbulenceConditionClient) Hooks() []Hook {
	return c.hooks.TurbulenceCondition
}

// Interceptors returns the client interceptors.
func (c *TurbulenceConditionClient) Interceptors() []Interceptor {
	return c.inters.TurbulenceCondition
}

func (c *TurbulenceConditionClient) mutate(ctx context.Context, m *TurbulenceConditionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TurbulenceConditionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TurbulenceConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TurbulenceConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TurbulenceConditionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TurbulenceCondition mutation op: %q", m.Op())
	}
}

// WeatherStationClient is a client for the WeatherStation schema.
type WeatherStationClient struct {
	config
}

// NewWeatherStationClient returns a client for the WeatherStation from the given config.
func NewWeatherStationClient(c config) *WeatherStationClient {
	return &WeatherStationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `weatherstation.Hooks(f(g(h())))`.
func (c *WeatherStationClient) Use(hooks ...Hook) {
	c.hooks.WeatherStation = append(c.hooks.WeatherStation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `weatherstation.Intercept(f(g(h())))`.
func (c *WeatherStationClient) Intercept(interceptors ...Interceptor) {
	c.inters.WeatherStation = append(c.inters.WeatherStation, interceptors...)
}

// Create returns a builder for creating a WeatherStation entity.
func (c *WeatherStationClient) Create() *WeatherStationCreate {
	mutation := newWeatherStationMutation(c.config, OpCreate)
	return &WeatherStationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WeatherStation entities.
func (c *WeatherStationClient) CreateBulk(builders ...*WeatherStationCreate) *WeatherStationCreateBulk {
	return &WeatherStationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WeatherStation.
func (c *WeatherStationClient) Update() *WeatherStationUpdate {
	mutation := newWeatherStationMutation(c.config, OpUpdate)
	return &WeatherStationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WeatherStationClient) UpdateOne(ws *WeatherStation) *WeatherStationUpdateOne {
	mutation := newWeatherStationMutation(c.config, OpUpdateOne, withWeatherStation(ws))
	return &WeatherStationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WeatherStationClient) UpdateOneID(id uuid.UUID) *WeatherStationUpdateOne {
	mutation := newWeatherStationMutation(c.config, OpUpdateOne, withWeatherStationID(id))
	return &WeatherStationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WeatherStation.
func (c *WeatherStationClient) Delete() *WeatherStationDelete {
	mutation := newWeatherStationMutation(c.config, OpDelete)
	return &WeatherStationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WeatherStationClient) DeleteOne(ws *WeatherStation) *WeatherStationDeleteOne {
	return c.DeleteOneID(ws.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WeatherStationClient) DeleteOneID(id uuid.UUID) *WeatherStationDeleteOne {
	builder := c.Delete().Where(weatherstation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WeatherStationDeleteOne{builder}
}

// Query returns a query builder for WeatherStation.
func (c *WeatherStationClient) Query() *WeatherStationQuery {
	return &WeatherStationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWeatherStation},
		inters: c.Interceptors(),
	}
}

// Get returns a WeatherStation entity by its id.
func (c *WeatherStationClient) Get(ctx context.Context, id uuid.UUID) (*WeatherStation, error) {
	return c.Query().Where(weatherstation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WeatherStationClient) GetX(ctx context.Context, id uuid.UUID) *WeatherStation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAirport queries the airport edge of a WeatherStation.
func (c *WeatherStationClient) QueryAirport(ws *WeatherStation) *AirportQuery {
	query := (&AirportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(weatherstation.Table, weatherstation.FieldID, id),
			sqlgraph.To(airport.Table, airport.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, weatherstation.AirportTable, weatherstation.AirportColumn),
		)
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetars queries the metars edge of a WeatherStation.
func (c *WeatherStationClient) QueryMetars(ws *WeatherStation) *MetarQuery {
	query := (&MetarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(weatherstation.Table, weatherstation.FieldID, id),
			sqlgraph.To(metar.Table, metar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, weatherstation.MetarsTable, weatherstation.MetarsColumn),
		)
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTafs queries the tafs edge of a WeatherStation.
func (c *WeatherStationClient) QueryTafs(ws *WeatherStation) *TafQuery {
	query := (&TafClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(weatherstation.Table, weatherstation.FieldID, id),
			sqlgraph.To(taf.Table, taf.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, weatherstation.TafsTable, weatherstation.TafsColumn),
		)
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WeatherStationClient) Hooks() []Hook {
	return c.hooks.WeatherStation
}

// Interceptors returns the client interceptors.
func (c *WeatherStationClient) Interceptors() []Interceptor {
	return c.inters.WeatherStation
}

func (c *WeatherStationClient) mutate(ctx context.Context, m *WeatherStationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WeatherStationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WeatherStationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WeatherStationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WeatherStationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WeatherStation mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Airport, Country, Forecast, Frequency, IcingCondition, Metar, Region, Runway,
		SkyCondition, Taf, TemperatureData, TurbulenceCondition,
		WeatherStation []ent.Hook
	}
	inters struct {
		Airport, Country, Forecast, Frequency, IcingCondition, Metar, Region, Runway,
		SkyCondition, Taf, TemperatureData, TurbulenceCondition,
		WeatherStation []ent.Interceptor
	}
)
