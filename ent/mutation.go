// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"metar.gg/ent/airport"
	"metar.gg/ent/frequency"
	"metar.gg/ent/metar"
	"metar.gg/ent/predicate"
	"metar.gg/ent/runway"
	"metar.gg/ent/skycondition"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAirport      = "Airport"
	TypeFrequency    = "Frequency"
	TypeMetar        = "Metar"
	TypeRunway       = "Runway"
	TypeSkyCondition = "SkyCondition"
)

// AirportMutation represents an operation that mutates the Airport nodes in the graph.
type AirportMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	hash               *string
	import_flag        *bool
	last_updated       *time.Time
	identifier         *string
	_type              *airport.Type
	name               *string
	latitude           *float64
	addlatitude        *float64
	longitude          *float64
	addlongitude       *float64
	elevation          *int
	addelevation       *int
	continent          *airport.Continent
	country            *string
	region             *string
	has_weather        *bool
	municipality       *string
	scheduled_service  *bool
	gps_code           *string
	iata_code          *string
	local_code         *string
	website            *string
	wikipedia          *string
	keywords           *[]string
	clearedFields      map[string]struct{}
	runways            map[int]struct{}
	removedrunways     map[int]struct{}
	clearedrunways     bool
	frequencies        map[int]struct{}
	removedfrequencies map[int]struct{}
	clearedfrequencies bool
	metars             map[int]struct{}
	removedmetars      map[int]struct{}
	clearedmetars      bool
	done               bool
	oldValue           func(context.Context) (*Airport, error)
	predicates         []predicate.Airport
}

var _ ent.Mutation = (*AirportMutation)(nil)

// airportOption allows management of the mutation configuration using functional options.
type airportOption func(*AirportMutation)

// newAirportMutation creates new mutation for the Airport entity.
func newAirportMutation(c config, op Op, opts ...airportOption) *AirportMutation {
	m := &AirportMutation{
		config:        c,
		op:            op,
		typ:           TypeAirport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirportID sets the ID field of the mutation.
func withAirportID(id int) airportOption {
	return func(m *AirportMutation) {
		var (
			err   error
			once  sync.Once
			value *Airport
		)
		m.oldValue = func(ctx context.Context) (*Airport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirport sets the old Airport of the mutation.
func withAirport(node *Airport) airportOption {
	return func(m *AirportMutation) {
		m.oldValue = func(context.Context) (*Airport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Airport entities.
func (m *AirportMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *AirportMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *AirportMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *AirportMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *AirportMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *AirportMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *AirportMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *AirportMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *AirportMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *AirportMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetIdentifier sets the "identifier" field.
func (m *AirportMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *AirportMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *AirportMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetType sets the "type" field.
func (m *AirportMutation) SetType(a airport.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AirportMutation) GetType() (r airport.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldType(ctx context.Context) (v airport.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AirportMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *AirportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirportMutation) ResetName() {
	m.name = nil
}

// SetLatitude sets the "latitude" field.
func (m *AirportMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *AirportMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *AirportMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *AirportMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *AirportMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *AirportMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *AirportMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *AirportMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *AirportMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *AirportMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetElevation sets the "elevation" field.
func (m *AirportMutation) SetElevation(i int) {
	m.elevation = &i
	m.addelevation = nil
}

// Elevation returns the value of the "elevation" field in the mutation.
func (m *AirportMutation) Elevation() (r int, exists bool) {
	v := m.elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldElevation returns the old "elevation" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldElevation(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElevation: %w", err)
	}
	return oldValue.Elevation, nil
}

// AddElevation adds i to the "elevation" field.
func (m *AirportMutation) AddElevation(i int) {
	if m.addelevation != nil {
		*m.addelevation += i
	} else {
		m.addelevation = &i
	}
}

// AddedElevation returns the value that was added to the "elevation" field in this mutation.
func (m *AirportMutation) AddedElevation() (r int, exists bool) {
	v := m.addelevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearElevation clears the value of the "elevation" field.
func (m *AirportMutation) ClearElevation() {
	m.elevation = nil
	m.addelevation = nil
	m.clearedFields[airport.FieldElevation] = struct{}{}
}

// ElevationCleared returns if the "elevation" field was cleared in this mutation.
func (m *AirportMutation) ElevationCleared() bool {
	_, ok := m.clearedFields[airport.FieldElevation]
	return ok
}

// ResetElevation resets all changes to the "elevation" field.
func (m *AirportMutation) ResetElevation() {
	m.elevation = nil
	m.addelevation = nil
	delete(m.clearedFields, airport.FieldElevation)
}

// SetContinent sets the "continent" field.
func (m *AirportMutation) SetContinent(a airport.Continent) {
	m.continent = &a
}

// Continent returns the value of the "continent" field in the mutation.
func (m *AirportMutation) Continent() (r airport.Continent, exists bool) {
	v := m.continent
	if v == nil {
		return
	}
	return *v, true
}

// OldContinent returns the old "continent" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldContinent(ctx context.Context) (v airport.Continent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinent: %w", err)
	}
	return oldValue.Continent, nil
}

// ResetContinent resets all changes to the "continent" field.
func (m *AirportMutation) ResetContinent() {
	m.continent = nil
}

// SetCountry sets the "country" field.
func (m *AirportMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AirportMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *AirportMutation) ResetCountry() {
	m.country = nil
}

// SetRegion sets the "region" field.
func (m *AirportMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *AirportMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *AirportMutation) ResetRegion() {
	m.region = nil
}

// SetHasWeather sets the "has_weather" field.
func (m *AirportMutation) SetHasWeather(b bool) {
	m.has_weather = &b
}

// HasWeather returns the value of the "has_weather" field in the mutation.
func (m *AirportMutation) HasWeather() (r bool, exists bool) {
	v := m.has_weather
	if v == nil {
		return
	}
	return *v, true
}

// OldHasWeather returns the old "has_weather" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldHasWeather(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasWeather is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasWeather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasWeather: %w", err)
	}
	return oldValue.HasWeather, nil
}

// ResetHasWeather resets all changes to the "has_weather" field.
func (m *AirportMutation) ResetHasWeather() {
	m.has_weather = nil
}

// SetMunicipality sets the "municipality" field.
func (m *AirportMutation) SetMunicipality(s string) {
	m.municipality = &s
}

// Municipality returns the value of the "municipality" field in the mutation.
func (m *AirportMutation) Municipality() (r string, exists bool) {
	v := m.municipality
	if v == nil {
		return
	}
	return *v, true
}

// OldMunicipality returns the old "municipality" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldMunicipality(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMunicipality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMunicipality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMunicipality: %w", err)
	}
	return oldValue.Municipality, nil
}

// ClearMunicipality clears the value of the "municipality" field.
func (m *AirportMutation) ClearMunicipality() {
	m.municipality = nil
	m.clearedFields[airport.FieldMunicipality] = struct{}{}
}

// MunicipalityCleared returns if the "municipality" field was cleared in this mutation.
func (m *AirportMutation) MunicipalityCleared() bool {
	_, ok := m.clearedFields[airport.FieldMunicipality]
	return ok
}

// ResetMunicipality resets all changes to the "municipality" field.
func (m *AirportMutation) ResetMunicipality() {
	m.municipality = nil
	delete(m.clearedFields, airport.FieldMunicipality)
}

// SetScheduledService sets the "scheduled_service" field.
func (m *AirportMutation) SetScheduledService(b bool) {
	m.scheduled_service = &b
}

// ScheduledService returns the value of the "scheduled_service" field in the mutation.
func (m *AirportMutation) ScheduledService() (r bool, exists bool) {
	v := m.scheduled_service
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledService returns the old "scheduled_service" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldScheduledService(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledService: %w", err)
	}
	return oldValue.ScheduledService, nil
}

// ResetScheduledService resets all changes to the "scheduled_service" field.
func (m *AirportMutation) ResetScheduledService() {
	m.scheduled_service = nil
}

// SetGpsCode sets the "gps_code" field.
func (m *AirportMutation) SetGpsCode(s string) {
	m.gps_code = &s
}

// GpsCode returns the value of the "gps_code" field in the mutation.
func (m *AirportMutation) GpsCode() (r string, exists bool) {
	v := m.gps_code
	if v == nil {
		return
	}
	return *v, true
}

// OldGpsCode returns the old "gps_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldGpsCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpsCode: %w", err)
	}
	return oldValue.GpsCode, nil
}

// ClearGpsCode clears the value of the "gps_code" field.
func (m *AirportMutation) ClearGpsCode() {
	m.gps_code = nil
	m.clearedFields[airport.FieldGpsCode] = struct{}{}
}

// GpsCodeCleared returns if the "gps_code" field was cleared in this mutation.
func (m *AirportMutation) GpsCodeCleared() bool {
	_, ok := m.clearedFields[airport.FieldGpsCode]
	return ok
}

// ResetGpsCode resets all changes to the "gps_code" field.
func (m *AirportMutation) ResetGpsCode() {
	m.gps_code = nil
	delete(m.clearedFields, airport.FieldGpsCode)
}

// SetIataCode sets the "iata_code" field.
func (m *AirportMutation) SetIataCode(s string) {
	m.iata_code = &s
}

// IataCode returns the value of the "iata_code" field in the mutation.
func (m *AirportMutation) IataCode() (r string, exists bool) {
	v := m.iata_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIataCode returns the old "iata_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldIataCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIataCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIataCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIataCode: %w", err)
	}
	return oldValue.IataCode, nil
}

// ClearIataCode clears the value of the "iata_code" field.
func (m *AirportMutation) ClearIataCode() {
	m.iata_code = nil
	m.clearedFields[airport.FieldIataCode] = struct{}{}
}

// IataCodeCleared returns if the "iata_code" field was cleared in this mutation.
func (m *AirportMutation) IataCodeCleared() bool {
	_, ok := m.clearedFields[airport.FieldIataCode]
	return ok
}

// ResetIataCode resets all changes to the "iata_code" field.
func (m *AirportMutation) ResetIataCode() {
	m.iata_code = nil
	delete(m.clearedFields, airport.FieldIataCode)
}

// SetLocalCode sets the "local_code" field.
func (m *AirportMutation) SetLocalCode(s string) {
	m.local_code = &s
}

// LocalCode returns the value of the "local_code" field in the mutation.
func (m *AirportMutation) LocalCode() (r string, exists bool) {
	v := m.local_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalCode returns the old "local_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLocalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalCode: %w", err)
	}
	return oldValue.LocalCode, nil
}

// ClearLocalCode clears the value of the "local_code" field.
func (m *AirportMutation) ClearLocalCode() {
	m.local_code = nil
	m.clearedFields[airport.FieldLocalCode] = struct{}{}
}

// LocalCodeCleared returns if the "local_code" field was cleared in this mutation.
func (m *AirportMutation) LocalCodeCleared() bool {
	_, ok := m.clearedFields[airport.FieldLocalCode]
	return ok
}

// ResetLocalCode resets all changes to the "local_code" field.
func (m *AirportMutation) ResetLocalCode() {
	m.local_code = nil
	delete(m.clearedFields, airport.FieldLocalCode)
}

// SetWebsite sets the "website" field.
func (m *AirportMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *AirportMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *AirportMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[airport.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *AirportMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[airport.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *AirportMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, airport.FieldWebsite)
}

// SetWikipedia sets the "wikipedia" field.
func (m *AirportMutation) SetWikipedia(s string) {
	m.wikipedia = &s
}

// Wikipedia returns the value of the "wikipedia" field in the mutation.
func (m *AirportMutation) Wikipedia() (r string, exists bool) {
	v := m.wikipedia
	if v == nil {
		return
	}
	return *v, true
}

// OldWikipedia returns the old "wikipedia" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldWikipedia(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWikipedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWikipedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWikipedia: %w", err)
	}
	return oldValue.Wikipedia, nil
}

// ClearWikipedia clears the value of the "wikipedia" field.
func (m *AirportMutation) ClearWikipedia() {
	m.wikipedia = nil
	m.clearedFields[airport.FieldWikipedia] = struct{}{}
}

// WikipediaCleared returns if the "wikipedia" field was cleared in this mutation.
func (m *AirportMutation) WikipediaCleared() bool {
	_, ok := m.clearedFields[airport.FieldWikipedia]
	return ok
}

// ResetWikipedia resets all changes to the "wikipedia" field.
func (m *AirportMutation) ResetWikipedia() {
	m.wikipedia = nil
	delete(m.clearedFields, airport.FieldWikipedia)
}

// SetKeywords sets the "keywords" field.
func (m *AirportMutation) SetKeywords(s []string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *AirportMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *AirportMutation) ResetKeywords() {
	m.keywords = nil
}

// AddRunwayIDs adds the "runways" edge to the Runway entity by ids.
func (m *AirportMutation) AddRunwayIDs(ids ...int) {
	if m.runways == nil {
		m.runways = make(map[int]struct{})
	}
	for i := range ids {
		m.runways[ids[i]] = struct{}{}
	}
}

// ClearRunways clears the "runways" edge to the Runway entity.
func (m *AirportMutation) ClearRunways() {
	m.clearedrunways = true
}

// RunwaysCleared reports if the "runways" edge to the Runway entity was cleared.
func (m *AirportMutation) RunwaysCleared() bool {
	return m.clearedrunways
}

// RemoveRunwayIDs removes the "runways" edge to the Runway entity by IDs.
func (m *AirportMutation) RemoveRunwayIDs(ids ...int) {
	if m.removedrunways == nil {
		m.removedrunways = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.runways, ids[i])
		m.removedrunways[ids[i]] = struct{}{}
	}
}

// RemovedRunways returns the removed IDs of the "runways" edge to the Runway entity.
func (m *AirportMutation) RemovedRunwaysIDs() (ids []int) {
	for id := range m.removedrunways {
		ids = append(ids, id)
	}
	return
}

// RunwaysIDs returns the "runways" edge IDs in the mutation.
func (m *AirportMutation) RunwaysIDs() (ids []int) {
	for id := range m.runways {
		ids = append(ids, id)
	}
	return
}

// ResetRunways resets all changes to the "runways" edge.
func (m *AirportMutation) ResetRunways() {
	m.runways = nil
	m.clearedrunways = false
	m.removedrunways = nil
}

// AddFrequencyIDs adds the "frequencies" edge to the Frequency entity by ids.
func (m *AirportMutation) AddFrequencyIDs(ids ...int) {
	if m.frequencies == nil {
		m.frequencies = make(map[int]struct{})
	}
	for i := range ids {
		m.frequencies[ids[i]] = struct{}{}
	}
}

// ClearFrequencies clears the "frequencies" edge to the Frequency entity.
func (m *AirportMutation) ClearFrequencies() {
	m.clearedfrequencies = true
}

// FrequenciesCleared reports if the "frequencies" edge to the Frequency entity was cleared.
func (m *AirportMutation) FrequenciesCleared() bool {
	return m.clearedfrequencies
}

// RemoveFrequencyIDs removes the "frequencies" edge to the Frequency entity by IDs.
func (m *AirportMutation) RemoveFrequencyIDs(ids ...int) {
	if m.removedfrequencies == nil {
		m.removedfrequencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.frequencies, ids[i])
		m.removedfrequencies[ids[i]] = struct{}{}
	}
}

// RemovedFrequencies returns the removed IDs of the "frequencies" edge to the Frequency entity.
func (m *AirportMutation) RemovedFrequenciesIDs() (ids []int) {
	for id := range m.removedfrequencies {
		ids = append(ids, id)
	}
	return
}

// FrequenciesIDs returns the "frequencies" edge IDs in the mutation.
func (m *AirportMutation) FrequenciesIDs() (ids []int) {
	for id := range m.frequencies {
		ids = append(ids, id)
	}
	return
}

// ResetFrequencies resets all changes to the "frequencies" edge.
func (m *AirportMutation) ResetFrequencies() {
	m.frequencies = nil
	m.clearedfrequencies = false
	m.removedfrequencies = nil
}

// AddMetarIDs adds the "metars" edge to the Metar entity by ids.
func (m *AirportMutation) AddMetarIDs(ids ...int) {
	if m.metars == nil {
		m.metars = make(map[int]struct{})
	}
	for i := range ids {
		m.metars[ids[i]] = struct{}{}
	}
}

// ClearMetars clears the "metars" edge to the Metar entity.
func (m *AirportMutation) ClearMetars() {
	m.clearedmetars = true
}

// MetarsCleared reports if the "metars" edge to the Metar entity was cleared.
func (m *AirportMutation) MetarsCleared() bool {
	return m.clearedmetars
}

// RemoveMetarIDs removes the "metars" edge to the Metar entity by IDs.
func (m *AirportMutation) RemoveMetarIDs(ids ...int) {
	if m.removedmetars == nil {
		m.removedmetars = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metars, ids[i])
		m.removedmetars[ids[i]] = struct{}{}
	}
}

// RemovedMetars returns the removed IDs of the "metars" edge to the Metar entity.
func (m *AirportMutation) RemovedMetarsIDs() (ids []int) {
	for id := range m.removedmetars {
		ids = append(ids, id)
	}
	return
}

// MetarsIDs returns the "metars" edge IDs in the mutation.
func (m *AirportMutation) MetarsIDs() (ids []int) {
	for id := range m.metars {
		ids = append(ids, id)
	}
	return
}

// ResetMetars resets all changes to the "metars" edge.
func (m *AirportMutation) ResetMetars() {
	m.metars = nil
	m.clearedmetars = false
	m.removedmetars = nil
}

// Where appends a list predicates to the AirportMutation builder.
func (m *AirportMutation) Where(ps ...predicate.Airport) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AirportMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Airport).
func (m *AirportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirportMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.hash != nil {
		fields = append(fields, airport.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, airport.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, airport.FieldLastUpdated)
	}
	if m.identifier != nil {
		fields = append(fields, airport.FieldIdentifier)
	}
	if m._type != nil {
		fields = append(fields, airport.FieldType)
	}
	if m.name != nil {
		fields = append(fields, airport.FieldName)
	}
	if m.latitude != nil {
		fields = append(fields, airport.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, airport.FieldLongitude)
	}
	if m.elevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	if m.continent != nil {
		fields = append(fields, airport.FieldContinent)
	}
	if m.country != nil {
		fields = append(fields, airport.FieldCountry)
	}
	if m.region != nil {
		fields = append(fields, airport.FieldRegion)
	}
	if m.has_weather != nil {
		fields = append(fields, airport.FieldHasWeather)
	}
	if m.municipality != nil {
		fields = append(fields, airport.FieldMunicipality)
	}
	if m.scheduled_service != nil {
		fields = append(fields, airport.FieldScheduledService)
	}
	if m.gps_code != nil {
		fields = append(fields, airport.FieldGpsCode)
	}
	if m.iata_code != nil {
		fields = append(fields, airport.FieldIataCode)
	}
	if m.local_code != nil {
		fields = append(fields, airport.FieldLocalCode)
	}
	if m.website != nil {
		fields = append(fields, airport.FieldWebsite)
	}
	if m.wikipedia != nil {
		fields = append(fields, airport.FieldWikipedia)
	}
	if m.keywords != nil {
		fields = append(fields, airport.FieldKeywords)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldHash:
		return m.Hash()
	case airport.FieldImportFlag:
		return m.ImportFlag()
	case airport.FieldLastUpdated:
		return m.LastUpdated()
	case airport.FieldIdentifier:
		return m.Identifier()
	case airport.FieldType:
		return m.GetType()
	case airport.FieldName:
		return m.Name()
	case airport.FieldLatitude:
		return m.Latitude()
	case airport.FieldLongitude:
		return m.Longitude()
	case airport.FieldElevation:
		return m.Elevation()
	case airport.FieldContinent:
		return m.Continent()
	case airport.FieldCountry:
		return m.Country()
	case airport.FieldRegion:
		return m.Region()
	case airport.FieldHasWeather:
		return m.HasWeather()
	case airport.FieldMunicipality:
		return m.Municipality()
	case airport.FieldScheduledService:
		return m.ScheduledService()
	case airport.FieldGpsCode:
		return m.GpsCode()
	case airport.FieldIataCode:
		return m.IataCode()
	case airport.FieldLocalCode:
		return m.LocalCode()
	case airport.FieldWebsite:
		return m.Website()
	case airport.FieldWikipedia:
		return m.Wikipedia()
	case airport.FieldKeywords:
		return m.Keywords()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airport.FieldHash:
		return m.OldHash(ctx)
	case airport.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case airport.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case airport.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case airport.FieldType:
		return m.OldType(ctx)
	case airport.FieldName:
		return m.OldName(ctx)
	case airport.FieldLatitude:
		return m.OldLatitude(ctx)
	case airport.FieldLongitude:
		return m.OldLongitude(ctx)
	case airport.FieldElevation:
		return m.OldElevation(ctx)
	case airport.FieldContinent:
		return m.OldContinent(ctx)
	case airport.FieldCountry:
		return m.OldCountry(ctx)
	case airport.FieldRegion:
		return m.OldRegion(ctx)
	case airport.FieldHasWeather:
		return m.OldHasWeather(ctx)
	case airport.FieldMunicipality:
		return m.OldMunicipality(ctx)
	case airport.FieldScheduledService:
		return m.OldScheduledService(ctx)
	case airport.FieldGpsCode:
		return m.OldGpsCode(ctx)
	case airport.FieldIataCode:
		return m.OldIataCode(ctx)
	case airport.FieldLocalCode:
		return m.OldLocalCode(ctx)
	case airport.FieldWebsite:
		return m.OldWebsite(ctx)
	case airport.FieldWikipedia:
		return m.OldWikipedia(ctx)
	case airport.FieldKeywords:
		return m.OldKeywords(ctx)
	}
	return nil, fmt.Errorf("unknown Airport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airport.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case airport.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case airport.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case airport.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case airport.FieldType:
		v, ok := value.(airport.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case airport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airport.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case airport.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case airport.FieldElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElevation(v)
		return nil
	case airport.FieldContinent:
		v, ok := value.(airport.Continent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinent(v)
		return nil
	case airport.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case airport.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case airport.FieldHasWeather:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasWeather(v)
		return nil
	case airport.FieldMunicipality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMunicipality(v)
		return nil
	case airport.FieldScheduledService:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledService(v)
		return nil
	case airport.FieldGpsCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpsCode(v)
		return nil
	case airport.FieldIataCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIataCode(v)
		return nil
	case airport.FieldLocalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalCode(v)
		return nil
	case airport.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case airport.FieldWikipedia:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWikipedia(v)
		return nil
	case airport.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirportMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, airport.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, airport.FieldLongitude)
	}
	if m.addelevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldLatitude:
		return m.AddedLatitude()
	case airport.FieldLongitude:
		return m.AddedLongitude()
	case airport.FieldElevation:
		return m.AddedElevation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case airport.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case airport.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case airport.FieldElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElevation(v)
		return nil
	}
	return fmt.Errorf("unknown Airport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(airport.FieldElevation) {
		fields = append(fields, airport.FieldElevation)
	}
	if m.FieldCleared(airport.FieldMunicipality) {
		fields = append(fields, airport.FieldMunicipality)
	}
	if m.FieldCleared(airport.FieldGpsCode) {
		fields = append(fields, airport.FieldGpsCode)
	}
	if m.FieldCleared(airport.FieldIataCode) {
		fields = append(fields, airport.FieldIataCode)
	}
	if m.FieldCleared(airport.FieldLocalCode) {
		fields = append(fields, airport.FieldLocalCode)
	}
	if m.FieldCleared(airport.FieldWebsite) {
		fields = append(fields, airport.FieldWebsite)
	}
	if m.FieldCleared(airport.FieldWikipedia) {
		fields = append(fields, airport.FieldWikipedia)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirportMutation) ClearField(name string) error {
	switch name {
	case airport.FieldElevation:
		m.ClearElevation()
		return nil
	case airport.FieldMunicipality:
		m.ClearMunicipality()
		return nil
	case airport.FieldGpsCode:
		m.ClearGpsCode()
		return nil
	case airport.FieldIataCode:
		m.ClearIataCode()
		return nil
	case airport.FieldLocalCode:
		m.ClearLocalCode()
		return nil
	case airport.FieldWebsite:
		m.ClearWebsite()
		return nil
	case airport.FieldWikipedia:
		m.ClearWikipedia()
		return nil
	}
	return fmt.Errorf("unknown Airport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirportMutation) ResetField(name string) error {
	switch name {
	case airport.FieldHash:
		m.ResetHash()
		return nil
	case airport.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case airport.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case airport.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case airport.FieldType:
		m.ResetType()
		return nil
	case airport.FieldName:
		m.ResetName()
		return nil
	case airport.FieldLatitude:
		m.ResetLatitude()
		return nil
	case airport.FieldLongitude:
		m.ResetLongitude()
		return nil
	case airport.FieldElevation:
		m.ResetElevation()
		return nil
	case airport.FieldContinent:
		m.ResetContinent()
		return nil
	case airport.FieldCountry:
		m.ResetCountry()
		return nil
	case airport.FieldRegion:
		m.ResetRegion()
		return nil
	case airport.FieldHasWeather:
		m.ResetHasWeather()
		return nil
	case airport.FieldMunicipality:
		m.ResetMunicipality()
		return nil
	case airport.FieldScheduledService:
		m.ResetScheduledService()
		return nil
	case airport.FieldGpsCode:
		m.ResetGpsCode()
		return nil
	case airport.FieldIataCode:
		m.ResetIataCode()
		return nil
	case airport.FieldLocalCode:
		m.ResetLocalCode()
		return nil
	case airport.FieldWebsite:
		m.ResetWebsite()
		return nil
	case airport.FieldWikipedia:
		m.ResetWikipedia()
		return nil
	case airport.FieldKeywords:
		m.ResetKeywords()
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirportMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.runways != nil {
		edges = append(edges, airport.EdgeRunways)
	}
	if m.frequencies != nil {
		edges = append(edges, airport.EdgeFrequencies)
	}
	if m.metars != nil {
		edges = append(edges, airport.EdgeMetars)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeRunways:
		ids := make([]ent.Value, 0, len(m.runways))
		for id := range m.runways {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeFrequencies:
		ids := make([]ent.Value, 0, len(m.frequencies))
		for id := range m.frequencies {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeMetars:
		ids := make([]ent.Value, 0, len(m.metars))
		for id := range m.metars {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrunways != nil {
		edges = append(edges, airport.EdgeRunways)
	}
	if m.removedfrequencies != nil {
		edges = append(edges, airport.EdgeFrequencies)
	}
	if m.removedmetars != nil {
		edges = append(edges, airport.EdgeMetars)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeRunways:
		ids := make([]ent.Value, 0, len(m.removedrunways))
		for id := range m.removedrunways {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeFrequencies:
		ids := make([]ent.Value, 0, len(m.removedfrequencies))
		for id := range m.removedfrequencies {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeMetars:
		ids := make([]ent.Value, 0, len(m.removedmetars))
		for id := range m.removedmetars {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrunways {
		edges = append(edges, airport.EdgeRunways)
	}
	if m.clearedfrequencies {
		edges = append(edges, airport.EdgeFrequencies)
	}
	if m.clearedmetars {
		edges = append(edges, airport.EdgeMetars)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirportMutation) EdgeCleared(name string) bool {
	switch name {
	case airport.EdgeRunways:
		return m.clearedrunways
	case airport.EdgeFrequencies:
		return m.clearedfrequencies
	case airport.EdgeMetars:
		return m.clearedmetars
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirportMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Airport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirportMutation) ResetEdge(name string) error {
	switch name {
	case airport.EdgeRunways:
		m.ResetRunways()
		return nil
	case airport.EdgeFrequencies:
		m.ResetFrequencies()
		return nil
	case airport.EdgeMetars:
		m.ResetMetars()
		return nil
	}
	return fmt.Errorf("unknown Airport edge %s", name)
}

// FrequencyMutation represents an operation that mutates the Frequency nodes in the graph.
type FrequencyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	hash           *string
	import_flag    *bool
	last_updated   *time.Time
	_type          *string
	description    *string
	frequency      *float64
	addfrequency   *float64
	clearedFields  map[string]struct{}
	airport        *int
	clearedairport bool
	done           bool
	oldValue       func(context.Context) (*Frequency, error)
	predicates     []predicate.Frequency
}

var _ ent.Mutation = (*FrequencyMutation)(nil)

// frequencyOption allows management of the mutation configuration using functional options.
type frequencyOption func(*FrequencyMutation)

// newFrequencyMutation creates new mutation for the Frequency entity.
func newFrequencyMutation(c config, op Op, opts ...frequencyOption) *FrequencyMutation {
	m := &FrequencyMutation{
		config:        c,
		op:            op,
		typ:           TypeFrequency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrequencyID sets the ID field of the mutation.
func withFrequencyID(id int) frequencyOption {
	return func(m *FrequencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Frequency
		)
		m.oldValue = func(ctx context.Context) (*Frequency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Frequency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrequency sets the old Frequency of the mutation.
func withFrequency(node *Frequency) frequencyOption {
	return func(m *FrequencyMutation) {
		m.oldValue = func(context.Context) (*Frequency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrequencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrequencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Frequency entities.
func (m *FrequencyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrequencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrequencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Frequency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *FrequencyMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *FrequencyMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *FrequencyMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *FrequencyMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *FrequencyMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *FrequencyMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *FrequencyMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *FrequencyMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *FrequencyMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetType sets the "type" field.
func (m *FrequencyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FrequencyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FrequencyMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *FrequencyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FrequencyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FrequencyMutation) ResetDescription() {
	m.description = nil
}

// SetFrequency sets the "frequency" field.
func (m *FrequencyMutation) SetFrequency(f float64) {
	m.frequency = &f
	m.addfrequency = nil
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *FrequencyMutation) Frequency() (r float64, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldFrequency(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// AddFrequency adds f to the "frequency" field.
func (m *FrequencyMutation) AddFrequency(f float64) {
	if m.addfrequency != nil {
		*m.addfrequency += f
	} else {
		m.addfrequency = &f
	}
}

// AddedFrequency returns the value that was added to the "frequency" field in this mutation.
func (m *FrequencyMutation) AddedFrequency() (r float64, exists bool) {
	v := m.addfrequency
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *FrequencyMutation) ResetFrequency() {
	m.frequency = nil
	m.addfrequency = nil
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *FrequencyMutation) SetAirportID(id int) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *FrequencyMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *FrequencyMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *FrequencyMutation) AirportID() (id int, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *FrequencyMutation) AirportIDs() (ids []int) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *FrequencyMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// Where appends a list predicates to the FrequencyMutation builder.
func (m *FrequencyMutation) Where(ps ...predicate.Frequency) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FrequencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Frequency).
func (m *FrequencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrequencyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hash != nil {
		fields = append(fields, frequency.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, frequency.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, frequency.FieldLastUpdated)
	}
	if m._type != nil {
		fields = append(fields, frequency.FieldType)
	}
	if m.description != nil {
		fields = append(fields, frequency.FieldDescription)
	}
	if m.frequency != nil {
		fields = append(fields, frequency.FieldFrequency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrequencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frequency.FieldHash:
		return m.Hash()
	case frequency.FieldImportFlag:
		return m.ImportFlag()
	case frequency.FieldLastUpdated:
		return m.LastUpdated()
	case frequency.FieldType:
		return m.GetType()
	case frequency.FieldDescription:
		return m.Description()
	case frequency.FieldFrequency:
		return m.Frequency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrequencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frequency.FieldHash:
		return m.OldHash(ctx)
	case frequency.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case frequency.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case frequency.FieldType:
		return m.OldType(ctx)
	case frequency.FieldDescription:
		return m.OldDescription(ctx)
	case frequency.FieldFrequency:
		return m.OldFrequency(ctx)
	}
	return nil, fmt.Errorf("unknown Frequency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrequencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frequency.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case frequency.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case frequency.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case frequency.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case frequency.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case frequency.FieldFrequency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	}
	return fmt.Errorf("unknown Frequency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrequencyMutation) AddedFields() []string {
	var fields []string
	if m.addfrequency != nil {
		fields = append(fields, frequency.FieldFrequency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrequencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frequency.FieldFrequency:
		return m.AddedFrequency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrequencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frequency.FieldFrequency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrequency(v)
		return nil
	}
	return fmt.Errorf("unknown Frequency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrequencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrequencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrequencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Frequency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrequencyMutation) ResetField(name string) error {
	switch name {
	case frequency.FieldHash:
		m.ResetHash()
		return nil
	case frequency.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case frequency.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case frequency.FieldType:
		m.ResetType()
		return nil
	case frequency.FieldDescription:
		m.ResetDescription()
		return nil
	case frequency.FieldFrequency:
		m.ResetFrequency()
		return nil
	}
	return fmt.Errorf("unknown Frequency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrequencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.airport != nil {
		edges = append(edges, frequency.EdgeAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrequencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frequency.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrequencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrequencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrequencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedairport {
		edges = append(edges, frequency.EdgeAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrequencyMutation) EdgeCleared(name string) bool {
	switch name {
	case frequency.EdgeAirport:
		return m.clearedairport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrequencyMutation) ClearEdge(name string) error {
	switch name {
	case frequency.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown Frequency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrequencyMutation) ResetEdge(name string) error {
	switch name {
	case frequency.EdgeAirport:
		m.ResetAirport()
		return nil
	}
	return fmt.Errorf("unknown Frequency edge %s", name)
}

// MetarMutation represents an operation that mutates the Metar nodes in the graph.
type MetarMutation struct {
	config
	op                                         Op
	typ                                        string
	id                                         *int
	raw_text                                   *string
	observation_time                           *time.Time
	latitude                                   *float64
	addlatitude                                *float64
	longitude                                  *float64
	addlongitude                               *float64
	elevation                                  *float64
	addelevation                               *float64
	temperature                                *float64
	addtemperature                             *float64
	dewpoint                                   *float64
	adddewpoint                                *float64
	wind_speed                                 *int
	addwind_speed                              *int
	wind_gust                                  *int
	addwind_gust                               *int
	wind_direction                             *int
	addwind_direction                          *int
	visibility                                 *float64
	addvisibility                              *float64
	altimeter                                  *float64
	addaltimeter                               *float64
	present_weather                            *string
	flight_category                            *metar.FlightCategory
	quality_control_corrected                  *bool
	quality_control_auto_station               *bool
	quality_control_maintenance_indicator_on   *bool
	quality_control_no_signal                  *bool
	quality_control_lightning_sensor_off       *bool
	quality_control_freezing_rain_sensor_off   *bool
	quality_control_present_weather_sensor_off *bool
	sea_level_pressure                         *float64
	addsea_level_pressure                      *float64
	pressure_tendency                          *float64
	addpressure_tendency                       *float64
	max_temp_6                                 *float64
	addmax_temp_6                              *float64
	min_temp_6                                 *float64
	addmin_temp_6                              *float64
	max_temp_24                                *float64
	addmax_temp_24                             *float64
	min_temp_24                                *float64
	addmin_temp_24                             *float64
	precipitation                              *float64
	addprecipitation                           *float64
	precipitation_3                            *float64
	addprecipitation_3                         *float64
	precipitation_6                            *float64
	addprecipitation_6                         *float64
	precipitation_24                           *float64
	addprecipitation_24                        *float64
	snow_depth                                 *float64
	addsnow_depth                              *float64
	vert_vis                                   *float64
	addvert_vis                                *float64
	metar_type                                 *metar.MetarType
	hash                                       *string
	clearedFields                              map[string]struct{}
	airport                                    *int
	clearedairport                             bool
	sky_conditions                             map[int]struct{}
	removedsky_conditions                      map[int]struct{}
	clearedsky_conditions                      bool
	done                                       bool
	oldValue                                   func(context.Context) (*Metar, error)
	predicates                                 []predicate.Metar
}

var _ ent.Mutation = (*MetarMutation)(nil)

// metarOption allows management of the mutation configuration using functional options.
type metarOption func(*MetarMutation)

// newMetarMutation creates new mutation for the Metar entity.
func newMetarMutation(c config, op Op, opts ...metarOption) *MetarMutation {
	m := &MetarMutation{
		config:        c,
		op:            op,
		typ:           TypeMetar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetarID sets the ID field of the mutation.
func withMetarID(id int) metarOption {
	return func(m *MetarMutation) {
		var (
			err   error
			once  sync.Once
			value *Metar
		)
		m.oldValue = func(ctx context.Context) (*Metar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetar sets the old Metar of the mutation.
func withMetar(node *Metar) metarOption {
	return func(m *MetarMutation) {
		m.oldValue = func(context.Context) (*Metar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metar entities.
func (m *MetarMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRawText sets the "raw_text" field.
func (m *MetarMutation) SetRawText(s string) {
	m.raw_text = &s
}

// RawText returns the value of the "raw_text" field in the mutation.
func (m *MetarMutation) RawText() (r string, exists bool) {
	v := m.raw_text
	if v == nil {
		return
	}
	return *v, true
}

// OldRawText returns the old "raw_text" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldRawText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawText: %w", err)
	}
	return oldValue.RawText, nil
}

// ResetRawText resets all changes to the "raw_text" field.
func (m *MetarMutation) ResetRawText() {
	m.raw_text = nil
}

// SetObservationTime sets the "observation_time" field.
func (m *MetarMutation) SetObservationTime(t time.Time) {
	m.observation_time = &t
}

// ObservationTime returns the value of the "observation_time" field in the mutation.
func (m *MetarMutation) ObservationTime() (r time.Time, exists bool) {
	v := m.observation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldObservationTime returns the old "observation_time" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldObservationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObservationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObservationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObservationTime: %w", err)
	}
	return oldValue.ObservationTime, nil
}

// ResetObservationTime resets all changes to the "observation_time" field.
func (m *MetarMutation) ResetObservationTime() {
	m.observation_time = nil
}

// SetLatitude sets the "latitude" field.
func (m *MetarMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *MetarMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *MetarMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *MetarMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *MetarMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[metar.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *MetarMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[metar.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *MetarMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, metar.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *MetarMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *MetarMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *MetarMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *MetarMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *MetarMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[metar.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *MetarMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[metar.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *MetarMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, metar.FieldLongitude)
}

// SetElevation sets the "elevation" field.
func (m *MetarMutation) SetElevation(f float64) {
	m.elevation = &f
	m.addelevation = nil
}

// Elevation returns the value of the "elevation" field in the mutation.
func (m *MetarMutation) Elevation() (r float64, exists bool) {
	v := m.elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldElevation returns the old "elevation" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldElevation(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElevation: %w", err)
	}
	return oldValue.Elevation, nil
}

// AddElevation adds f to the "elevation" field.
func (m *MetarMutation) AddElevation(f float64) {
	if m.addelevation != nil {
		*m.addelevation += f
	} else {
		m.addelevation = &f
	}
}

// AddedElevation returns the value that was added to the "elevation" field in this mutation.
func (m *MetarMutation) AddedElevation() (r float64, exists bool) {
	v := m.addelevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearElevation clears the value of the "elevation" field.
func (m *MetarMutation) ClearElevation() {
	m.elevation = nil
	m.addelevation = nil
	m.clearedFields[metar.FieldElevation] = struct{}{}
}

// ElevationCleared returns if the "elevation" field was cleared in this mutation.
func (m *MetarMutation) ElevationCleared() bool {
	_, ok := m.clearedFields[metar.FieldElevation]
	return ok
}

// ResetElevation resets all changes to the "elevation" field.
func (m *MetarMutation) ResetElevation() {
	m.elevation = nil
	m.addelevation = nil
	delete(m.clearedFields, metar.FieldElevation)
}

// SetTemperature sets the "temperature" field.
func (m *MetarMutation) SetTemperature(f float64) {
	m.temperature = &f
	m.addtemperature = nil
}

// Temperature returns the value of the "temperature" field in the mutation.
func (m *MetarMutation) Temperature() (r float64, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old "temperature" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldTemperature(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds f to the "temperature" field.
func (m *MetarMutation) AddTemperature(f float64) {
	if m.addtemperature != nil {
		*m.addtemperature += f
	} else {
		m.addtemperature = &f
	}
}

// AddedTemperature returns the value that was added to the "temperature" field in this mutation.
func (m *MetarMutation) AddedTemperature() (r float64, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemperature resets all changes to the "temperature" field.
func (m *MetarMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
}

// SetDewpoint sets the "dewpoint" field.
func (m *MetarMutation) SetDewpoint(f float64) {
	m.dewpoint = &f
	m.adddewpoint = nil
}

// Dewpoint returns the value of the "dewpoint" field in the mutation.
func (m *MetarMutation) Dewpoint() (r float64, exists bool) {
	v := m.dewpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldDewpoint returns the old "dewpoint" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldDewpoint(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDewpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDewpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDewpoint: %w", err)
	}
	return oldValue.Dewpoint, nil
}

// AddDewpoint adds f to the "dewpoint" field.
func (m *MetarMutation) AddDewpoint(f float64) {
	if m.adddewpoint != nil {
		*m.adddewpoint += f
	} else {
		m.adddewpoint = &f
	}
}

// AddedDewpoint returns the value that was added to the "dewpoint" field in this mutation.
func (m *MetarMutation) AddedDewpoint() (r float64, exists bool) {
	v := m.adddewpoint
	if v == nil {
		return
	}
	return *v, true
}

// ResetDewpoint resets all changes to the "dewpoint" field.
func (m *MetarMutation) ResetDewpoint() {
	m.dewpoint = nil
	m.adddewpoint = nil
}

// SetWindSpeed sets the "wind_speed" field.
func (m *MetarMutation) SetWindSpeed(i int) {
	m.wind_speed = &i
	m.addwind_speed = nil
}

// WindSpeed returns the value of the "wind_speed" field in the mutation.
func (m *MetarMutation) WindSpeed() (r int, exists bool) {
	v := m.wind_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldWindSpeed returns the old "wind_speed" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldWindSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindSpeed: %w", err)
	}
	return oldValue.WindSpeed, nil
}

// AddWindSpeed adds i to the "wind_speed" field.
func (m *MetarMutation) AddWindSpeed(i int) {
	if m.addwind_speed != nil {
		*m.addwind_speed += i
	} else {
		m.addwind_speed = &i
	}
}

// AddedWindSpeed returns the value that was added to the "wind_speed" field in this mutation.
func (m *MetarMutation) AddedWindSpeed() (r int, exists bool) {
	v := m.addwind_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetWindSpeed resets all changes to the "wind_speed" field.
func (m *MetarMutation) ResetWindSpeed() {
	m.wind_speed = nil
	m.addwind_speed = nil
}

// SetWindGust sets the "wind_gust" field.
func (m *MetarMutation) SetWindGust(i int) {
	m.wind_gust = &i
	m.addwind_gust = nil
}

// WindGust returns the value of the "wind_gust" field in the mutation.
func (m *MetarMutation) WindGust() (r int, exists bool) {
	v := m.wind_gust
	if v == nil {
		return
	}
	return *v, true
}

// OldWindGust returns the old "wind_gust" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldWindGust(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindGust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindGust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindGust: %w", err)
	}
	return oldValue.WindGust, nil
}

// AddWindGust adds i to the "wind_gust" field.
func (m *MetarMutation) AddWindGust(i int) {
	if m.addwind_gust != nil {
		*m.addwind_gust += i
	} else {
		m.addwind_gust = &i
	}
}

// AddedWindGust returns the value that was added to the "wind_gust" field in this mutation.
func (m *MetarMutation) AddedWindGust() (r int, exists bool) {
	v := m.addwind_gust
	if v == nil {
		return
	}
	return *v, true
}

// ResetWindGust resets all changes to the "wind_gust" field.
func (m *MetarMutation) ResetWindGust() {
	m.wind_gust = nil
	m.addwind_gust = nil
}

// SetWindDirection sets the "wind_direction" field.
func (m *MetarMutation) SetWindDirection(i int) {
	m.wind_direction = &i
	m.addwind_direction = nil
}

// WindDirection returns the value of the "wind_direction" field in the mutation.
func (m *MetarMutation) WindDirection() (r int, exists bool) {
	v := m.wind_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirection returns the old "wind_direction" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldWindDirection(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirection: %w", err)
	}
	return oldValue.WindDirection, nil
}

// AddWindDirection adds i to the "wind_direction" field.
func (m *MetarMutation) AddWindDirection(i int) {
	if m.addwind_direction != nil {
		*m.addwind_direction += i
	} else {
		m.addwind_direction = &i
	}
}

// AddedWindDirection returns the value that was added to the "wind_direction" field in this mutation.
func (m *MetarMutation) AddedWindDirection() (r int, exists bool) {
	v := m.addwind_direction
	if v == nil {
		return
	}
	return *v, true
}

// ResetWindDirection resets all changes to the "wind_direction" field.
func (m *MetarMutation) ResetWindDirection() {
	m.wind_direction = nil
	m.addwind_direction = nil
}

// SetVisibility sets the "visibility" field.
func (m *MetarMutation) SetVisibility(f float64) {
	m.visibility = &f
	m.addvisibility = nil
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *MetarMutation) Visibility() (r float64, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldVisibility(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// AddVisibility adds f to the "visibility" field.
func (m *MetarMutation) AddVisibility(f float64) {
	if m.addvisibility != nil {
		*m.addvisibility += f
	} else {
		m.addvisibility = &f
	}
}

// AddedVisibility returns the value that was added to the "visibility" field in this mutation.
func (m *MetarMutation) AddedVisibility() (r float64, exists bool) {
	v := m.addvisibility
	if v == nil {
		return
	}
	return *v, true
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *MetarMutation) ResetVisibility() {
	m.visibility = nil
	m.addvisibility = nil
}

// SetAltimeter sets the "altimeter" field.
func (m *MetarMutation) SetAltimeter(f float64) {
	m.altimeter = &f
	m.addaltimeter = nil
}

// Altimeter returns the value of the "altimeter" field in the mutation.
func (m *MetarMutation) Altimeter() (r float64, exists bool) {
	v := m.altimeter
	if v == nil {
		return
	}
	return *v, true
}

// OldAltimeter returns the old "altimeter" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldAltimeter(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltimeter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltimeter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltimeter: %w", err)
	}
	return oldValue.Altimeter, nil
}

// AddAltimeter adds f to the "altimeter" field.
func (m *MetarMutation) AddAltimeter(f float64) {
	if m.addaltimeter != nil {
		*m.addaltimeter += f
	} else {
		m.addaltimeter = &f
	}
}

// AddedAltimeter returns the value that was added to the "altimeter" field in this mutation.
func (m *MetarMutation) AddedAltimeter() (r float64, exists bool) {
	v := m.addaltimeter
	if v == nil {
		return
	}
	return *v, true
}

// ResetAltimeter resets all changes to the "altimeter" field.
func (m *MetarMutation) ResetAltimeter() {
	m.altimeter = nil
	m.addaltimeter = nil
}

// SetPresentWeather sets the "present_weather" field.
func (m *MetarMutation) SetPresentWeather(s string) {
	m.present_weather = &s
}

// PresentWeather returns the value of the "present_weather" field in the mutation.
func (m *MetarMutation) PresentWeather() (r string, exists bool) {
	v := m.present_weather
	if v == nil {
		return
	}
	return *v, true
}

// OldPresentWeather returns the old "present_weather" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPresentWeather(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresentWeather is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresentWeather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresentWeather: %w", err)
	}
	return oldValue.PresentWeather, nil
}

// ClearPresentWeather clears the value of the "present_weather" field.
func (m *MetarMutation) ClearPresentWeather() {
	m.present_weather = nil
	m.clearedFields[metar.FieldPresentWeather] = struct{}{}
}

// PresentWeatherCleared returns if the "present_weather" field was cleared in this mutation.
func (m *MetarMutation) PresentWeatherCleared() bool {
	_, ok := m.clearedFields[metar.FieldPresentWeather]
	return ok
}

// ResetPresentWeather resets all changes to the "present_weather" field.
func (m *MetarMutation) ResetPresentWeather() {
	m.present_weather = nil
	delete(m.clearedFields, metar.FieldPresentWeather)
}

// SetFlightCategory sets the "flight_category" field.
func (m *MetarMutation) SetFlightCategory(mc metar.FlightCategory) {
	m.flight_category = &mc
}

// FlightCategory returns the value of the "flight_category" field in the mutation.
func (m *MetarMutation) FlightCategory() (r metar.FlightCategory, exists bool) {
	v := m.flight_category
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightCategory returns the old "flight_category" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldFlightCategory(ctx context.Context) (v *metar.FlightCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightCategory: %w", err)
	}
	return oldValue.FlightCategory, nil
}

// ClearFlightCategory clears the value of the "flight_category" field.
func (m *MetarMutation) ClearFlightCategory() {
	m.flight_category = nil
	m.clearedFields[metar.FieldFlightCategory] = struct{}{}
}

// FlightCategoryCleared returns if the "flight_category" field was cleared in this mutation.
func (m *MetarMutation) FlightCategoryCleared() bool {
	_, ok := m.clearedFields[metar.FieldFlightCategory]
	return ok
}

// ResetFlightCategory resets all changes to the "flight_category" field.
func (m *MetarMutation) ResetFlightCategory() {
	m.flight_category = nil
	delete(m.clearedFields, metar.FieldFlightCategory)
}

// SetQualityControlCorrected sets the "quality_control_corrected" field.
func (m *MetarMutation) SetQualityControlCorrected(b bool) {
	m.quality_control_corrected = &b
}

// QualityControlCorrected returns the value of the "quality_control_corrected" field in the mutation.
func (m *MetarMutation) QualityControlCorrected() (r bool, exists bool) {
	v := m.quality_control_corrected
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlCorrected returns the old "quality_control_corrected" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlCorrected(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlCorrected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlCorrected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlCorrected: %w", err)
	}
	return oldValue.QualityControlCorrected, nil
}

// ClearQualityControlCorrected clears the value of the "quality_control_corrected" field.
func (m *MetarMutation) ClearQualityControlCorrected() {
	m.quality_control_corrected = nil
	m.clearedFields[metar.FieldQualityControlCorrected] = struct{}{}
}

// QualityControlCorrectedCleared returns if the "quality_control_corrected" field was cleared in this mutation.
func (m *MetarMutation) QualityControlCorrectedCleared() bool {
	_, ok := m.clearedFields[metar.FieldQualityControlCorrected]
	return ok
}

// ResetQualityControlCorrected resets all changes to the "quality_control_corrected" field.
func (m *MetarMutation) ResetQualityControlCorrected() {
	m.quality_control_corrected = nil
	delete(m.clearedFields, metar.FieldQualityControlCorrected)
}

// SetQualityControlAutoStation sets the "quality_control_auto_station" field.
func (m *MetarMutation) SetQualityControlAutoStation(b bool) {
	m.quality_control_auto_station = &b
}

// QualityControlAutoStation returns the value of the "quality_control_auto_station" field in the mutation.
func (m *MetarMutation) QualityControlAutoStation() (r bool, exists bool) {
	v := m.quality_control_auto_station
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlAutoStation returns the old "quality_control_auto_station" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlAutoStation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlAutoStation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlAutoStation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlAutoStation: %w", err)
	}
	return oldValue.QualityControlAutoStation, nil
}

// ResetQualityControlAutoStation resets all changes to the "quality_control_auto_station" field.
func (m *MetarMutation) ResetQualityControlAutoStation() {
	m.quality_control_auto_station = nil
}

// SetQualityControlMaintenanceIndicatorOn sets the "quality_control_maintenance_indicator_on" field.
func (m *MetarMutation) SetQualityControlMaintenanceIndicatorOn(b bool) {
	m.quality_control_maintenance_indicator_on = &b
}

// QualityControlMaintenanceIndicatorOn returns the value of the "quality_control_maintenance_indicator_on" field in the mutation.
func (m *MetarMutation) QualityControlMaintenanceIndicatorOn() (r bool, exists bool) {
	v := m.quality_control_maintenance_indicator_on
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlMaintenanceIndicatorOn returns the old "quality_control_maintenance_indicator_on" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlMaintenanceIndicatorOn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlMaintenanceIndicatorOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlMaintenanceIndicatorOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlMaintenanceIndicatorOn: %w", err)
	}
	return oldValue.QualityControlMaintenanceIndicatorOn, nil
}

// ResetQualityControlMaintenanceIndicatorOn resets all changes to the "quality_control_maintenance_indicator_on" field.
func (m *MetarMutation) ResetQualityControlMaintenanceIndicatorOn() {
	m.quality_control_maintenance_indicator_on = nil
}

// SetQualityControlNoSignal sets the "quality_control_no_signal" field.
func (m *MetarMutation) SetQualityControlNoSignal(b bool) {
	m.quality_control_no_signal = &b
}

// QualityControlNoSignal returns the value of the "quality_control_no_signal" field in the mutation.
func (m *MetarMutation) QualityControlNoSignal() (r bool, exists bool) {
	v := m.quality_control_no_signal
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlNoSignal returns the old "quality_control_no_signal" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlNoSignal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlNoSignal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlNoSignal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlNoSignal: %w", err)
	}
	return oldValue.QualityControlNoSignal, nil
}

// ResetQualityControlNoSignal resets all changes to the "quality_control_no_signal" field.
func (m *MetarMutation) ResetQualityControlNoSignal() {
	m.quality_control_no_signal = nil
}

// SetQualityControlLightningSensorOff sets the "quality_control_lightning_sensor_off" field.
func (m *MetarMutation) SetQualityControlLightningSensorOff(b bool) {
	m.quality_control_lightning_sensor_off = &b
}

// QualityControlLightningSensorOff returns the value of the "quality_control_lightning_sensor_off" field in the mutation.
func (m *MetarMutation) QualityControlLightningSensorOff() (r bool, exists bool) {
	v := m.quality_control_lightning_sensor_off
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlLightningSensorOff returns the old "quality_control_lightning_sensor_off" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlLightningSensorOff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlLightningSensorOff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlLightningSensorOff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlLightningSensorOff: %w", err)
	}
	return oldValue.QualityControlLightningSensorOff, nil
}

// ResetQualityControlLightningSensorOff resets all changes to the "quality_control_lightning_sensor_off" field.
func (m *MetarMutation) ResetQualityControlLightningSensorOff() {
	m.quality_control_lightning_sensor_off = nil
}

// SetQualityControlFreezingRainSensorOff sets the "quality_control_freezing_rain_sensor_off" field.
func (m *MetarMutation) SetQualityControlFreezingRainSensorOff(b bool) {
	m.quality_control_freezing_rain_sensor_off = &b
}

// QualityControlFreezingRainSensorOff returns the value of the "quality_control_freezing_rain_sensor_off" field in the mutation.
func (m *MetarMutation) QualityControlFreezingRainSensorOff() (r bool, exists bool) {
	v := m.quality_control_freezing_rain_sensor_off
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlFreezingRainSensorOff returns the old "quality_control_freezing_rain_sensor_off" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlFreezingRainSensorOff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlFreezingRainSensorOff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlFreezingRainSensorOff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlFreezingRainSensorOff: %w", err)
	}
	return oldValue.QualityControlFreezingRainSensorOff, nil
}

// ResetQualityControlFreezingRainSensorOff resets all changes to the "quality_control_freezing_rain_sensor_off" field.
func (m *MetarMutation) ResetQualityControlFreezingRainSensorOff() {
	m.quality_control_freezing_rain_sensor_off = nil
}

// SetQualityControlPresentWeatherSensorOff sets the "quality_control_present_weather_sensor_off" field.
func (m *MetarMutation) SetQualityControlPresentWeatherSensorOff(b bool) {
	m.quality_control_present_weather_sensor_off = &b
}

// QualityControlPresentWeatherSensorOff returns the value of the "quality_control_present_weather_sensor_off" field in the mutation.
func (m *MetarMutation) QualityControlPresentWeatherSensorOff() (r bool, exists bool) {
	v := m.quality_control_present_weather_sensor_off
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlPresentWeatherSensorOff returns the old "quality_control_present_weather_sensor_off" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlPresentWeatherSensorOff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlPresentWeatherSensorOff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlPresentWeatherSensorOff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlPresentWeatherSensorOff: %w", err)
	}
	return oldValue.QualityControlPresentWeatherSensorOff, nil
}

// ResetQualityControlPresentWeatherSensorOff resets all changes to the "quality_control_present_weather_sensor_off" field.
func (m *MetarMutation) ResetQualityControlPresentWeatherSensorOff() {
	m.quality_control_present_weather_sensor_off = nil
}

// SetSeaLevelPressure sets the "sea_level_pressure" field.
func (m *MetarMutation) SetSeaLevelPressure(f float64) {
	m.sea_level_pressure = &f
	m.addsea_level_pressure = nil
}

// SeaLevelPressure returns the value of the "sea_level_pressure" field in the mutation.
func (m *MetarMutation) SeaLevelPressure() (r float64, exists bool) {
	v := m.sea_level_pressure
	if v == nil {
		return
	}
	return *v, true
}

// OldSeaLevelPressure returns the old "sea_level_pressure" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldSeaLevelPressure(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeaLevelPressure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeaLevelPressure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeaLevelPressure: %w", err)
	}
	return oldValue.SeaLevelPressure, nil
}

// AddSeaLevelPressure adds f to the "sea_level_pressure" field.
func (m *MetarMutation) AddSeaLevelPressure(f float64) {
	if m.addsea_level_pressure != nil {
		*m.addsea_level_pressure += f
	} else {
		m.addsea_level_pressure = &f
	}
}

// AddedSeaLevelPressure returns the value that was added to the "sea_level_pressure" field in this mutation.
func (m *MetarMutation) AddedSeaLevelPressure() (r float64, exists bool) {
	v := m.addsea_level_pressure
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeaLevelPressure clears the value of the "sea_level_pressure" field.
func (m *MetarMutation) ClearSeaLevelPressure() {
	m.sea_level_pressure = nil
	m.addsea_level_pressure = nil
	m.clearedFields[metar.FieldSeaLevelPressure] = struct{}{}
}

// SeaLevelPressureCleared returns if the "sea_level_pressure" field was cleared in this mutation.
func (m *MetarMutation) SeaLevelPressureCleared() bool {
	_, ok := m.clearedFields[metar.FieldSeaLevelPressure]
	return ok
}

// ResetSeaLevelPressure resets all changes to the "sea_level_pressure" field.
func (m *MetarMutation) ResetSeaLevelPressure() {
	m.sea_level_pressure = nil
	m.addsea_level_pressure = nil
	delete(m.clearedFields, metar.FieldSeaLevelPressure)
}

// SetPressureTendency sets the "pressure_tendency" field.
func (m *MetarMutation) SetPressureTendency(f float64) {
	m.pressure_tendency = &f
	m.addpressure_tendency = nil
}

// PressureTendency returns the value of the "pressure_tendency" field in the mutation.
func (m *MetarMutation) PressureTendency() (r float64, exists bool) {
	v := m.pressure_tendency
	if v == nil {
		return
	}
	return *v, true
}

// OldPressureTendency returns the old "pressure_tendency" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPressureTendency(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPressureTendency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPressureTendency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPressureTendency: %w", err)
	}
	return oldValue.PressureTendency, nil
}

// AddPressureTendency adds f to the "pressure_tendency" field.
func (m *MetarMutation) AddPressureTendency(f float64) {
	if m.addpressure_tendency != nil {
		*m.addpressure_tendency += f
	} else {
		m.addpressure_tendency = &f
	}
}

// AddedPressureTendency returns the value that was added to the "pressure_tendency" field in this mutation.
func (m *MetarMutation) AddedPressureTendency() (r float64, exists bool) {
	v := m.addpressure_tendency
	if v == nil {
		return
	}
	return *v, true
}

// ClearPressureTendency clears the value of the "pressure_tendency" field.
func (m *MetarMutation) ClearPressureTendency() {
	m.pressure_tendency = nil
	m.addpressure_tendency = nil
	m.clearedFields[metar.FieldPressureTendency] = struct{}{}
}

// PressureTendencyCleared returns if the "pressure_tendency" field was cleared in this mutation.
func (m *MetarMutation) PressureTendencyCleared() bool {
	_, ok := m.clearedFields[metar.FieldPressureTendency]
	return ok
}

// ResetPressureTendency resets all changes to the "pressure_tendency" field.
func (m *MetarMutation) ResetPressureTendency() {
	m.pressure_tendency = nil
	m.addpressure_tendency = nil
	delete(m.clearedFields, metar.FieldPressureTendency)
}

// SetMaxTemp6 sets the "max_temp_6" field.
func (m *MetarMutation) SetMaxTemp6(f float64) {
	m.max_temp_6 = &f
	m.addmax_temp_6 = nil
}

// MaxTemp6 returns the value of the "max_temp_6" field in the mutation.
func (m *MetarMutation) MaxTemp6() (r float64, exists bool) {
	v := m.max_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemp6 returns the old "max_temp_6" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMaxTemp6(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemp6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemp6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemp6: %w", err)
	}
	return oldValue.MaxTemp6, nil
}

// AddMaxTemp6 adds f to the "max_temp_6" field.
func (m *MetarMutation) AddMaxTemp6(f float64) {
	if m.addmax_temp_6 != nil {
		*m.addmax_temp_6 += f
	} else {
		m.addmax_temp_6 = &f
	}
}

// AddedMaxTemp6 returns the value that was added to the "max_temp_6" field in this mutation.
func (m *MetarMutation) AddedMaxTemp6() (r float64, exists bool) {
	v := m.addmax_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTemp6 clears the value of the "max_temp_6" field.
func (m *MetarMutation) ClearMaxTemp6() {
	m.max_temp_6 = nil
	m.addmax_temp_6 = nil
	m.clearedFields[metar.FieldMaxTemp6] = struct{}{}
}

// MaxTemp6Cleared returns if the "max_temp_6" field was cleared in this mutation.
func (m *MetarMutation) MaxTemp6Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMaxTemp6]
	return ok
}

// ResetMaxTemp6 resets all changes to the "max_temp_6" field.
func (m *MetarMutation) ResetMaxTemp6() {
	m.max_temp_6 = nil
	m.addmax_temp_6 = nil
	delete(m.clearedFields, metar.FieldMaxTemp6)
}

// SetMinTemp6 sets the "min_temp_6" field.
func (m *MetarMutation) SetMinTemp6(f float64) {
	m.min_temp_6 = &f
	m.addmin_temp_6 = nil
}

// MinTemp6 returns the value of the "min_temp_6" field in the mutation.
func (m *MetarMutation) MinTemp6() (r float64, exists bool) {
	v := m.min_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemp6 returns the old "min_temp_6" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMinTemp6(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemp6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemp6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemp6: %w", err)
	}
	return oldValue.MinTemp6, nil
}

// AddMinTemp6 adds f to the "min_temp_6" field.
func (m *MetarMutation) AddMinTemp6(f float64) {
	if m.addmin_temp_6 != nil {
		*m.addmin_temp_6 += f
	} else {
		m.addmin_temp_6 = &f
	}
}

// AddedMinTemp6 returns the value that was added to the "min_temp_6" field in this mutation.
func (m *MetarMutation) AddedMinTemp6() (r float64, exists bool) {
	v := m.addmin_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinTemp6 clears the value of the "min_temp_6" field.
func (m *MetarMutation) ClearMinTemp6() {
	m.min_temp_6 = nil
	m.addmin_temp_6 = nil
	m.clearedFields[metar.FieldMinTemp6] = struct{}{}
}

// MinTemp6Cleared returns if the "min_temp_6" field was cleared in this mutation.
func (m *MetarMutation) MinTemp6Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMinTemp6]
	return ok
}

// ResetMinTemp6 resets all changes to the "min_temp_6" field.
func (m *MetarMutation) ResetMinTemp6() {
	m.min_temp_6 = nil
	m.addmin_temp_6 = nil
	delete(m.clearedFields, metar.FieldMinTemp6)
}

// SetMaxTemp24 sets the "max_temp_24" field.
func (m *MetarMutation) SetMaxTemp24(f float64) {
	m.max_temp_24 = &f
	m.addmax_temp_24 = nil
}

// MaxTemp24 returns the value of the "max_temp_24" field in the mutation.
func (m *MetarMutation) MaxTemp24() (r float64, exists bool) {
	v := m.max_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemp24 returns the old "max_temp_24" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMaxTemp24(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemp24 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemp24 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemp24: %w", err)
	}
	return oldValue.MaxTemp24, nil
}

// AddMaxTemp24 adds f to the "max_temp_24" field.
func (m *MetarMutation) AddMaxTemp24(f float64) {
	if m.addmax_temp_24 != nil {
		*m.addmax_temp_24 += f
	} else {
		m.addmax_temp_24 = &f
	}
}

// AddedMaxTemp24 returns the value that was added to the "max_temp_24" field in this mutation.
func (m *MetarMutation) AddedMaxTemp24() (r float64, exists bool) {
	v := m.addmax_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTemp24 clears the value of the "max_temp_24" field.
func (m *MetarMutation) ClearMaxTemp24() {
	m.max_temp_24 = nil
	m.addmax_temp_24 = nil
	m.clearedFields[metar.FieldMaxTemp24] = struct{}{}
}

// MaxTemp24Cleared returns if the "max_temp_24" field was cleared in this mutation.
func (m *MetarMutation) MaxTemp24Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMaxTemp24]
	return ok
}

// ResetMaxTemp24 resets all changes to the "max_temp_24" field.
func (m *MetarMutation) ResetMaxTemp24() {
	m.max_temp_24 = nil
	m.addmax_temp_24 = nil
	delete(m.clearedFields, metar.FieldMaxTemp24)
}

// SetMinTemp24 sets the "min_temp_24" field.
func (m *MetarMutation) SetMinTemp24(f float64) {
	m.min_temp_24 = &f
	m.addmin_temp_24 = nil
}

// MinTemp24 returns the value of the "min_temp_24" field in the mutation.
func (m *MetarMutation) MinTemp24() (r float64, exists bool) {
	v := m.min_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemp24 returns the old "min_temp_24" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMinTemp24(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemp24 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemp24 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemp24: %w", err)
	}
	return oldValue.MinTemp24, nil
}

// AddMinTemp24 adds f to the "min_temp_24" field.
func (m *MetarMutation) AddMinTemp24(f float64) {
	if m.addmin_temp_24 != nil {
		*m.addmin_temp_24 += f
	} else {
		m.addmin_temp_24 = &f
	}
}

// AddedMinTemp24 returns the value that was added to the "min_temp_24" field in this mutation.
func (m *MetarMutation) AddedMinTemp24() (r float64, exists bool) {
	v := m.addmin_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinTemp24 clears the value of the "min_temp_24" field.
func (m *MetarMutation) ClearMinTemp24() {
	m.min_temp_24 = nil
	m.addmin_temp_24 = nil
	m.clearedFields[metar.FieldMinTemp24] = struct{}{}
}

// MinTemp24Cleared returns if the "min_temp_24" field was cleared in this mutation.
func (m *MetarMutation) MinTemp24Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMinTemp24]
	return ok
}

// ResetMinTemp24 resets all changes to the "min_temp_24" field.
func (m *MetarMutation) ResetMinTemp24() {
	m.min_temp_24 = nil
	m.addmin_temp_24 = nil
	delete(m.clearedFields, metar.FieldMinTemp24)
}

// SetPrecipitation sets the "precipitation" field.
func (m *MetarMutation) SetPrecipitation(f float64) {
	m.precipitation = &f
	m.addprecipitation = nil
}

// Precipitation returns the value of the "precipitation" field in the mutation.
func (m *MetarMutation) Precipitation() (r float64, exists bool) {
	v := m.precipitation
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation returns the old "precipitation" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation: %w", err)
	}
	return oldValue.Precipitation, nil
}

// AddPrecipitation adds f to the "precipitation" field.
func (m *MetarMutation) AddPrecipitation(f float64) {
	if m.addprecipitation != nil {
		*m.addprecipitation += f
	} else {
		m.addprecipitation = &f
	}
}

// AddedPrecipitation returns the value that was added to the "precipitation" field in this mutation.
func (m *MetarMutation) AddedPrecipitation() (r float64, exists bool) {
	v := m.addprecipitation
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation clears the value of the "precipitation" field.
func (m *MetarMutation) ClearPrecipitation() {
	m.precipitation = nil
	m.addprecipitation = nil
	m.clearedFields[metar.FieldPrecipitation] = struct{}{}
}

// PrecipitationCleared returns if the "precipitation" field was cleared in this mutation.
func (m *MetarMutation) PrecipitationCleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation]
	return ok
}

// ResetPrecipitation resets all changes to the "precipitation" field.
func (m *MetarMutation) ResetPrecipitation() {
	m.precipitation = nil
	m.addprecipitation = nil
	delete(m.clearedFields, metar.FieldPrecipitation)
}

// SetPrecipitation3 sets the "precipitation_3" field.
func (m *MetarMutation) SetPrecipitation3(f float64) {
	m.precipitation_3 = &f
	m.addprecipitation_3 = nil
}

// Precipitation3 returns the value of the "precipitation_3" field in the mutation.
func (m *MetarMutation) Precipitation3() (r float64, exists bool) {
	v := m.precipitation_3
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation3 returns the old "precipitation_3" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation3(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation3: %w", err)
	}
	return oldValue.Precipitation3, nil
}

// AddPrecipitation3 adds f to the "precipitation_3" field.
func (m *MetarMutation) AddPrecipitation3(f float64) {
	if m.addprecipitation_3 != nil {
		*m.addprecipitation_3 += f
	} else {
		m.addprecipitation_3 = &f
	}
}

// AddedPrecipitation3 returns the value that was added to the "precipitation_3" field in this mutation.
func (m *MetarMutation) AddedPrecipitation3() (r float64, exists bool) {
	v := m.addprecipitation_3
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation3 clears the value of the "precipitation_3" field.
func (m *MetarMutation) ClearPrecipitation3() {
	m.precipitation_3 = nil
	m.addprecipitation_3 = nil
	m.clearedFields[metar.FieldPrecipitation3] = struct{}{}
}

// Precipitation3Cleared returns if the "precipitation_3" field was cleared in this mutation.
func (m *MetarMutation) Precipitation3Cleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation3]
	return ok
}

// ResetPrecipitation3 resets all changes to the "precipitation_3" field.
func (m *MetarMutation) ResetPrecipitation3() {
	m.precipitation_3 = nil
	m.addprecipitation_3 = nil
	delete(m.clearedFields, metar.FieldPrecipitation3)
}

// SetPrecipitation6 sets the "precipitation_6" field.
func (m *MetarMutation) SetPrecipitation6(f float64) {
	m.precipitation_6 = &f
	m.addprecipitation_6 = nil
}

// Precipitation6 returns the value of the "precipitation_6" field in the mutation.
func (m *MetarMutation) Precipitation6() (r float64, exists bool) {
	v := m.precipitation_6
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation6 returns the old "precipitation_6" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation6(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation6: %w", err)
	}
	return oldValue.Precipitation6, nil
}

// AddPrecipitation6 adds f to the "precipitation_6" field.
func (m *MetarMutation) AddPrecipitation6(f float64) {
	if m.addprecipitation_6 != nil {
		*m.addprecipitation_6 += f
	} else {
		m.addprecipitation_6 = &f
	}
}

// AddedPrecipitation6 returns the value that was added to the "precipitation_6" field in this mutation.
func (m *MetarMutation) AddedPrecipitation6() (r float64, exists bool) {
	v := m.addprecipitation_6
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation6 clears the value of the "precipitation_6" field.
func (m *MetarMutation) ClearPrecipitation6() {
	m.precipitation_6 = nil
	m.addprecipitation_6 = nil
	m.clearedFields[metar.FieldPrecipitation6] = struct{}{}
}

// Precipitation6Cleared returns if the "precipitation_6" field was cleared in this mutation.
func (m *MetarMutation) Precipitation6Cleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation6]
	return ok
}

// ResetPrecipitation6 resets all changes to the "precipitation_6" field.
func (m *MetarMutation) ResetPrecipitation6() {
	m.precipitation_6 = nil
	m.addprecipitation_6 = nil
	delete(m.clearedFields, metar.FieldPrecipitation6)
}

// SetPrecipitation24 sets the "precipitation_24" field.
func (m *MetarMutation) SetPrecipitation24(f float64) {
	m.precipitation_24 = &f
	m.addprecipitation_24 = nil
}

// Precipitation24 returns the value of the "precipitation_24" field in the mutation.
func (m *MetarMutation) Precipitation24() (r float64, exists bool) {
	v := m.precipitation_24
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation24 returns the old "precipitation_24" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation24(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation24 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation24 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation24: %w", err)
	}
	return oldValue.Precipitation24, nil
}

// AddPrecipitation24 adds f to the "precipitation_24" field.
func (m *MetarMutation) AddPrecipitation24(f float64) {
	if m.addprecipitation_24 != nil {
		*m.addprecipitation_24 += f
	} else {
		m.addprecipitation_24 = &f
	}
}

// AddedPrecipitation24 returns the value that was added to the "precipitation_24" field in this mutation.
func (m *MetarMutation) AddedPrecipitation24() (r float64, exists bool) {
	v := m.addprecipitation_24
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation24 clears the value of the "precipitation_24" field.
func (m *MetarMutation) ClearPrecipitation24() {
	m.precipitation_24 = nil
	m.addprecipitation_24 = nil
	m.clearedFields[metar.FieldPrecipitation24] = struct{}{}
}

// Precipitation24Cleared returns if the "precipitation_24" field was cleared in this mutation.
func (m *MetarMutation) Precipitation24Cleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation24]
	return ok
}

// ResetPrecipitation24 resets all changes to the "precipitation_24" field.
func (m *MetarMutation) ResetPrecipitation24() {
	m.precipitation_24 = nil
	m.addprecipitation_24 = nil
	delete(m.clearedFields, metar.FieldPrecipitation24)
}

// SetSnowDepth sets the "snow_depth" field.
func (m *MetarMutation) SetSnowDepth(f float64) {
	m.snow_depth = &f
	m.addsnow_depth = nil
}

// SnowDepth returns the value of the "snow_depth" field in the mutation.
func (m *MetarMutation) SnowDepth() (r float64, exists bool) {
	v := m.snow_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldSnowDepth returns the old "snow_depth" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldSnowDepth(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnowDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnowDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnowDepth: %w", err)
	}
	return oldValue.SnowDepth, nil
}

// AddSnowDepth adds f to the "snow_depth" field.
func (m *MetarMutation) AddSnowDepth(f float64) {
	if m.addsnow_depth != nil {
		*m.addsnow_depth += f
	} else {
		m.addsnow_depth = &f
	}
}

// AddedSnowDepth returns the value that was added to the "snow_depth" field in this mutation.
func (m *MetarMutation) AddedSnowDepth() (r float64, exists bool) {
	v := m.addsnow_depth
	if v == nil {
		return
	}
	return *v, true
}

// ClearSnowDepth clears the value of the "snow_depth" field.
func (m *MetarMutation) ClearSnowDepth() {
	m.snow_depth = nil
	m.addsnow_depth = nil
	m.clearedFields[metar.FieldSnowDepth] = struct{}{}
}

// SnowDepthCleared returns if the "snow_depth" field was cleared in this mutation.
func (m *MetarMutation) SnowDepthCleared() bool {
	_, ok := m.clearedFields[metar.FieldSnowDepth]
	return ok
}

// ResetSnowDepth resets all changes to the "snow_depth" field.
func (m *MetarMutation) ResetSnowDepth() {
	m.snow_depth = nil
	m.addsnow_depth = nil
	delete(m.clearedFields, metar.FieldSnowDepth)
}

// SetVertVis sets the "vert_vis" field.
func (m *MetarMutation) SetVertVis(f float64) {
	m.vert_vis = &f
	m.addvert_vis = nil
}

// VertVis returns the value of the "vert_vis" field in the mutation.
func (m *MetarMutation) VertVis() (r float64, exists bool) {
	v := m.vert_vis
	if v == nil {
		return
	}
	return *v, true
}

// OldVertVis returns the old "vert_vis" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldVertVis(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVertVis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVertVis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVertVis: %w", err)
	}
	return oldValue.VertVis, nil
}

// AddVertVis adds f to the "vert_vis" field.
func (m *MetarMutation) AddVertVis(f float64) {
	if m.addvert_vis != nil {
		*m.addvert_vis += f
	} else {
		m.addvert_vis = &f
	}
}

// AddedVertVis returns the value that was added to the "vert_vis" field in this mutation.
func (m *MetarMutation) AddedVertVis() (r float64, exists bool) {
	v := m.addvert_vis
	if v == nil {
		return
	}
	return *v, true
}

// ClearVertVis clears the value of the "vert_vis" field.
func (m *MetarMutation) ClearVertVis() {
	m.vert_vis = nil
	m.addvert_vis = nil
	m.clearedFields[metar.FieldVertVis] = struct{}{}
}

// VertVisCleared returns if the "vert_vis" field was cleared in this mutation.
func (m *MetarMutation) VertVisCleared() bool {
	_, ok := m.clearedFields[metar.FieldVertVis]
	return ok
}

// ResetVertVis resets all changes to the "vert_vis" field.
func (m *MetarMutation) ResetVertVis() {
	m.vert_vis = nil
	m.addvert_vis = nil
	delete(m.clearedFields, metar.FieldVertVis)
}

// SetMetarType sets the "metar_type" field.
func (m *MetarMutation) SetMetarType(mt metar.MetarType) {
	m.metar_type = &mt
}

// MetarType returns the value of the "metar_type" field in the mutation.
func (m *MetarMutation) MetarType() (r metar.MetarType, exists bool) {
	v := m.metar_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMetarType returns the old "metar_type" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMetarType(ctx context.Context) (v metar.MetarType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetarType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetarType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetarType: %w", err)
	}
	return oldValue.MetarType, nil
}

// ResetMetarType resets all changes to the "metar_type" field.
func (m *MetarMutation) ResetMetarType() {
	m.metar_type = nil
}

// SetHash sets the "hash" field.
func (m *MetarMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *MetarMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *MetarMutation) ResetHash() {
	m.hash = nil
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *MetarMutation) SetAirportID(id int) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *MetarMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *MetarMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *MetarMutation) AirportID() (id int, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *MetarMutation) AirportIDs() (ids []int) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *MetarMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// AddSkyConditionIDs adds the "sky_conditions" edge to the SkyCondition entity by ids.
func (m *MetarMutation) AddSkyConditionIDs(ids ...int) {
	if m.sky_conditions == nil {
		m.sky_conditions = make(map[int]struct{})
	}
	for i := range ids {
		m.sky_conditions[ids[i]] = struct{}{}
	}
}

// ClearSkyConditions clears the "sky_conditions" edge to the SkyCondition entity.
func (m *MetarMutation) ClearSkyConditions() {
	m.clearedsky_conditions = true
}

// SkyConditionsCleared reports if the "sky_conditions" edge to the SkyCondition entity was cleared.
func (m *MetarMutation) SkyConditionsCleared() bool {
	return m.clearedsky_conditions
}

// RemoveSkyConditionIDs removes the "sky_conditions" edge to the SkyCondition entity by IDs.
func (m *MetarMutation) RemoveSkyConditionIDs(ids ...int) {
	if m.removedsky_conditions == nil {
		m.removedsky_conditions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sky_conditions, ids[i])
		m.removedsky_conditions[ids[i]] = struct{}{}
	}
}

// RemovedSkyConditions returns the removed IDs of the "sky_conditions" edge to the SkyCondition entity.
func (m *MetarMutation) RemovedSkyConditionsIDs() (ids []int) {
	for id := range m.removedsky_conditions {
		ids = append(ids, id)
	}
	return
}

// SkyConditionsIDs returns the "sky_conditions" edge IDs in the mutation.
func (m *MetarMutation) SkyConditionsIDs() (ids []int) {
	for id := range m.sky_conditions {
		ids = append(ids, id)
	}
	return
}

// ResetSkyConditions resets all changes to the "sky_conditions" edge.
func (m *MetarMutation) ResetSkyConditions() {
	m.sky_conditions = nil
	m.clearedsky_conditions = false
	m.removedsky_conditions = nil
}

// Where appends a list predicates to the MetarMutation builder.
func (m *MetarMutation) Where(ps ...predicate.Metar) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetarMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Metar).
func (m *MetarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetarMutation) Fields() []string {
	fields := make([]string, 0, 35)
	if m.raw_text != nil {
		fields = append(fields, metar.FieldRawText)
	}
	if m.observation_time != nil {
		fields = append(fields, metar.FieldObservationTime)
	}
	if m.latitude != nil {
		fields = append(fields, metar.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, metar.FieldLongitude)
	}
	if m.elevation != nil {
		fields = append(fields, metar.FieldElevation)
	}
	if m.temperature != nil {
		fields = append(fields, metar.FieldTemperature)
	}
	if m.dewpoint != nil {
		fields = append(fields, metar.FieldDewpoint)
	}
	if m.wind_speed != nil {
		fields = append(fields, metar.FieldWindSpeed)
	}
	if m.wind_gust != nil {
		fields = append(fields, metar.FieldWindGust)
	}
	if m.wind_direction != nil {
		fields = append(fields, metar.FieldWindDirection)
	}
	if m.visibility != nil {
		fields = append(fields, metar.FieldVisibility)
	}
	if m.altimeter != nil {
		fields = append(fields, metar.FieldAltimeter)
	}
	if m.present_weather != nil {
		fields = append(fields, metar.FieldPresentWeather)
	}
	if m.flight_category != nil {
		fields = append(fields, metar.FieldFlightCategory)
	}
	if m.quality_control_corrected != nil {
		fields = append(fields, metar.FieldQualityControlCorrected)
	}
	if m.quality_control_auto_station != nil {
		fields = append(fields, metar.FieldQualityControlAutoStation)
	}
	if m.quality_control_maintenance_indicator_on != nil {
		fields = append(fields, metar.FieldQualityControlMaintenanceIndicatorOn)
	}
	if m.quality_control_no_signal != nil {
		fields = append(fields, metar.FieldQualityControlNoSignal)
	}
	if m.quality_control_lightning_sensor_off != nil {
		fields = append(fields, metar.FieldQualityControlLightningSensorOff)
	}
	if m.quality_control_freezing_rain_sensor_off != nil {
		fields = append(fields, metar.FieldQualityControlFreezingRainSensorOff)
	}
	if m.quality_control_present_weather_sensor_off != nil {
		fields = append(fields, metar.FieldQualityControlPresentWeatherSensorOff)
	}
	if m.sea_level_pressure != nil {
		fields = append(fields, metar.FieldSeaLevelPressure)
	}
	if m.pressure_tendency != nil {
		fields = append(fields, metar.FieldPressureTendency)
	}
	if m.max_temp_6 != nil {
		fields = append(fields, metar.FieldMaxTemp6)
	}
	if m.min_temp_6 != nil {
		fields = append(fields, metar.FieldMinTemp6)
	}
	if m.max_temp_24 != nil {
		fields = append(fields, metar.FieldMaxTemp24)
	}
	if m.min_temp_24 != nil {
		fields = append(fields, metar.FieldMinTemp24)
	}
	if m.precipitation != nil {
		fields = append(fields, metar.FieldPrecipitation)
	}
	if m.precipitation_3 != nil {
		fields = append(fields, metar.FieldPrecipitation3)
	}
	if m.precipitation_6 != nil {
		fields = append(fields, metar.FieldPrecipitation6)
	}
	if m.precipitation_24 != nil {
		fields = append(fields, metar.FieldPrecipitation24)
	}
	if m.snow_depth != nil {
		fields = append(fields, metar.FieldSnowDepth)
	}
	if m.vert_vis != nil {
		fields = append(fields, metar.FieldVertVis)
	}
	if m.metar_type != nil {
		fields = append(fields, metar.FieldMetarType)
	}
	if m.hash != nil {
		fields = append(fields, metar.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metar.FieldRawText:
		return m.RawText()
	case metar.FieldObservationTime:
		return m.ObservationTime()
	case metar.FieldLatitude:
		return m.Latitude()
	case metar.FieldLongitude:
		return m.Longitude()
	case metar.FieldElevation:
		return m.Elevation()
	case metar.FieldTemperature:
		return m.Temperature()
	case metar.FieldDewpoint:
		return m.Dewpoint()
	case metar.FieldWindSpeed:
		return m.WindSpeed()
	case metar.FieldWindGust:
		return m.WindGust()
	case metar.FieldWindDirection:
		return m.WindDirection()
	case metar.FieldVisibility:
		return m.Visibility()
	case metar.FieldAltimeter:
		return m.Altimeter()
	case metar.FieldPresentWeather:
		return m.PresentWeather()
	case metar.FieldFlightCategory:
		return m.FlightCategory()
	case metar.FieldQualityControlCorrected:
		return m.QualityControlCorrected()
	case metar.FieldQualityControlAutoStation:
		return m.QualityControlAutoStation()
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		return m.QualityControlMaintenanceIndicatorOn()
	case metar.FieldQualityControlNoSignal:
		return m.QualityControlNoSignal()
	case metar.FieldQualityControlLightningSensorOff:
		return m.QualityControlLightningSensorOff()
	case metar.FieldQualityControlFreezingRainSensorOff:
		return m.QualityControlFreezingRainSensorOff()
	case metar.FieldQualityControlPresentWeatherSensorOff:
		return m.QualityControlPresentWeatherSensorOff()
	case metar.FieldSeaLevelPressure:
		return m.SeaLevelPressure()
	case metar.FieldPressureTendency:
		return m.PressureTendency()
	case metar.FieldMaxTemp6:
		return m.MaxTemp6()
	case metar.FieldMinTemp6:
		return m.MinTemp6()
	case metar.FieldMaxTemp24:
		return m.MaxTemp24()
	case metar.FieldMinTemp24:
		return m.MinTemp24()
	case metar.FieldPrecipitation:
		return m.Precipitation()
	case metar.FieldPrecipitation3:
		return m.Precipitation3()
	case metar.FieldPrecipitation6:
		return m.Precipitation6()
	case metar.FieldPrecipitation24:
		return m.Precipitation24()
	case metar.FieldSnowDepth:
		return m.SnowDepth()
	case metar.FieldVertVis:
		return m.VertVis()
	case metar.FieldMetarType:
		return m.MetarType()
	case metar.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metar.FieldRawText:
		return m.OldRawText(ctx)
	case metar.FieldObservationTime:
		return m.OldObservationTime(ctx)
	case metar.FieldLatitude:
		return m.OldLatitude(ctx)
	case metar.FieldLongitude:
		return m.OldLongitude(ctx)
	case metar.FieldElevation:
		return m.OldElevation(ctx)
	case metar.FieldTemperature:
		return m.OldTemperature(ctx)
	case metar.FieldDewpoint:
		return m.OldDewpoint(ctx)
	case metar.FieldWindSpeed:
		return m.OldWindSpeed(ctx)
	case metar.FieldWindGust:
		return m.OldWindGust(ctx)
	case metar.FieldWindDirection:
		return m.OldWindDirection(ctx)
	case metar.FieldVisibility:
		return m.OldVisibility(ctx)
	case metar.FieldAltimeter:
		return m.OldAltimeter(ctx)
	case metar.FieldPresentWeather:
		return m.OldPresentWeather(ctx)
	case metar.FieldFlightCategory:
		return m.OldFlightCategory(ctx)
	case metar.FieldQualityControlCorrected:
		return m.OldQualityControlCorrected(ctx)
	case metar.FieldQualityControlAutoStation:
		return m.OldQualityControlAutoStation(ctx)
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		return m.OldQualityControlMaintenanceIndicatorOn(ctx)
	case metar.FieldQualityControlNoSignal:
		return m.OldQualityControlNoSignal(ctx)
	case metar.FieldQualityControlLightningSensorOff:
		return m.OldQualityControlLightningSensorOff(ctx)
	case metar.FieldQualityControlFreezingRainSensorOff:
		return m.OldQualityControlFreezingRainSensorOff(ctx)
	case metar.FieldQualityControlPresentWeatherSensorOff:
		return m.OldQualityControlPresentWeatherSensorOff(ctx)
	case metar.FieldSeaLevelPressure:
		return m.OldSeaLevelPressure(ctx)
	case metar.FieldPressureTendency:
		return m.OldPressureTendency(ctx)
	case metar.FieldMaxTemp6:
		return m.OldMaxTemp6(ctx)
	case metar.FieldMinTemp6:
		return m.OldMinTemp6(ctx)
	case metar.FieldMaxTemp24:
		return m.OldMaxTemp24(ctx)
	case metar.FieldMinTemp24:
		return m.OldMinTemp24(ctx)
	case metar.FieldPrecipitation:
		return m.OldPrecipitation(ctx)
	case metar.FieldPrecipitation3:
		return m.OldPrecipitation3(ctx)
	case metar.FieldPrecipitation6:
		return m.OldPrecipitation6(ctx)
	case metar.FieldPrecipitation24:
		return m.OldPrecipitation24(ctx)
	case metar.FieldSnowDepth:
		return m.OldSnowDepth(ctx)
	case metar.FieldVertVis:
		return m.OldVertVis(ctx)
	case metar.FieldMetarType:
		return m.OldMetarType(ctx)
	case metar.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown Metar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metar.FieldRawText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawText(v)
		return nil
	case metar.FieldObservationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObservationTime(v)
		return nil
	case metar.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case metar.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case metar.FieldElevation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElevation(v)
		return nil
	case metar.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case metar.FieldDewpoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDewpoint(v)
		return nil
	case metar.FieldWindSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindSpeed(v)
		return nil
	case metar.FieldWindGust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindGust(v)
		return nil
	case metar.FieldWindDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirection(v)
		return nil
	case metar.FieldVisibility:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case metar.FieldAltimeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltimeter(v)
		return nil
	case metar.FieldPresentWeather:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresentWeather(v)
		return nil
	case metar.FieldFlightCategory:
		v, ok := value.(metar.FlightCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightCategory(v)
		return nil
	case metar.FieldQualityControlCorrected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlCorrected(v)
		return nil
	case metar.FieldQualityControlAutoStation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlAutoStation(v)
		return nil
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlMaintenanceIndicatorOn(v)
		return nil
	case metar.FieldQualityControlNoSignal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlNoSignal(v)
		return nil
	case metar.FieldQualityControlLightningSensorOff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlLightningSensorOff(v)
		return nil
	case metar.FieldQualityControlFreezingRainSensorOff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlFreezingRainSensorOff(v)
		return nil
	case metar.FieldQualityControlPresentWeatherSensorOff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlPresentWeatherSensorOff(v)
		return nil
	case metar.FieldSeaLevelPressure:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeaLevelPressure(v)
		return nil
	case metar.FieldPressureTendency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPressureTendency(v)
		return nil
	case metar.FieldMaxTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemp6(v)
		return nil
	case metar.FieldMinTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemp6(v)
		return nil
	case metar.FieldMaxTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemp24(v)
		return nil
	case metar.FieldMinTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemp24(v)
		return nil
	case metar.FieldPrecipitation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation(v)
		return nil
	case metar.FieldPrecipitation3:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation3(v)
		return nil
	case metar.FieldPrecipitation6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation6(v)
		return nil
	case metar.FieldPrecipitation24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation24(v)
		return nil
	case metar.FieldSnowDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnowDepth(v)
		return nil
	case metar.FieldVertVis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVertVis(v)
		return nil
	case metar.FieldMetarType:
		v, ok := value.(metar.MetarType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetarType(v)
		return nil
	case metar.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown Metar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetarMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, metar.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, metar.FieldLongitude)
	}
	if m.addelevation != nil {
		fields = append(fields, metar.FieldElevation)
	}
	if m.addtemperature != nil {
		fields = append(fields, metar.FieldTemperature)
	}
	if m.adddewpoint != nil {
		fields = append(fields, metar.FieldDewpoint)
	}
	if m.addwind_speed != nil {
		fields = append(fields, metar.FieldWindSpeed)
	}
	if m.addwind_gust != nil {
		fields = append(fields, metar.FieldWindGust)
	}
	if m.addwind_direction != nil {
		fields = append(fields, metar.FieldWindDirection)
	}
	if m.addvisibility != nil {
		fields = append(fields, metar.FieldVisibility)
	}
	if m.addaltimeter != nil {
		fields = append(fields, metar.FieldAltimeter)
	}
	if m.addsea_level_pressure != nil {
		fields = append(fields, metar.FieldSeaLevelPressure)
	}
	if m.addpressure_tendency != nil {
		fields = append(fields, metar.FieldPressureTendency)
	}
	if m.addmax_temp_6 != nil {
		fields = append(fields, metar.FieldMaxTemp6)
	}
	if m.addmin_temp_6 != nil {
		fields = append(fields, metar.FieldMinTemp6)
	}
	if m.addmax_temp_24 != nil {
		fields = append(fields, metar.FieldMaxTemp24)
	}
	if m.addmin_temp_24 != nil {
		fields = append(fields, metar.FieldMinTemp24)
	}
	if m.addprecipitation != nil {
		fields = append(fields, metar.FieldPrecipitation)
	}
	if m.addprecipitation_3 != nil {
		fields = append(fields, metar.FieldPrecipitation3)
	}
	if m.addprecipitation_6 != nil {
		fields = append(fields, metar.FieldPrecipitation6)
	}
	if m.addprecipitation_24 != nil {
		fields = append(fields, metar.FieldPrecipitation24)
	}
	if m.addsnow_depth != nil {
		fields = append(fields, metar.FieldSnowDepth)
	}
	if m.addvert_vis != nil {
		fields = append(fields, metar.FieldVertVis)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case metar.FieldLatitude:
		return m.AddedLatitude()
	case metar.FieldLongitude:
		return m.AddedLongitude()
	case metar.FieldElevation:
		return m.AddedElevation()
	case metar.FieldTemperature:
		return m.AddedTemperature()
	case metar.FieldDewpoint:
		return m.AddedDewpoint()
	case metar.FieldWindSpeed:
		return m.AddedWindSpeed()
	case metar.FieldWindGust:
		return m.AddedWindGust()
	case metar.FieldWindDirection:
		return m.AddedWindDirection()
	case metar.FieldVisibility:
		return m.AddedVisibility()
	case metar.FieldAltimeter:
		return m.AddedAltimeter()
	case metar.FieldSeaLevelPressure:
		return m.AddedSeaLevelPressure()
	case metar.FieldPressureTendency:
		return m.AddedPressureTendency()
	case metar.FieldMaxTemp6:
		return m.AddedMaxTemp6()
	case metar.FieldMinTemp6:
		return m.AddedMinTemp6()
	case metar.FieldMaxTemp24:
		return m.AddedMaxTemp24()
	case metar.FieldMinTemp24:
		return m.AddedMinTemp24()
	case metar.FieldPrecipitation:
		return m.AddedPrecipitation()
	case metar.FieldPrecipitation3:
		return m.AddedPrecipitation3()
	case metar.FieldPrecipitation6:
		return m.AddedPrecipitation6()
	case metar.FieldPrecipitation24:
		return m.AddedPrecipitation24()
	case metar.FieldSnowDepth:
		return m.AddedSnowDepth()
	case metar.FieldVertVis:
		return m.AddedVertVis()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case metar.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case metar.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case metar.FieldElevation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElevation(v)
		return nil
	case metar.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case metar.FieldDewpoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDewpoint(v)
		return nil
	case metar.FieldWindSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindSpeed(v)
		return nil
	case metar.FieldWindGust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindGust(v)
		return nil
	case metar.FieldWindDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindDirection(v)
		return nil
	case metar.FieldVisibility:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisibility(v)
		return nil
	case metar.FieldAltimeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAltimeter(v)
		return nil
	case metar.FieldSeaLevelPressure:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeaLevelPressure(v)
		return nil
	case metar.FieldPressureTendency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPressureTendency(v)
		return nil
	case metar.FieldMaxTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemp6(v)
		return nil
	case metar.FieldMinTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemp6(v)
		return nil
	case metar.FieldMaxTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemp24(v)
		return nil
	case metar.FieldMinTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemp24(v)
		return nil
	case metar.FieldPrecipitation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation(v)
		return nil
	case metar.FieldPrecipitation3:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation3(v)
		return nil
	case metar.FieldPrecipitation6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation6(v)
		return nil
	case metar.FieldPrecipitation24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation24(v)
		return nil
	case metar.FieldSnowDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSnowDepth(v)
		return nil
	case metar.FieldVertVis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVertVis(v)
		return nil
	}
	return fmt.Errorf("unknown Metar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metar.FieldLatitude) {
		fields = append(fields, metar.FieldLatitude)
	}
	if m.FieldCleared(metar.FieldLongitude) {
		fields = append(fields, metar.FieldLongitude)
	}
	if m.FieldCleared(metar.FieldElevation) {
		fields = append(fields, metar.FieldElevation)
	}
	if m.FieldCleared(metar.FieldPresentWeather) {
		fields = append(fields, metar.FieldPresentWeather)
	}
	if m.FieldCleared(metar.FieldFlightCategory) {
		fields = append(fields, metar.FieldFlightCategory)
	}
	if m.FieldCleared(metar.FieldQualityControlCorrected) {
		fields = append(fields, metar.FieldQualityControlCorrected)
	}
	if m.FieldCleared(metar.FieldSeaLevelPressure) {
		fields = append(fields, metar.FieldSeaLevelPressure)
	}
	if m.FieldCleared(metar.FieldPressureTendency) {
		fields = append(fields, metar.FieldPressureTendency)
	}
	if m.FieldCleared(metar.FieldMaxTemp6) {
		fields = append(fields, metar.FieldMaxTemp6)
	}
	if m.FieldCleared(metar.FieldMinTemp6) {
		fields = append(fields, metar.FieldMinTemp6)
	}
	if m.FieldCleared(metar.FieldMaxTemp24) {
		fields = append(fields, metar.FieldMaxTemp24)
	}
	if m.FieldCleared(metar.FieldMinTemp24) {
		fields = append(fields, metar.FieldMinTemp24)
	}
	if m.FieldCleared(metar.FieldPrecipitation) {
		fields = append(fields, metar.FieldPrecipitation)
	}
	if m.FieldCleared(metar.FieldPrecipitation3) {
		fields = append(fields, metar.FieldPrecipitation3)
	}
	if m.FieldCleared(metar.FieldPrecipitation6) {
		fields = append(fields, metar.FieldPrecipitation6)
	}
	if m.FieldCleared(metar.FieldPrecipitation24) {
		fields = append(fields, metar.FieldPrecipitation24)
	}
	if m.FieldCleared(metar.FieldSnowDepth) {
		fields = append(fields, metar.FieldSnowDepth)
	}
	if m.FieldCleared(metar.FieldVertVis) {
		fields = append(fields, metar.FieldVertVis)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetarMutation) ClearField(name string) error {
	switch name {
	case metar.FieldLatitude:
		m.ClearLatitude()
		return nil
	case metar.FieldLongitude:
		m.ClearLongitude()
		return nil
	case metar.FieldElevation:
		m.ClearElevation()
		return nil
	case metar.FieldPresentWeather:
		m.ClearPresentWeather()
		return nil
	case metar.FieldFlightCategory:
		m.ClearFlightCategory()
		return nil
	case metar.FieldQualityControlCorrected:
		m.ClearQualityControlCorrected()
		return nil
	case metar.FieldSeaLevelPressure:
		m.ClearSeaLevelPressure()
		return nil
	case metar.FieldPressureTendency:
		m.ClearPressureTendency()
		return nil
	case metar.FieldMaxTemp6:
		m.ClearMaxTemp6()
		return nil
	case metar.FieldMinTemp6:
		m.ClearMinTemp6()
		return nil
	case metar.FieldMaxTemp24:
		m.ClearMaxTemp24()
		return nil
	case metar.FieldMinTemp24:
		m.ClearMinTemp24()
		return nil
	case metar.FieldPrecipitation:
		m.ClearPrecipitation()
		return nil
	case metar.FieldPrecipitation3:
		m.ClearPrecipitation3()
		return nil
	case metar.FieldPrecipitation6:
		m.ClearPrecipitation6()
		return nil
	case metar.FieldPrecipitation24:
		m.ClearPrecipitation24()
		return nil
	case metar.FieldSnowDepth:
		m.ClearSnowDepth()
		return nil
	case metar.FieldVertVis:
		m.ClearVertVis()
		return nil
	}
	return fmt.Errorf("unknown Metar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetarMutation) ResetField(name string) error {
	switch name {
	case metar.FieldRawText:
		m.ResetRawText()
		return nil
	case metar.FieldObservationTime:
		m.ResetObservationTime()
		return nil
	case metar.FieldLatitude:
		m.ResetLatitude()
		return nil
	case metar.FieldLongitude:
		m.ResetLongitude()
		return nil
	case metar.FieldElevation:
		m.ResetElevation()
		return nil
	case metar.FieldTemperature:
		m.ResetTemperature()
		return nil
	case metar.FieldDewpoint:
		m.ResetDewpoint()
		return nil
	case metar.FieldWindSpeed:
		m.ResetWindSpeed()
		return nil
	case metar.FieldWindGust:
		m.ResetWindGust()
		return nil
	case metar.FieldWindDirection:
		m.ResetWindDirection()
		return nil
	case metar.FieldVisibility:
		m.ResetVisibility()
		return nil
	case metar.FieldAltimeter:
		m.ResetAltimeter()
		return nil
	case metar.FieldPresentWeather:
		m.ResetPresentWeather()
		return nil
	case metar.FieldFlightCategory:
		m.ResetFlightCategory()
		return nil
	case metar.FieldQualityControlCorrected:
		m.ResetQualityControlCorrected()
		return nil
	case metar.FieldQualityControlAutoStation:
		m.ResetQualityControlAutoStation()
		return nil
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		m.ResetQualityControlMaintenanceIndicatorOn()
		return nil
	case metar.FieldQualityControlNoSignal:
		m.ResetQualityControlNoSignal()
		return nil
	case metar.FieldQualityControlLightningSensorOff:
		m.ResetQualityControlLightningSensorOff()
		return nil
	case metar.FieldQualityControlFreezingRainSensorOff:
		m.ResetQualityControlFreezingRainSensorOff()
		return nil
	case metar.FieldQualityControlPresentWeatherSensorOff:
		m.ResetQualityControlPresentWeatherSensorOff()
		return nil
	case metar.FieldSeaLevelPressure:
		m.ResetSeaLevelPressure()
		return nil
	case metar.FieldPressureTendency:
		m.ResetPressureTendency()
		return nil
	case metar.FieldMaxTemp6:
		m.ResetMaxTemp6()
		return nil
	case metar.FieldMinTemp6:
		m.ResetMinTemp6()
		return nil
	case metar.FieldMaxTemp24:
		m.ResetMaxTemp24()
		return nil
	case metar.FieldMinTemp24:
		m.ResetMinTemp24()
		return nil
	case metar.FieldPrecipitation:
		m.ResetPrecipitation()
		return nil
	case metar.FieldPrecipitation3:
		m.ResetPrecipitation3()
		return nil
	case metar.FieldPrecipitation6:
		m.ResetPrecipitation6()
		return nil
	case metar.FieldPrecipitation24:
		m.ResetPrecipitation24()
		return nil
	case metar.FieldSnowDepth:
		m.ResetSnowDepth()
		return nil
	case metar.FieldVertVis:
		m.ResetVertVis()
		return nil
	case metar.FieldMetarType:
		m.ResetMetarType()
		return nil
	case metar.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown Metar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetarMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.airport != nil {
		edges = append(edges, metar.EdgeAirport)
	}
	if m.sky_conditions != nil {
		edges = append(edges, metar.EdgeSkyConditions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metar.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	case metar.EdgeSkyConditions:
		ids := make([]ent.Value, 0, len(m.sky_conditions))
		for id := range m.sky_conditions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsky_conditions != nil {
		edges = append(edges, metar.EdgeSkyConditions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metar.EdgeSkyConditions:
		ids := make([]ent.Value, 0, len(m.removedsky_conditions))
		for id := range m.removedsky_conditions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedairport {
		edges = append(edges, metar.EdgeAirport)
	}
	if m.clearedsky_conditions {
		edges = append(edges, metar.EdgeSkyConditions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetarMutation) EdgeCleared(name string) bool {
	switch name {
	case metar.EdgeAirport:
		return m.clearedairport
	case metar.EdgeSkyConditions:
		return m.clearedsky_conditions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetarMutation) ClearEdge(name string) error {
	switch name {
	case metar.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown Metar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetarMutation) ResetEdge(name string) error {
	switch name {
	case metar.EdgeAirport:
		m.ResetAirport()
		return nil
	case metar.EdgeSkyConditions:
		m.ResetSkyConditions()
		return nil
	}
	return fmt.Errorf("unknown Metar edge %s", name)
}

// RunwayMutation represents an operation that mutates the Runway nodes in the graph.
type RunwayMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	hash                               *string
	import_flag                        *bool
	last_updated                       *time.Time
	length                             *int
	addlength                          *int
	width                              *int
	addwidth                           *int
	surface                            *string
	lighted                            *bool
	closed                             *bool
	low_runway_identifier              *string
	low_runway_latitude                *float64
	addlow_runway_latitude             *float64
	low_runway_longitude               *float64
	addlow_runway_longitude            *float64
	low_runway_elevation               *int
	addlow_runway_elevation            *int
	low_runway_heading                 *float64
	addlow_runway_heading              *float64
	low_runway_displaced_threshold     *int
	addlow_runway_displaced_threshold  *int
	high_runway_identifier             *string
	high_runway_latitude               *float64
	addhigh_runway_latitude            *float64
	high_runway_longitude              *float64
	addhigh_runway_longitude           *float64
	high_runway_elevation              *int
	addhigh_runway_elevation           *int
	high_runway_heading                *float64
	addhigh_runway_heading             *float64
	high_runway_displaced_threshold    *int
	addhigh_runway_displaced_threshold *int
	clearedFields                      map[string]struct{}
	airport                            *int
	clearedairport                     bool
	done                               bool
	oldValue                           func(context.Context) (*Runway, error)
	predicates                         []predicate.Runway
}

var _ ent.Mutation = (*RunwayMutation)(nil)

// runwayOption allows management of the mutation configuration using functional options.
type runwayOption func(*RunwayMutation)

// newRunwayMutation creates new mutation for the Runway entity.
func newRunwayMutation(c config, op Op, opts ...runwayOption) *RunwayMutation {
	m := &RunwayMutation{
		config:        c,
		op:            op,
		typ:           TypeRunway,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunwayID sets the ID field of the mutation.
func withRunwayID(id int) runwayOption {
	return func(m *RunwayMutation) {
		var (
			err   error
			once  sync.Once
			value *Runway
		)
		m.oldValue = func(ctx context.Context) (*Runway, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Runway.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRunway sets the old Runway of the mutation.
func withRunway(node *Runway) runwayOption {
	return func(m *RunwayMutation) {
		m.oldValue = func(context.Context) (*Runway, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunwayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunwayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Runway entities.
func (m *RunwayMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RunwayMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RunwayMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Runway.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *RunwayMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *RunwayMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *RunwayMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *RunwayMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *RunwayMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *RunwayMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *RunwayMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *RunwayMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *RunwayMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetLength sets the "length" field.
func (m *RunwayMutation) SetLength(i int) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *RunwayMutation) Length() (r int, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *RunwayMutation) AddLength(i int) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *RunwayMutation) AddedLength() (r int, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *RunwayMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the "width" field.
func (m *RunwayMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *RunwayMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *RunwayMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *RunwayMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *RunwayMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetSurface sets the "surface" field.
func (m *RunwayMutation) SetSurface(s string) {
	m.surface = &s
}

// Surface returns the value of the "surface" field in the mutation.
func (m *RunwayMutation) Surface() (r string, exists bool) {
	v := m.surface
	if v == nil {
		return
	}
	return *v, true
}

// OldSurface returns the old "surface" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldSurface(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurface is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurface requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurface: %w", err)
	}
	return oldValue.Surface, nil
}

// ClearSurface clears the value of the "surface" field.
func (m *RunwayMutation) ClearSurface() {
	m.surface = nil
	m.clearedFields[runway.FieldSurface] = struct{}{}
}

// SurfaceCleared returns if the "surface" field was cleared in this mutation.
func (m *RunwayMutation) SurfaceCleared() bool {
	_, ok := m.clearedFields[runway.FieldSurface]
	return ok
}

// ResetSurface resets all changes to the "surface" field.
func (m *RunwayMutation) ResetSurface() {
	m.surface = nil
	delete(m.clearedFields, runway.FieldSurface)
}

// SetLighted sets the "lighted" field.
func (m *RunwayMutation) SetLighted(b bool) {
	m.lighted = &b
}

// Lighted returns the value of the "lighted" field in the mutation.
func (m *RunwayMutation) Lighted() (r bool, exists bool) {
	v := m.lighted
	if v == nil {
		return
	}
	return *v, true
}

// OldLighted returns the old "lighted" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLighted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLighted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLighted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLighted: %w", err)
	}
	return oldValue.Lighted, nil
}

// ResetLighted resets all changes to the "lighted" field.
func (m *RunwayMutation) ResetLighted() {
	m.lighted = nil
}

// SetClosed sets the "closed" field.
func (m *RunwayMutation) SetClosed(b bool) {
	m.closed = &b
}

// Closed returns the value of the "closed" field in the mutation.
func (m *RunwayMutation) Closed() (r bool, exists bool) {
	v := m.closed
	if v == nil {
		return
	}
	return *v, true
}

// OldClosed returns the old "closed" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldClosed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosed: %w", err)
	}
	return oldValue.Closed, nil
}

// ResetClosed resets all changes to the "closed" field.
func (m *RunwayMutation) ResetClosed() {
	m.closed = nil
}

// SetLowRunwayIdentifier sets the "low_runway_identifier" field.
func (m *RunwayMutation) SetLowRunwayIdentifier(s string) {
	m.low_runway_identifier = &s
}

// LowRunwayIdentifier returns the value of the "low_runway_identifier" field in the mutation.
func (m *RunwayMutation) LowRunwayIdentifier() (r string, exists bool) {
	v := m.low_runway_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayIdentifier returns the old "low_runway_identifier" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayIdentifier: %w", err)
	}
	return oldValue.LowRunwayIdentifier, nil
}

// ResetLowRunwayIdentifier resets all changes to the "low_runway_identifier" field.
func (m *RunwayMutation) ResetLowRunwayIdentifier() {
	m.low_runway_identifier = nil
}

// SetLowRunwayLatitude sets the "low_runway_latitude" field.
func (m *RunwayMutation) SetLowRunwayLatitude(f float64) {
	m.low_runway_latitude = &f
	m.addlow_runway_latitude = nil
}

// LowRunwayLatitude returns the value of the "low_runway_latitude" field in the mutation.
func (m *RunwayMutation) LowRunwayLatitude() (r float64, exists bool) {
	v := m.low_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayLatitude returns the old "low_runway_latitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayLatitude: %w", err)
	}
	return oldValue.LowRunwayLatitude, nil
}

// AddLowRunwayLatitude adds f to the "low_runway_latitude" field.
func (m *RunwayMutation) AddLowRunwayLatitude(f float64) {
	if m.addlow_runway_latitude != nil {
		*m.addlow_runway_latitude += f
	} else {
		m.addlow_runway_latitude = &f
	}
}

// AddedLowRunwayLatitude returns the value that was added to the "low_runway_latitude" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayLatitude() (r float64, exists bool) {
	v := m.addlow_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayLatitude clears the value of the "low_runway_latitude" field.
func (m *RunwayMutation) ClearLowRunwayLatitude() {
	m.low_runway_latitude = nil
	m.addlow_runway_latitude = nil
	m.clearedFields[runway.FieldLowRunwayLatitude] = struct{}{}
}

// LowRunwayLatitudeCleared returns if the "low_runway_latitude" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayLatitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayLatitude]
	return ok
}

// ResetLowRunwayLatitude resets all changes to the "low_runway_latitude" field.
func (m *RunwayMutation) ResetLowRunwayLatitude() {
	m.low_runway_latitude = nil
	m.addlow_runway_latitude = nil
	delete(m.clearedFields, runway.FieldLowRunwayLatitude)
}

// SetLowRunwayLongitude sets the "low_runway_longitude" field.
func (m *RunwayMutation) SetLowRunwayLongitude(f float64) {
	m.low_runway_longitude = &f
	m.addlow_runway_longitude = nil
}

// LowRunwayLongitude returns the value of the "low_runway_longitude" field in the mutation.
func (m *RunwayMutation) LowRunwayLongitude() (r float64, exists bool) {
	v := m.low_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayLongitude returns the old "low_runway_longitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayLongitude: %w", err)
	}
	return oldValue.LowRunwayLongitude, nil
}

// AddLowRunwayLongitude adds f to the "low_runway_longitude" field.
func (m *RunwayMutation) AddLowRunwayLongitude(f float64) {
	if m.addlow_runway_longitude != nil {
		*m.addlow_runway_longitude += f
	} else {
		m.addlow_runway_longitude = &f
	}
}

// AddedLowRunwayLongitude returns the value that was added to the "low_runway_longitude" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayLongitude() (r float64, exists bool) {
	v := m.addlow_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayLongitude clears the value of the "low_runway_longitude" field.
func (m *RunwayMutation) ClearLowRunwayLongitude() {
	m.low_runway_longitude = nil
	m.addlow_runway_longitude = nil
	m.clearedFields[runway.FieldLowRunwayLongitude] = struct{}{}
}

// LowRunwayLongitudeCleared returns if the "low_runway_longitude" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayLongitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayLongitude]
	return ok
}

// ResetLowRunwayLongitude resets all changes to the "low_runway_longitude" field.
func (m *RunwayMutation) ResetLowRunwayLongitude() {
	m.low_runway_longitude = nil
	m.addlow_runway_longitude = nil
	delete(m.clearedFields, runway.FieldLowRunwayLongitude)
}

// SetLowRunwayElevation sets the "low_runway_elevation" field.
func (m *RunwayMutation) SetLowRunwayElevation(i int) {
	m.low_runway_elevation = &i
	m.addlow_runway_elevation = nil
}

// LowRunwayElevation returns the value of the "low_runway_elevation" field in the mutation.
func (m *RunwayMutation) LowRunwayElevation() (r int, exists bool) {
	v := m.low_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayElevation returns the old "low_runway_elevation" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayElevation(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayElevation: %w", err)
	}
	return oldValue.LowRunwayElevation, nil
}

// AddLowRunwayElevation adds i to the "low_runway_elevation" field.
func (m *RunwayMutation) AddLowRunwayElevation(i int) {
	if m.addlow_runway_elevation != nil {
		*m.addlow_runway_elevation += i
	} else {
		m.addlow_runway_elevation = &i
	}
}

// AddedLowRunwayElevation returns the value that was added to the "low_runway_elevation" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayElevation() (r int, exists bool) {
	v := m.addlow_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayElevation clears the value of the "low_runway_elevation" field.
func (m *RunwayMutation) ClearLowRunwayElevation() {
	m.low_runway_elevation = nil
	m.addlow_runway_elevation = nil
	m.clearedFields[runway.FieldLowRunwayElevation] = struct{}{}
}

// LowRunwayElevationCleared returns if the "low_runway_elevation" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayElevationCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayElevation]
	return ok
}

// ResetLowRunwayElevation resets all changes to the "low_runway_elevation" field.
func (m *RunwayMutation) ResetLowRunwayElevation() {
	m.low_runway_elevation = nil
	m.addlow_runway_elevation = nil
	delete(m.clearedFields, runway.FieldLowRunwayElevation)
}

// SetLowRunwayHeading sets the "low_runway_heading" field.
func (m *RunwayMutation) SetLowRunwayHeading(f float64) {
	m.low_runway_heading = &f
	m.addlow_runway_heading = nil
}

// LowRunwayHeading returns the value of the "low_runway_heading" field in the mutation.
func (m *RunwayMutation) LowRunwayHeading() (r float64, exists bool) {
	v := m.low_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayHeading returns the old "low_runway_heading" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayHeading(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayHeading is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayHeading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayHeading: %w", err)
	}
	return oldValue.LowRunwayHeading, nil
}

// AddLowRunwayHeading adds f to the "low_runway_heading" field.
func (m *RunwayMutation) AddLowRunwayHeading(f float64) {
	if m.addlow_runway_heading != nil {
		*m.addlow_runway_heading += f
	} else {
		m.addlow_runway_heading = &f
	}
}

// AddedLowRunwayHeading returns the value that was added to the "low_runway_heading" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayHeading() (r float64, exists bool) {
	v := m.addlow_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayHeading clears the value of the "low_runway_heading" field.
func (m *RunwayMutation) ClearLowRunwayHeading() {
	m.low_runway_heading = nil
	m.addlow_runway_heading = nil
	m.clearedFields[runway.FieldLowRunwayHeading] = struct{}{}
}

// LowRunwayHeadingCleared returns if the "low_runway_heading" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayHeadingCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayHeading]
	return ok
}

// ResetLowRunwayHeading resets all changes to the "low_runway_heading" field.
func (m *RunwayMutation) ResetLowRunwayHeading() {
	m.low_runway_heading = nil
	m.addlow_runway_heading = nil
	delete(m.clearedFields, runway.FieldLowRunwayHeading)
}

// SetLowRunwayDisplacedThreshold sets the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) SetLowRunwayDisplacedThreshold(i int) {
	m.low_runway_displaced_threshold = &i
	m.addlow_runway_displaced_threshold = nil
}

// LowRunwayDisplacedThreshold returns the value of the "low_runway_displaced_threshold" field in the mutation.
func (m *RunwayMutation) LowRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.low_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayDisplacedThreshold returns the old "low_runway_displaced_threshold" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayDisplacedThreshold(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayDisplacedThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayDisplacedThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayDisplacedThreshold: %w", err)
	}
	return oldValue.LowRunwayDisplacedThreshold, nil
}

// AddLowRunwayDisplacedThreshold adds i to the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) AddLowRunwayDisplacedThreshold(i int) {
	if m.addlow_runway_displaced_threshold != nil {
		*m.addlow_runway_displaced_threshold += i
	} else {
		m.addlow_runway_displaced_threshold = &i
	}
}

// AddedLowRunwayDisplacedThreshold returns the value that was added to the "low_runway_displaced_threshold" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.addlow_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayDisplacedThreshold clears the value of the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) ClearLowRunwayDisplacedThreshold() {
	m.low_runway_displaced_threshold = nil
	m.addlow_runway_displaced_threshold = nil
	m.clearedFields[runway.FieldLowRunwayDisplacedThreshold] = struct{}{}
}

// LowRunwayDisplacedThresholdCleared returns if the "low_runway_displaced_threshold" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayDisplacedThresholdCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayDisplacedThreshold]
	return ok
}

// ResetLowRunwayDisplacedThreshold resets all changes to the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) ResetLowRunwayDisplacedThreshold() {
	m.low_runway_displaced_threshold = nil
	m.addlow_runway_displaced_threshold = nil
	delete(m.clearedFields, runway.FieldLowRunwayDisplacedThreshold)
}

// SetHighRunwayIdentifier sets the "high_runway_identifier" field.
func (m *RunwayMutation) SetHighRunwayIdentifier(s string) {
	m.high_runway_identifier = &s
}

// HighRunwayIdentifier returns the value of the "high_runway_identifier" field in the mutation.
func (m *RunwayMutation) HighRunwayIdentifier() (r string, exists bool) {
	v := m.high_runway_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayIdentifier returns the old "high_runway_identifier" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayIdentifier: %w", err)
	}
	return oldValue.HighRunwayIdentifier, nil
}

// ResetHighRunwayIdentifier resets all changes to the "high_runway_identifier" field.
func (m *RunwayMutation) ResetHighRunwayIdentifier() {
	m.high_runway_identifier = nil
}

// SetHighRunwayLatitude sets the "high_runway_latitude" field.
func (m *RunwayMutation) SetHighRunwayLatitude(f float64) {
	m.high_runway_latitude = &f
	m.addhigh_runway_latitude = nil
}

// HighRunwayLatitude returns the value of the "high_runway_latitude" field in the mutation.
func (m *RunwayMutation) HighRunwayLatitude() (r float64, exists bool) {
	v := m.high_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayLatitude returns the old "high_runway_latitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayLatitude: %w", err)
	}
	return oldValue.HighRunwayLatitude, nil
}

// AddHighRunwayLatitude adds f to the "high_runway_latitude" field.
func (m *RunwayMutation) AddHighRunwayLatitude(f float64) {
	if m.addhigh_runway_latitude != nil {
		*m.addhigh_runway_latitude += f
	} else {
		m.addhigh_runway_latitude = &f
	}
}

// AddedHighRunwayLatitude returns the value that was added to the "high_runway_latitude" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayLatitude() (r float64, exists bool) {
	v := m.addhigh_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayLatitude clears the value of the "high_runway_latitude" field.
func (m *RunwayMutation) ClearHighRunwayLatitude() {
	m.high_runway_latitude = nil
	m.addhigh_runway_latitude = nil
	m.clearedFields[runway.FieldHighRunwayLatitude] = struct{}{}
}

// HighRunwayLatitudeCleared returns if the "high_runway_latitude" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayLatitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayLatitude]
	return ok
}

// ResetHighRunwayLatitude resets all changes to the "high_runway_latitude" field.
func (m *RunwayMutation) ResetHighRunwayLatitude() {
	m.high_runway_latitude = nil
	m.addhigh_runway_latitude = nil
	delete(m.clearedFields, runway.FieldHighRunwayLatitude)
}

// SetHighRunwayLongitude sets the "high_runway_longitude" field.
func (m *RunwayMutation) SetHighRunwayLongitude(f float64) {
	m.high_runway_longitude = &f
	m.addhigh_runway_longitude = nil
}

// HighRunwayLongitude returns the value of the "high_runway_longitude" field in the mutation.
func (m *RunwayMutation) HighRunwayLongitude() (r float64, exists bool) {
	v := m.high_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayLongitude returns the old "high_runway_longitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayLongitude: %w", err)
	}
	return oldValue.HighRunwayLongitude, nil
}

// AddHighRunwayLongitude adds f to the "high_runway_longitude" field.
func (m *RunwayMutation) AddHighRunwayLongitude(f float64) {
	if m.addhigh_runway_longitude != nil {
		*m.addhigh_runway_longitude += f
	} else {
		m.addhigh_runway_longitude = &f
	}
}

// AddedHighRunwayLongitude returns the value that was added to the "high_runway_longitude" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayLongitude() (r float64, exists bool) {
	v := m.addhigh_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayLongitude clears the value of the "high_runway_longitude" field.
func (m *RunwayMutation) ClearHighRunwayLongitude() {
	m.high_runway_longitude = nil
	m.addhigh_runway_longitude = nil
	m.clearedFields[runway.FieldHighRunwayLongitude] = struct{}{}
}

// HighRunwayLongitudeCleared returns if the "high_runway_longitude" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayLongitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayLongitude]
	return ok
}

// ResetHighRunwayLongitude resets all changes to the "high_runway_longitude" field.
func (m *RunwayMutation) ResetHighRunwayLongitude() {
	m.high_runway_longitude = nil
	m.addhigh_runway_longitude = nil
	delete(m.clearedFields, runway.FieldHighRunwayLongitude)
}

// SetHighRunwayElevation sets the "high_runway_elevation" field.
func (m *RunwayMutation) SetHighRunwayElevation(i int) {
	m.high_runway_elevation = &i
	m.addhigh_runway_elevation = nil
}

// HighRunwayElevation returns the value of the "high_runway_elevation" field in the mutation.
func (m *RunwayMutation) HighRunwayElevation() (r int, exists bool) {
	v := m.high_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayElevation returns the old "high_runway_elevation" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayElevation(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayElevation: %w", err)
	}
	return oldValue.HighRunwayElevation, nil
}

// AddHighRunwayElevation adds i to the "high_runway_elevation" field.
func (m *RunwayMutation) AddHighRunwayElevation(i int) {
	if m.addhigh_runway_elevation != nil {
		*m.addhigh_runway_elevation += i
	} else {
		m.addhigh_runway_elevation = &i
	}
}

// AddedHighRunwayElevation returns the value that was added to the "high_runway_elevation" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayElevation() (r int, exists bool) {
	v := m.addhigh_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayElevation clears the value of the "high_runway_elevation" field.
func (m *RunwayMutation) ClearHighRunwayElevation() {
	m.high_runway_elevation = nil
	m.addhigh_runway_elevation = nil
	m.clearedFields[runway.FieldHighRunwayElevation] = struct{}{}
}

// HighRunwayElevationCleared returns if the "high_runway_elevation" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayElevationCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayElevation]
	return ok
}

// ResetHighRunwayElevation resets all changes to the "high_runway_elevation" field.
func (m *RunwayMutation) ResetHighRunwayElevation() {
	m.high_runway_elevation = nil
	m.addhigh_runway_elevation = nil
	delete(m.clearedFields, runway.FieldHighRunwayElevation)
}

// SetHighRunwayHeading sets the "high_runway_heading" field.
func (m *RunwayMutation) SetHighRunwayHeading(f float64) {
	m.high_runway_heading = &f
	m.addhigh_runway_heading = nil
}

// HighRunwayHeading returns the value of the "high_runway_heading" field in the mutation.
func (m *RunwayMutation) HighRunwayHeading() (r float64, exists bool) {
	v := m.high_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayHeading returns the old "high_runway_heading" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayHeading(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayHeading is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayHeading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayHeading: %w", err)
	}
	return oldValue.HighRunwayHeading, nil
}

// AddHighRunwayHeading adds f to the "high_runway_heading" field.
func (m *RunwayMutation) AddHighRunwayHeading(f float64) {
	if m.addhigh_runway_heading != nil {
		*m.addhigh_runway_heading += f
	} else {
		m.addhigh_runway_heading = &f
	}
}

// AddedHighRunwayHeading returns the value that was added to the "high_runway_heading" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayHeading() (r float64, exists bool) {
	v := m.addhigh_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayHeading clears the value of the "high_runway_heading" field.
func (m *RunwayMutation) ClearHighRunwayHeading() {
	m.high_runway_heading = nil
	m.addhigh_runway_heading = nil
	m.clearedFields[runway.FieldHighRunwayHeading] = struct{}{}
}

// HighRunwayHeadingCleared returns if the "high_runway_heading" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayHeadingCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayHeading]
	return ok
}

// ResetHighRunwayHeading resets all changes to the "high_runway_heading" field.
func (m *RunwayMutation) ResetHighRunwayHeading() {
	m.high_runway_heading = nil
	m.addhigh_runway_heading = nil
	delete(m.clearedFields, runway.FieldHighRunwayHeading)
}

// SetHighRunwayDisplacedThreshold sets the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) SetHighRunwayDisplacedThreshold(i int) {
	m.high_runway_displaced_threshold = &i
	m.addhigh_runway_displaced_threshold = nil
}

// HighRunwayDisplacedThreshold returns the value of the "high_runway_displaced_threshold" field in the mutation.
func (m *RunwayMutation) HighRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.high_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayDisplacedThreshold returns the old "high_runway_displaced_threshold" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayDisplacedThreshold(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayDisplacedThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayDisplacedThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayDisplacedThreshold: %w", err)
	}
	return oldValue.HighRunwayDisplacedThreshold, nil
}

// AddHighRunwayDisplacedThreshold adds i to the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) AddHighRunwayDisplacedThreshold(i int) {
	if m.addhigh_runway_displaced_threshold != nil {
		*m.addhigh_runway_displaced_threshold += i
	} else {
		m.addhigh_runway_displaced_threshold = &i
	}
}

// AddedHighRunwayDisplacedThreshold returns the value that was added to the "high_runway_displaced_threshold" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.addhigh_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayDisplacedThreshold clears the value of the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) ClearHighRunwayDisplacedThreshold() {
	m.high_runway_displaced_threshold = nil
	m.addhigh_runway_displaced_threshold = nil
	m.clearedFields[runway.FieldHighRunwayDisplacedThreshold] = struct{}{}
}

// HighRunwayDisplacedThresholdCleared returns if the "high_runway_displaced_threshold" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayDisplacedThresholdCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayDisplacedThreshold]
	return ok
}

// ResetHighRunwayDisplacedThreshold resets all changes to the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) ResetHighRunwayDisplacedThreshold() {
	m.high_runway_displaced_threshold = nil
	m.addhigh_runway_displaced_threshold = nil
	delete(m.clearedFields, runway.FieldHighRunwayDisplacedThreshold)
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *RunwayMutation) SetAirportID(id int) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *RunwayMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *RunwayMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *RunwayMutation) AirportID() (id int, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *RunwayMutation) AirportIDs() (ids []int) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *RunwayMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// Where appends a list predicates to the RunwayMutation builder.
func (m *RunwayMutation) Where(ps ...predicate.Runway) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RunwayMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Runway).
func (m *RunwayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RunwayMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.hash != nil {
		fields = append(fields, runway.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, runway.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, runway.FieldLastUpdated)
	}
	if m.length != nil {
		fields = append(fields, runway.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, runway.FieldWidth)
	}
	if m.surface != nil {
		fields = append(fields, runway.FieldSurface)
	}
	if m.lighted != nil {
		fields = append(fields, runway.FieldLighted)
	}
	if m.closed != nil {
		fields = append(fields, runway.FieldClosed)
	}
	if m.low_runway_identifier != nil {
		fields = append(fields, runway.FieldLowRunwayIdentifier)
	}
	if m.low_runway_latitude != nil {
		fields = append(fields, runway.FieldLowRunwayLatitude)
	}
	if m.low_runway_longitude != nil {
		fields = append(fields, runway.FieldLowRunwayLongitude)
	}
	if m.low_runway_elevation != nil {
		fields = append(fields, runway.FieldLowRunwayElevation)
	}
	if m.low_runway_heading != nil {
		fields = append(fields, runway.FieldLowRunwayHeading)
	}
	if m.low_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldLowRunwayDisplacedThreshold)
	}
	if m.high_runway_identifier != nil {
		fields = append(fields, runway.FieldHighRunwayIdentifier)
	}
	if m.high_runway_latitude != nil {
		fields = append(fields, runway.FieldHighRunwayLatitude)
	}
	if m.high_runway_longitude != nil {
		fields = append(fields, runway.FieldHighRunwayLongitude)
	}
	if m.high_runway_elevation != nil {
		fields = append(fields, runway.FieldHighRunwayElevation)
	}
	if m.high_runway_heading != nil {
		fields = append(fields, runway.FieldHighRunwayHeading)
	}
	if m.high_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldHighRunwayDisplacedThreshold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RunwayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case runway.FieldHash:
		return m.Hash()
	case runway.FieldImportFlag:
		return m.ImportFlag()
	case runway.FieldLastUpdated:
		return m.LastUpdated()
	case runway.FieldLength:
		return m.Length()
	case runway.FieldWidth:
		return m.Width()
	case runway.FieldSurface:
		return m.Surface()
	case runway.FieldLighted:
		return m.Lighted()
	case runway.FieldClosed:
		return m.Closed()
	case runway.FieldLowRunwayIdentifier:
		return m.LowRunwayIdentifier()
	case runway.FieldLowRunwayLatitude:
		return m.LowRunwayLatitude()
	case runway.FieldLowRunwayLongitude:
		return m.LowRunwayLongitude()
	case runway.FieldLowRunwayElevation:
		return m.LowRunwayElevation()
	case runway.FieldLowRunwayHeading:
		return m.LowRunwayHeading()
	case runway.FieldLowRunwayDisplacedThreshold:
		return m.LowRunwayDisplacedThreshold()
	case runway.FieldHighRunwayIdentifier:
		return m.HighRunwayIdentifier()
	case runway.FieldHighRunwayLatitude:
		return m.HighRunwayLatitude()
	case runway.FieldHighRunwayLongitude:
		return m.HighRunwayLongitude()
	case runway.FieldHighRunwayElevation:
		return m.HighRunwayElevation()
	case runway.FieldHighRunwayHeading:
		return m.HighRunwayHeading()
	case runway.FieldHighRunwayDisplacedThreshold:
		return m.HighRunwayDisplacedThreshold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RunwayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case runway.FieldHash:
		return m.OldHash(ctx)
	case runway.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case runway.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case runway.FieldLength:
		return m.OldLength(ctx)
	case runway.FieldWidth:
		return m.OldWidth(ctx)
	case runway.FieldSurface:
		return m.OldSurface(ctx)
	case runway.FieldLighted:
		return m.OldLighted(ctx)
	case runway.FieldClosed:
		return m.OldClosed(ctx)
	case runway.FieldLowRunwayIdentifier:
		return m.OldLowRunwayIdentifier(ctx)
	case runway.FieldLowRunwayLatitude:
		return m.OldLowRunwayLatitude(ctx)
	case runway.FieldLowRunwayLongitude:
		return m.OldLowRunwayLongitude(ctx)
	case runway.FieldLowRunwayElevation:
		return m.OldLowRunwayElevation(ctx)
	case runway.FieldLowRunwayHeading:
		return m.OldLowRunwayHeading(ctx)
	case runway.FieldLowRunwayDisplacedThreshold:
		return m.OldLowRunwayDisplacedThreshold(ctx)
	case runway.FieldHighRunwayIdentifier:
		return m.OldHighRunwayIdentifier(ctx)
	case runway.FieldHighRunwayLatitude:
		return m.OldHighRunwayLatitude(ctx)
	case runway.FieldHighRunwayLongitude:
		return m.OldHighRunwayLongitude(ctx)
	case runway.FieldHighRunwayElevation:
		return m.OldHighRunwayElevation(ctx)
	case runway.FieldHighRunwayHeading:
		return m.OldHighRunwayHeading(ctx)
	case runway.FieldHighRunwayDisplacedThreshold:
		return m.OldHighRunwayDisplacedThreshold(ctx)
	}
	return nil, fmt.Errorf("unknown Runway field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunwayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case runway.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case runway.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case runway.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case runway.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case runway.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case runway.FieldSurface:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurface(v)
		return nil
	case runway.FieldLighted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLighted(v)
		return nil
	case runway.FieldClosed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosed(v)
		return nil
	case runway.FieldLowRunwayIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayIdentifier(v)
		return nil
	case runway.FieldLowRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayLatitude(v)
		return nil
	case runway.FieldLowRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayLongitude(v)
		return nil
	case runway.FieldLowRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayElevation(v)
		return nil
	case runway.FieldLowRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayHeading(v)
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayDisplacedThreshold(v)
		return nil
	case runway.FieldHighRunwayIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayIdentifier(v)
		return nil
	case runway.FieldHighRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayLatitude(v)
		return nil
	case runway.FieldHighRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayLongitude(v)
		return nil
	case runway.FieldHighRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayElevation(v)
		return nil
	case runway.FieldHighRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayHeading(v)
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayDisplacedThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown Runway field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RunwayMutation) AddedFields() []string {
	var fields []string
	if m.addlength != nil {
		fields = append(fields, runway.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, runway.FieldWidth)
	}
	if m.addlow_runway_latitude != nil {
		fields = append(fields, runway.FieldLowRunwayLatitude)
	}
	if m.addlow_runway_longitude != nil {
		fields = append(fields, runway.FieldLowRunwayLongitude)
	}
	if m.addlow_runway_elevation != nil {
		fields = append(fields, runway.FieldLowRunwayElevation)
	}
	if m.addlow_runway_heading != nil {
		fields = append(fields, runway.FieldLowRunwayHeading)
	}
	if m.addlow_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldLowRunwayDisplacedThreshold)
	}
	if m.addhigh_runway_latitude != nil {
		fields = append(fields, runway.FieldHighRunwayLatitude)
	}
	if m.addhigh_runway_longitude != nil {
		fields = append(fields, runway.FieldHighRunwayLongitude)
	}
	if m.addhigh_runway_elevation != nil {
		fields = append(fields, runway.FieldHighRunwayElevation)
	}
	if m.addhigh_runway_heading != nil {
		fields = append(fields, runway.FieldHighRunwayHeading)
	}
	if m.addhigh_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldHighRunwayDisplacedThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RunwayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case runway.FieldLength:
		return m.AddedLength()
	case runway.FieldWidth:
		return m.AddedWidth()
	case runway.FieldLowRunwayLatitude:
		return m.AddedLowRunwayLatitude()
	case runway.FieldLowRunwayLongitude:
		return m.AddedLowRunwayLongitude()
	case runway.FieldLowRunwayElevation:
		return m.AddedLowRunwayElevation()
	case runway.FieldLowRunwayHeading:
		return m.AddedLowRunwayHeading()
	case runway.FieldLowRunwayDisplacedThreshold:
		return m.AddedLowRunwayDisplacedThreshold()
	case runway.FieldHighRunwayLatitude:
		return m.AddedHighRunwayLatitude()
	case runway.FieldHighRunwayLongitude:
		return m.AddedHighRunwayLongitude()
	case runway.FieldHighRunwayElevation:
		return m.AddedHighRunwayElevation()
	case runway.FieldHighRunwayHeading:
		return m.AddedHighRunwayHeading()
	case runway.FieldHighRunwayDisplacedThreshold:
		return m.AddedHighRunwayDisplacedThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunwayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case runway.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case runway.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case runway.FieldLowRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayLatitude(v)
		return nil
	case runway.FieldLowRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayLongitude(v)
		return nil
	case runway.FieldLowRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayElevation(v)
		return nil
	case runway.FieldLowRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayHeading(v)
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayDisplacedThreshold(v)
		return nil
	case runway.FieldHighRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayLatitude(v)
		return nil
	case runway.FieldHighRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayLongitude(v)
		return nil
	case runway.FieldHighRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayElevation(v)
		return nil
	case runway.FieldHighRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayHeading(v)
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayDisplacedThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown Runway numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RunwayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(runway.FieldSurface) {
		fields = append(fields, runway.FieldSurface)
	}
	if m.FieldCleared(runway.FieldLowRunwayLatitude) {
		fields = append(fields, runway.FieldLowRunwayLatitude)
	}
	if m.FieldCleared(runway.FieldLowRunwayLongitude) {
		fields = append(fields, runway.FieldLowRunwayLongitude)
	}
	if m.FieldCleared(runway.FieldLowRunwayElevation) {
		fields = append(fields, runway.FieldLowRunwayElevation)
	}
	if m.FieldCleared(runway.FieldLowRunwayHeading) {
		fields = append(fields, runway.FieldLowRunwayHeading)
	}
	if m.FieldCleared(runway.FieldLowRunwayDisplacedThreshold) {
		fields = append(fields, runway.FieldLowRunwayDisplacedThreshold)
	}
	if m.FieldCleared(runway.FieldHighRunwayLatitude) {
		fields = append(fields, runway.FieldHighRunwayLatitude)
	}
	if m.FieldCleared(runway.FieldHighRunwayLongitude) {
		fields = append(fields, runway.FieldHighRunwayLongitude)
	}
	if m.FieldCleared(runway.FieldHighRunwayElevation) {
		fields = append(fields, runway.FieldHighRunwayElevation)
	}
	if m.FieldCleared(runway.FieldHighRunwayHeading) {
		fields = append(fields, runway.FieldHighRunwayHeading)
	}
	if m.FieldCleared(runway.FieldHighRunwayDisplacedThreshold) {
		fields = append(fields, runway.FieldHighRunwayDisplacedThreshold)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RunwayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunwayMutation) ClearField(name string) error {
	switch name {
	case runway.FieldSurface:
		m.ClearSurface()
		return nil
	case runway.FieldLowRunwayLatitude:
		m.ClearLowRunwayLatitude()
		return nil
	case runway.FieldLowRunwayLongitude:
		m.ClearLowRunwayLongitude()
		return nil
	case runway.FieldLowRunwayElevation:
		m.ClearLowRunwayElevation()
		return nil
	case runway.FieldLowRunwayHeading:
		m.ClearLowRunwayHeading()
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		m.ClearLowRunwayDisplacedThreshold()
		return nil
	case runway.FieldHighRunwayLatitude:
		m.ClearHighRunwayLatitude()
		return nil
	case runway.FieldHighRunwayLongitude:
		m.ClearHighRunwayLongitude()
		return nil
	case runway.FieldHighRunwayElevation:
		m.ClearHighRunwayElevation()
		return nil
	case runway.FieldHighRunwayHeading:
		m.ClearHighRunwayHeading()
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		m.ClearHighRunwayDisplacedThreshold()
		return nil
	}
	return fmt.Errorf("unknown Runway nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RunwayMutation) ResetField(name string) error {
	switch name {
	case runway.FieldHash:
		m.ResetHash()
		return nil
	case runway.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case runway.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case runway.FieldLength:
		m.ResetLength()
		return nil
	case runway.FieldWidth:
		m.ResetWidth()
		return nil
	case runway.FieldSurface:
		m.ResetSurface()
		return nil
	case runway.FieldLighted:
		m.ResetLighted()
		return nil
	case runway.FieldClosed:
		m.ResetClosed()
		return nil
	case runway.FieldLowRunwayIdentifier:
		m.ResetLowRunwayIdentifier()
		return nil
	case runway.FieldLowRunwayLatitude:
		m.ResetLowRunwayLatitude()
		return nil
	case runway.FieldLowRunwayLongitude:
		m.ResetLowRunwayLongitude()
		return nil
	case runway.FieldLowRunwayElevation:
		m.ResetLowRunwayElevation()
		return nil
	case runway.FieldLowRunwayHeading:
		m.ResetLowRunwayHeading()
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		m.ResetLowRunwayDisplacedThreshold()
		return nil
	case runway.FieldHighRunwayIdentifier:
		m.ResetHighRunwayIdentifier()
		return nil
	case runway.FieldHighRunwayLatitude:
		m.ResetHighRunwayLatitude()
		return nil
	case runway.FieldHighRunwayLongitude:
		m.ResetHighRunwayLongitude()
		return nil
	case runway.FieldHighRunwayElevation:
		m.ResetHighRunwayElevation()
		return nil
	case runway.FieldHighRunwayHeading:
		m.ResetHighRunwayHeading()
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		m.ResetHighRunwayDisplacedThreshold()
		return nil
	}
	return fmt.Errorf("unknown Runway field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RunwayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.airport != nil {
		edges = append(edges, runway.EdgeAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RunwayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case runway.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RunwayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RunwayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RunwayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedairport {
		edges = append(edges, runway.EdgeAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RunwayMutation) EdgeCleared(name string) bool {
	switch name {
	case runway.EdgeAirport:
		return m.clearedairport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RunwayMutation) ClearEdge(name string) error {
	switch name {
	case runway.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown Runway unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RunwayMutation) ResetEdge(name string) error {
	switch name {
	case runway.EdgeAirport:
		m.ResetAirport()
		return nil
	}
	return fmt.Errorf("unknown Runway edge %s", name)
}

// SkyConditionMutation represents an operation that mutates the SkyCondition nodes in the graph.
type SkyConditionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	sky_cover     *skycondition.SkyCover
	cloud_base    *int
	addcloud_base *int
	clearedFields map[string]struct{}
	metar         *int
	clearedmetar  bool
	done          bool
	oldValue      func(context.Context) (*SkyCondition, error)
	predicates    []predicate.SkyCondition
}

var _ ent.Mutation = (*SkyConditionMutation)(nil)

// skyconditionOption allows management of the mutation configuration using functional options.
type skyconditionOption func(*SkyConditionMutation)

// newSkyConditionMutation creates new mutation for the SkyCondition entity.
func newSkyConditionMutation(c config, op Op, opts ...skyconditionOption) *SkyConditionMutation {
	m := &SkyConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeSkyCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkyConditionID sets the ID field of the mutation.
func withSkyConditionID(id int) skyconditionOption {
	return func(m *SkyConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *SkyCondition
		)
		m.oldValue = func(ctx context.Context) (*SkyCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkyCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkyCondition sets the old SkyCondition of the mutation.
func withSkyCondition(node *SkyCondition) skyconditionOption {
	return func(m *SkyConditionMutation) {
		m.oldValue = func(context.Context) (*SkyCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkyConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkyConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SkyCondition entities.
func (m *SkyConditionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkyConditionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkyConditionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SkyCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSkyCover sets the "sky_cover" field.
func (m *SkyConditionMutation) SetSkyCover(sc skycondition.SkyCover) {
	m.sky_cover = &sc
}

// SkyCover returns the value of the "sky_cover" field in the mutation.
func (m *SkyConditionMutation) SkyCover() (r skycondition.SkyCover, exists bool) {
	v := m.sky_cover
	if v == nil {
		return
	}
	return *v, true
}

// OldSkyCover returns the old "sky_cover" field's value of the SkyCondition entity.
// If the SkyCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkyConditionMutation) OldSkyCover(ctx context.Context) (v skycondition.SkyCover, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkyCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkyCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkyCover: %w", err)
	}
	return oldValue.SkyCover, nil
}

// ResetSkyCover resets all changes to the "sky_cover" field.
func (m *SkyConditionMutation) ResetSkyCover() {
	m.sky_cover = nil
}

// SetCloudBase sets the "cloud_base" field.
func (m *SkyConditionMutation) SetCloudBase(i int) {
	m.cloud_base = &i
	m.addcloud_base = nil
}

// CloudBase returns the value of the "cloud_base" field in the mutation.
func (m *SkyConditionMutation) CloudBase() (r int, exists bool) {
	v := m.cloud_base
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudBase returns the old "cloud_base" field's value of the SkyCondition entity.
// If the SkyCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkyConditionMutation) OldCloudBase(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudBase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudBase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudBase: %w", err)
	}
	return oldValue.CloudBase, nil
}

// AddCloudBase adds i to the "cloud_base" field.
func (m *SkyConditionMutation) AddCloudBase(i int) {
	if m.addcloud_base != nil {
		*m.addcloud_base += i
	} else {
		m.addcloud_base = &i
	}
}

// AddedCloudBase returns the value that was added to the "cloud_base" field in this mutation.
func (m *SkyConditionMutation) AddedCloudBase() (r int, exists bool) {
	v := m.addcloud_base
	if v == nil {
		return
	}
	return *v, true
}

// ClearCloudBase clears the value of the "cloud_base" field.
func (m *SkyConditionMutation) ClearCloudBase() {
	m.cloud_base = nil
	m.addcloud_base = nil
	m.clearedFields[skycondition.FieldCloudBase] = struct{}{}
}

// CloudBaseCleared returns if the "cloud_base" field was cleared in this mutation.
func (m *SkyConditionMutation) CloudBaseCleared() bool {
	_, ok := m.clearedFields[skycondition.FieldCloudBase]
	return ok
}

// ResetCloudBase resets all changes to the "cloud_base" field.
func (m *SkyConditionMutation) ResetCloudBase() {
	m.cloud_base = nil
	m.addcloud_base = nil
	delete(m.clearedFields, skycondition.FieldCloudBase)
}

// SetMetarID sets the "metar" edge to the Metar entity by id.
func (m *SkyConditionMutation) SetMetarID(id int) {
	m.metar = &id
}

// ClearMetar clears the "metar" edge to the Metar entity.
func (m *SkyConditionMutation) ClearMetar() {
	m.clearedmetar = true
}

// MetarCleared reports if the "metar" edge to the Metar entity was cleared.
func (m *SkyConditionMutation) MetarCleared() bool {
	return m.clearedmetar
}

// MetarID returns the "metar" edge ID in the mutation.
func (m *SkyConditionMutation) MetarID() (id int, exists bool) {
	if m.metar != nil {
		return *m.metar, true
	}
	return
}

// MetarIDs returns the "metar" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetarID instead. It exists only for internal usage by the builders.
func (m *SkyConditionMutation) MetarIDs() (ids []int) {
	if id := m.metar; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetar resets all changes to the "metar" edge.
func (m *SkyConditionMutation) ResetMetar() {
	m.metar = nil
	m.clearedmetar = false
}

// Where appends a list predicates to the SkyConditionMutation builder.
func (m *SkyConditionMutation) Where(ps ...predicate.SkyCondition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkyConditionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SkyCondition).
func (m *SkyConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkyConditionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.sky_cover != nil {
		fields = append(fields, skycondition.FieldSkyCover)
	}
	if m.cloud_base != nil {
		fields = append(fields, skycondition.FieldCloudBase)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkyConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skycondition.FieldSkyCover:
		return m.SkyCover()
	case skycondition.FieldCloudBase:
		return m.CloudBase()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkyConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skycondition.FieldSkyCover:
		return m.OldSkyCover(ctx)
	case skycondition.FieldCloudBase:
		return m.OldCloudBase(ctx)
	}
	return nil, fmt.Errorf("unknown SkyCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkyConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skycondition.FieldSkyCover:
		v, ok := value.(skycondition.SkyCover)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkyCover(v)
		return nil
	case skycondition.FieldCloudBase:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudBase(v)
		return nil
	}
	return fmt.Errorf("unknown SkyCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkyConditionMutation) AddedFields() []string {
	var fields []string
	if m.addcloud_base != nil {
		fields = append(fields, skycondition.FieldCloudBase)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkyConditionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case skycondition.FieldCloudBase:
		return m.AddedCloudBase()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkyConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case skycondition.FieldCloudBase:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCloudBase(v)
		return nil
	}
	return fmt.Errorf("unknown SkyCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkyConditionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skycondition.FieldCloudBase) {
		fields = append(fields, skycondition.FieldCloudBase)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkyConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkyConditionMutation) ClearField(name string) error {
	switch name {
	case skycondition.FieldCloudBase:
		m.ClearCloudBase()
		return nil
	}
	return fmt.Errorf("unknown SkyCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkyConditionMutation) ResetField(name string) error {
	switch name {
	case skycondition.FieldSkyCover:
		m.ResetSkyCover()
		return nil
	case skycondition.FieldCloudBase:
		m.ResetCloudBase()
		return nil
	}
	return fmt.Errorf("unknown SkyCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkyConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metar != nil {
		edges = append(edges, skycondition.EdgeMetar)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkyConditionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skycondition.EdgeMetar:
		if id := m.metar; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkyConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkyConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkyConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetar {
		edges = append(edges, skycondition.EdgeMetar)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkyConditionMutation) EdgeCleared(name string) bool {
	switch name {
	case skycondition.EdgeMetar:
		return m.clearedmetar
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkyConditionMutation) ClearEdge(name string) error {
	switch name {
	case skycondition.EdgeMetar:
		m.ClearMetar()
		return nil
	}
	return fmt.Errorf("unknown SkyCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkyConditionMutation) ResetEdge(name string) error {
	switch name {
	case skycondition.EdgeMetar:
		m.ResetMetar()
		return nil
	}
	return fmt.Errorf("unknown SkyCondition edge %s", name)
}
