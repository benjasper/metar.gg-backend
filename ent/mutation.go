// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"metar.gg/ent/airport"
	"metar.gg/ent/country"
	"metar.gg/ent/forecast"
	"metar.gg/ent/frequency"
	"metar.gg/ent/icingcondition"
	"metar.gg/ent/metar"
	"metar.gg/ent/predicate"
	"metar.gg/ent/region"
	"metar.gg/ent/runway"
	"metar.gg/ent/skycondition"
	"metar.gg/ent/taf"
	"metar.gg/ent/temperaturedata"
	"metar.gg/ent/turbulencecondition"
	"metar.gg/ent/weatherstation"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAirport             = "Airport"
	TypeCountry             = "Country"
	TypeForecast            = "Forecast"
	TypeFrequency           = "Frequency"
	TypeIcingCondition      = "IcingCondition"
	TypeMetar               = "Metar"
	TypeRegion              = "Region"
	TypeRunway              = "Runway"
	TypeSkyCondition        = "SkyCondition"
	TypeTaf                 = "Taf"
	TypeTemperatureData     = "TemperatureData"
	TypeTurbulenceCondition = "TurbulenceCondition"
	TypeWeatherStation      = "WeatherStation"
)

// AirportMutation represents an operation that mutates the Airport nodes in the graph.
type AirportMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	import_id          *int
	addimport_id       *int
	hash               *string
	import_flag        *bool
	last_updated       *time.Time
	icao_code          *string
	iata_code          *string
	identifier         *string
	_type              *airport.Type
	importance         *int
	addimportance      *int
	name               *string
	latitude           *float64
	addlatitude        *float64
	longitude          *float64
	addlongitude       *float64
	timezone           *string
	elevation          *int
	addelevation       *int
	municipality       *string
	scheduled_service  *bool
	gps_code           *string
	local_code         *string
	website            *string
	wikipedia          *string
	keywords           *[]string
	appendkeywords     []string
	clearedFields      map[string]struct{}
	region             *uuid.UUID
	clearedregion      bool
	country            *uuid.UUID
	clearedcountry     bool
	runways            map[uuid.UUID]struct{}
	removedrunways     map[uuid.UUID]struct{}
	clearedrunways     bool
	frequencies        map[uuid.UUID]struct{}
	removedfrequencies map[uuid.UUID]struct{}
	clearedfrequencies bool
	station            *uuid.UUID
	clearedstation     bool
	done               bool
	oldValue           func(context.Context) (*Airport, error)
	predicates         []predicate.Airport
}

var _ ent.Mutation = (*AirportMutation)(nil)

// airportOption allows management of the mutation configuration using functional options.
type airportOption func(*AirportMutation)

// newAirportMutation creates new mutation for the Airport entity.
func newAirportMutation(c config, op Op, opts ...airportOption) *AirportMutation {
	m := &AirportMutation{
		config:        c,
		op:            op,
		typ:           TypeAirport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirportID sets the ID field of the mutation.
func withAirportID(id uuid.UUID) airportOption {
	return func(m *AirportMutation) {
		var (
			err   error
			once  sync.Once
			value *Airport
		)
		m.oldValue = func(ctx context.Context) (*Airport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirport sets the old Airport of the mutation.
func withAirport(node *Airport) airportOption {
	return func(m *AirportMutation) {
		m.oldValue = func(context.Context) (*Airport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Airport entities.
func (m *AirportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImportID sets the "import_id" field.
func (m *AirportMutation) SetImportID(i int) {
	m.import_id = &i
	m.addimport_id = nil
}

// ImportID returns the value of the "import_id" field in the mutation.
func (m *AirportMutation) ImportID() (r int, exists bool) {
	v := m.import_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImportID returns the old "import_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldImportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportID: %w", err)
	}
	return oldValue.ImportID, nil
}

// AddImportID adds i to the "import_id" field.
func (m *AirportMutation) AddImportID(i int) {
	if m.addimport_id != nil {
		*m.addimport_id += i
	} else {
		m.addimport_id = &i
	}
}

// AddedImportID returns the value that was added to the "import_id" field in this mutation.
func (m *AirportMutation) AddedImportID() (r int, exists bool) {
	v := m.addimport_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetImportID resets all changes to the "import_id" field.
func (m *AirportMutation) ResetImportID() {
	m.import_id = nil
	m.addimport_id = nil
}

// SetHash sets the "hash" field.
func (m *AirportMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *AirportMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *AirportMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *AirportMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *AirportMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *AirportMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *AirportMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *AirportMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *AirportMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetIcaoCode sets the "icao_code" field.
func (m *AirportMutation) SetIcaoCode(s string) {
	m.icao_code = &s
}

// IcaoCode returns the value of the "icao_code" field in the mutation.
func (m *AirportMutation) IcaoCode() (r string, exists bool) {
	v := m.icao_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIcaoCode returns the old "icao_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldIcaoCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcaoCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcaoCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcaoCode: %w", err)
	}
	return oldValue.IcaoCode, nil
}

// ClearIcaoCode clears the value of the "icao_code" field.
func (m *AirportMutation) ClearIcaoCode() {
	m.icao_code = nil
	m.clearedFields[airport.FieldIcaoCode] = struct{}{}
}

// IcaoCodeCleared returns if the "icao_code" field was cleared in this mutation.
func (m *AirportMutation) IcaoCodeCleared() bool {
	_, ok := m.clearedFields[airport.FieldIcaoCode]
	return ok
}

// ResetIcaoCode resets all changes to the "icao_code" field.
func (m *AirportMutation) ResetIcaoCode() {
	m.icao_code = nil
	delete(m.clearedFields, airport.FieldIcaoCode)
}

// SetIataCode sets the "iata_code" field.
func (m *AirportMutation) SetIataCode(s string) {
	m.iata_code = &s
}

// IataCode returns the value of the "iata_code" field in the mutation.
func (m *AirportMutation) IataCode() (r string, exists bool) {
	v := m.iata_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIataCode returns the old "iata_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldIataCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIataCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIataCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIataCode: %w", err)
	}
	return oldValue.IataCode, nil
}

// ClearIataCode clears the value of the "iata_code" field.
func (m *AirportMutation) ClearIataCode() {
	m.iata_code = nil
	m.clearedFields[airport.FieldIataCode] = struct{}{}
}

// IataCodeCleared returns if the "iata_code" field was cleared in this mutation.
func (m *AirportMutation) IataCodeCleared() bool {
	_, ok := m.clearedFields[airport.FieldIataCode]
	return ok
}

// ResetIataCode resets all changes to the "iata_code" field.
func (m *AirportMutation) ResetIataCode() {
	m.iata_code = nil
	delete(m.clearedFields, airport.FieldIataCode)
}

// SetIdentifier sets the "identifier" field.
func (m *AirportMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *AirportMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *AirportMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetType sets the "type" field.
func (m *AirportMutation) SetType(a airport.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AirportMutation) GetType() (r airport.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldType(ctx context.Context) (v airport.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AirportMutation) ResetType() {
	m._type = nil
}

// SetImportance sets the "importance" field.
func (m *AirportMutation) SetImportance(i int) {
	m.importance = &i
	m.addimportance = nil
}

// Importance returns the value of the "importance" field in the mutation.
func (m *AirportMutation) Importance() (r int, exists bool) {
	v := m.importance
	if v == nil {
		return
	}
	return *v, true
}

// OldImportance returns the old "importance" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldImportance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportance: %w", err)
	}
	return oldValue.Importance, nil
}

// AddImportance adds i to the "importance" field.
func (m *AirportMutation) AddImportance(i int) {
	if m.addimportance != nil {
		*m.addimportance += i
	} else {
		m.addimportance = &i
	}
}

// AddedImportance returns the value that was added to the "importance" field in this mutation.
func (m *AirportMutation) AddedImportance() (r int, exists bool) {
	v := m.addimportance
	if v == nil {
		return
	}
	return *v, true
}

// ResetImportance resets all changes to the "importance" field.
func (m *AirportMutation) ResetImportance() {
	m.importance = nil
	m.addimportance = nil
}

// SetName sets the "name" field.
func (m *AirportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirportMutation) ResetName() {
	m.name = nil
}

// SetLatitude sets the "latitude" field.
func (m *AirportMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *AirportMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *AirportMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *AirportMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *AirportMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *AirportMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *AirportMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *AirportMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *AirportMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *AirportMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetTimezone sets the "timezone" field.
func (m *AirportMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *AirportMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldTimezone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *AirportMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[airport.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *AirportMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[airport.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *AirportMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, airport.FieldTimezone)
}

// SetElevation sets the "elevation" field.
func (m *AirportMutation) SetElevation(i int) {
	m.elevation = &i
	m.addelevation = nil
}

// Elevation returns the value of the "elevation" field in the mutation.
func (m *AirportMutation) Elevation() (r int, exists bool) {
	v := m.elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldElevation returns the old "elevation" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldElevation(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElevation: %w", err)
	}
	return oldValue.Elevation, nil
}

// AddElevation adds i to the "elevation" field.
func (m *AirportMutation) AddElevation(i int) {
	if m.addelevation != nil {
		*m.addelevation += i
	} else {
		m.addelevation = &i
	}
}

// AddedElevation returns the value that was added to the "elevation" field in this mutation.
func (m *AirportMutation) AddedElevation() (r int, exists bool) {
	v := m.addelevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearElevation clears the value of the "elevation" field.
func (m *AirportMutation) ClearElevation() {
	m.elevation = nil
	m.addelevation = nil
	m.clearedFields[airport.FieldElevation] = struct{}{}
}

// ElevationCleared returns if the "elevation" field was cleared in this mutation.
func (m *AirportMutation) ElevationCleared() bool {
	_, ok := m.clearedFields[airport.FieldElevation]
	return ok
}

// ResetElevation resets all changes to the "elevation" field.
func (m *AirportMutation) ResetElevation() {
	m.elevation = nil
	m.addelevation = nil
	delete(m.clearedFields, airport.FieldElevation)
}

// SetMunicipality sets the "municipality" field.
func (m *AirportMutation) SetMunicipality(s string) {
	m.municipality = &s
}

// Municipality returns the value of the "municipality" field in the mutation.
func (m *AirportMutation) Municipality() (r string, exists bool) {
	v := m.municipality
	if v == nil {
		return
	}
	return *v, true
}

// OldMunicipality returns the old "municipality" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldMunicipality(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMunicipality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMunicipality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMunicipality: %w", err)
	}
	return oldValue.Municipality, nil
}

// ClearMunicipality clears the value of the "municipality" field.
func (m *AirportMutation) ClearMunicipality() {
	m.municipality = nil
	m.clearedFields[airport.FieldMunicipality] = struct{}{}
}

// MunicipalityCleared returns if the "municipality" field was cleared in this mutation.
func (m *AirportMutation) MunicipalityCleared() bool {
	_, ok := m.clearedFields[airport.FieldMunicipality]
	return ok
}

// ResetMunicipality resets all changes to the "municipality" field.
func (m *AirportMutation) ResetMunicipality() {
	m.municipality = nil
	delete(m.clearedFields, airport.FieldMunicipality)
}

// SetScheduledService sets the "scheduled_service" field.
func (m *AirportMutation) SetScheduledService(b bool) {
	m.scheduled_service = &b
}

// ScheduledService returns the value of the "scheduled_service" field in the mutation.
func (m *AirportMutation) ScheduledService() (r bool, exists bool) {
	v := m.scheduled_service
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledService returns the old "scheduled_service" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldScheduledService(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledService: %w", err)
	}
	return oldValue.ScheduledService, nil
}

// ResetScheduledService resets all changes to the "scheduled_service" field.
func (m *AirportMutation) ResetScheduledService() {
	m.scheduled_service = nil
}

// SetGpsCode sets the "gps_code" field.
func (m *AirportMutation) SetGpsCode(s string) {
	m.gps_code = &s
}

// GpsCode returns the value of the "gps_code" field in the mutation.
func (m *AirportMutation) GpsCode() (r string, exists bool) {
	v := m.gps_code
	if v == nil {
		return
	}
	return *v, true
}

// OldGpsCode returns the old "gps_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldGpsCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpsCode: %w", err)
	}
	return oldValue.GpsCode, nil
}

// ClearGpsCode clears the value of the "gps_code" field.
func (m *AirportMutation) ClearGpsCode() {
	m.gps_code = nil
	m.clearedFields[airport.FieldGpsCode] = struct{}{}
}

// GpsCodeCleared returns if the "gps_code" field was cleared in this mutation.
func (m *AirportMutation) GpsCodeCleared() bool {
	_, ok := m.clearedFields[airport.FieldGpsCode]
	return ok
}

// ResetGpsCode resets all changes to the "gps_code" field.
func (m *AirportMutation) ResetGpsCode() {
	m.gps_code = nil
	delete(m.clearedFields, airport.FieldGpsCode)
}

// SetLocalCode sets the "local_code" field.
func (m *AirportMutation) SetLocalCode(s string) {
	m.local_code = &s
}

// LocalCode returns the value of the "local_code" field in the mutation.
func (m *AirportMutation) LocalCode() (r string, exists bool) {
	v := m.local_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalCode returns the old "local_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLocalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalCode: %w", err)
	}
	return oldValue.LocalCode, nil
}

// ClearLocalCode clears the value of the "local_code" field.
func (m *AirportMutation) ClearLocalCode() {
	m.local_code = nil
	m.clearedFields[airport.FieldLocalCode] = struct{}{}
}

// LocalCodeCleared returns if the "local_code" field was cleared in this mutation.
func (m *AirportMutation) LocalCodeCleared() bool {
	_, ok := m.clearedFields[airport.FieldLocalCode]
	return ok
}

// ResetLocalCode resets all changes to the "local_code" field.
func (m *AirportMutation) ResetLocalCode() {
	m.local_code = nil
	delete(m.clearedFields, airport.FieldLocalCode)
}

// SetWebsite sets the "website" field.
func (m *AirportMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *AirportMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *AirportMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[airport.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *AirportMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[airport.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *AirportMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, airport.FieldWebsite)
}

// SetWikipedia sets the "wikipedia" field.
func (m *AirportMutation) SetWikipedia(s string) {
	m.wikipedia = &s
}

// Wikipedia returns the value of the "wikipedia" field in the mutation.
func (m *AirportMutation) Wikipedia() (r string, exists bool) {
	v := m.wikipedia
	if v == nil {
		return
	}
	return *v, true
}

// OldWikipedia returns the old "wikipedia" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldWikipedia(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWikipedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWikipedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWikipedia: %w", err)
	}
	return oldValue.Wikipedia, nil
}

// ClearWikipedia clears the value of the "wikipedia" field.
func (m *AirportMutation) ClearWikipedia() {
	m.wikipedia = nil
	m.clearedFields[airport.FieldWikipedia] = struct{}{}
}

// WikipediaCleared returns if the "wikipedia" field was cleared in this mutation.
func (m *AirportMutation) WikipediaCleared() bool {
	_, ok := m.clearedFields[airport.FieldWikipedia]
	return ok
}

// ResetWikipedia resets all changes to the "wikipedia" field.
func (m *AirportMutation) ResetWikipedia() {
	m.wikipedia = nil
	delete(m.clearedFields, airport.FieldWikipedia)
}

// SetKeywords sets the "keywords" field.
func (m *AirportMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *AirportMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *AirportMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *AirportMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *AirportMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *AirportMutation) SetRegionID(id uuid.UUID) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *AirportMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *AirportMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *AirportMutation) RegionID() (id uuid.UUID, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *AirportMutation) RegionIDs() (ids []uuid.UUID) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *AirportMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *AirportMutation) SetCountryID(id uuid.UUID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *AirportMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *AirportMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *AirportMutation) CountryID() (id uuid.UUID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *AirportMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *AirportMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddRunwayIDs adds the "runways" edge to the Runway entity by ids.
func (m *AirportMutation) AddRunwayIDs(ids ...uuid.UUID) {
	if m.runways == nil {
		m.runways = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.runways[ids[i]] = struct{}{}
	}
}

// ClearRunways clears the "runways" edge to the Runway entity.
func (m *AirportMutation) ClearRunways() {
	m.clearedrunways = true
}

// RunwaysCleared reports if the "runways" edge to the Runway entity was cleared.
func (m *AirportMutation) RunwaysCleared() bool {
	return m.clearedrunways
}

// RemoveRunwayIDs removes the "runways" edge to the Runway entity by IDs.
func (m *AirportMutation) RemoveRunwayIDs(ids ...uuid.UUID) {
	if m.removedrunways == nil {
		m.removedrunways = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.runways, ids[i])
		m.removedrunways[ids[i]] = struct{}{}
	}
}

// RemovedRunways returns the removed IDs of the "runways" edge to the Runway entity.
func (m *AirportMutation) RemovedRunwaysIDs() (ids []uuid.UUID) {
	for id := range m.removedrunways {
		ids = append(ids, id)
	}
	return
}

// RunwaysIDs returns the "runways" edge IDs in the mutation.
func (m *AirportMutation) RunwaysIDs() (ids []uuid.UUID) {
	for id := range m.runways {
		ids = append(ids, id)
	}
	return
}

// ResetRunways resets all changes to the "runways" edge.
func (m *AirportMutation) ResetRunways() {
	m.runways = nil
	m.clearedrunways = false
	m.removedrunways = nil
}

// AddFrequencyIDs adds the "frequencies" edge to the Frequency entity by ids.
func (m *AirportMutation) AddFrequencyIDs(ids ...uuid.UUID) {
	if m.frequencies == nil {
		m.frequencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.frequencies[ids[i]] = struct{}{}
	}
}

// ClearFrequencies clears the "frequencies" edge to the Frequency entity.
func (m *AirportMutation) ClearFrequencies() {
	m.clearedfrequencies = true
}

// FrequenciesCleared reports if the "frequencies" edge to the Frequency entity was cleared.
func (m *AirportMutation) FrequenciesCleared() bool {
	return m.clearedfrequencies
}

// RemoveFrequencyIDs removes the "frequencies" edge to the Frequency entity by IDs.
func (m *AirportMutation) RemoveFrequencyIDs(ids ...uuid.UUID) {
	if m.removedfrequencies == nil {
		m.removedfrequencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.frequencies, ids[i])
		m.removedfrequencies[ids[i]] = struct{}{}
	}
}

// RemovedFrequencies returns the removed IDs of the "frequencies" edge to the Frequency entity.
func (m *AirportMutation) RemovedFrequenciesIDs() (ids []uuid.UUID) {
	for id := range m.removedfrequencies {
		ids = append(ids, id)
	}
	return
}

// FrequenciesIDs returns the "frequencies" edge IDs in the mutation.
func (m *AirportMutation) FrequenciesIDs() (ids []uuid.UUID) {
	for id := range m.frequencies {
		ids = append(ids, id)
	}
	return
}

// ResetFrequencies resets all changes to the "frequencies" edge.
func (m *AirportMutation) ResetFrequencies() {
	m.frequencies = nil
	m.clearedfrequencies = false
	m.removedfrequencies = nil
}

// SetStationID sets the "station" edge to the WeatherStation entity by id.
func (m *AirportMutation) SetStationID(id uuid.UUID) {
	m.station = &id
}

// ClearStation clears the "station" edge to the WeatherStation entity.
func (m *AirportMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the WeatherStation entity was cleared.
func (m *AirportMutation) StationCleared() bool {
	return m.clearedstation
}

// StationID returns the "station" edge ID in the mutation.
func (m *AirportMutation) StationID() (id uuid.UUID, exists bool) {
	if m.station != nil {
		return *m.station, true
	}
	return
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *AirportMutation) StationIDs() (ids []uuid.UUID) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *AirportMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// Where appends a list predicates to the AirportMutation builder.
func (m *AirportMutation) Where(ps ...predicate.Airport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AirportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AirportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Airport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AirportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AirportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Airport).
func (m *AirportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirportMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.import_id != nil {
		fields = append(fields, airport.FieldImportID)
	}
	if m.hash != nil {
		fields = append(fields, airport.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, airport.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, airport.FieldLastUpdated)
	}
	if m.icao_code != nil {
		fields = append(fields, airport.FieldIcaoCode)
	}
	if m.iata_code != nil {
		fields = append(fields, airport.FieldIataCode)
	}
	if m.identifier != nil {
		fields = append(fields, airport.FieldIdentifier)
	}
	if m._type != nil {
		fields = append(fields, airport.FieldType)
	}
	if m.importance != nil {
		fields = append(fields, airport.FieldImportance)
	}
	if m.name != nil {
		fields = append(fields, airport.FieldName)
	}
	if m.latitude != nil {
		fields = append(fields, airport.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, airport.FieldLongitude)
	}
	if m.timezone != nil {
		fields = append(fields, airport.FieldTimezone)
	}
	if m.elevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	if m.municipality != nil {
		fields = append(fields, airport.FieldMunicipality)
	}
	if m.scheduled_service != nil {
		fields = append(fields, airport.FieldScheduledService)
	}
	if m.gps_code != nil {
		fields = append(fields, airport.FieldGpsCode)
	}
	if m.local_code != nil {
		fields = append(fields, airport.FieldLocalCode)
	}
	if m.website != nil {
		fields = append(fields, airport.FieldWebsite)
	}
	if m.wikipedia != nil {
		fields = append(fields, airport.FieldWikipedia)
	}
	if m.keywords != nil {
		fields = append(fields, airport.FieldKeywords)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldImportID:
		return m.ImportID()
	case airport.FieldHash:
		return m.Hash()
	case airport.FieldImportFlag:
		return m.ImportFlag()
	case airport.FieldLastUpdated:
		return m.LastUpdated()
	case airport.FieldIcaoCode:
		return m.IcaoCode()
	case airport.FieldIataCode:
		return m.IataCode()
	case airport.FieldIdentifier:
		return m.Identifier()
	case airport.FieldType:
		return m.GetType()
	case airport.FieldImportance:
		return m.Importance()
	case airport.FieldName:
		return m.Name()
	case airport.FieldLatitude:
		return m.Latitude()
	case airport.FieldLongitude:
		return m.Longitude()
	case airport.FieldTimezone:
		return m.Timezone()
	case airport.FieldElevation:
		return m.Elevation()
	case airport.FieldMunicipality:
		return m.Municipality()
	case airport.FieldScheduledService:
		return m.ScheduledService()
	case airport.FieldGpsCode:
		return m.GpsCode()
	case airport.FieldLocalCode:
		return m.LocalCode()
	case airport.FieldWebsite:
		return m.Website()
	case airport.FieldWikipedia:
		return m.Wikipedia()
	case airport.FieldKeywords:
		return m.Keywords()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airport.FieldImportID:
		return m.OldImportID(ctx)
	case airport.FieldHash:
		return m.OldHash(ctx)
	case airport.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case airport.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case airport.FieldIcaoCode:
		return m.OldIcaoCode(ctx)
	case airport.FieldIataCode:
		return m.OldIataCode(ctx)
	case airport.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case airport.FieldType:
		return m.OldType(ctx)
	case airport.FieldImportance:
		return m.OldImportance(ctx)
	case airport.FieldName:
		return m.OldName(ctx)
	case airport.FieldLatitude:
		return m.OldLatitude(ctx)
	case airport.FieldLongitude:
		return m.OldLongitude(ctx)
	case airport.FieldTimezone:
		return m.OldTimezone(ctx)
	case airport.FieldElevation:
		return m.OldElevation(ctx)
	case airport.FieldMunicipality:
		return m.OldMunicipality(ctx)
	case airport.FieldScheduledService:
		return m.OldScheduledService(ctx)
	case airport.FieldGpsCode:
		return m.OldGpsCode(ctx)
	case airport.FieldLocalCode:
		return m.OldLocalCode(ctx)
	case airport.FieldWebsite:
		return m.OldWebsite(ctx)
	case airport.FieldWikipedia:
		return m.OldWikipedia(ctx)
	case airport.FieldKeywords:
		return m.OldKeywords(ctx)
	}
	return nil, fmt.Errorf("unknown Airport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airport.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportID(v)
		return nil
	case airport.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case airport.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case airport.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case airport.FieldIcaoCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcaoCode(v)
		return nil
	case airport.FieldIataCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIataCode(v)
		return nil
	case airport.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case airport.FieldType:
		v, ok := value.(airport.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case airport.FieldImportance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportance(v)
		return nil
	case airport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airport.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case airport.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case airport.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case airport.FieldElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElevation(v)
		return nil
	case airport.FieldMunicipality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMunicipality(v)
		return nil
	case airport.FieldScheduledService:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledService(v)
		return nil
	case airport.FieldGpsCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpsCode(v)
		return nil
	case airport.FieldLocalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalCode(v)
		return nil
	case airport.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case airport.FieldWikipedia:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWikipedia(v)
		return nil
	case airport.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirportMutation) AddedFields() []string {
	var fields []string
	if m.addimport_id != nil {
		fields = append(fields, airport.FieldImportID)
	}
	if m.addimportance != nil {
		fields = append(fields, airport.FieldImportance)
	}
	if m.addlatitude != nil {
		fields = append(fields, airport.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, airport.FieldLongitude)
	}
	if m.addelevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldImportID:
		return m.AddedImportID()
	case airport.FieldImportance:
		return m.AddedImportance()
	case airport.FieldLatitude:
		return m.AddedLatitude()
	case airport.FieldLongitude:
		return m.AddedLongitude()
	case airport.FieldElevation:
		return m.AddedElevation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case airport.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportID(v)
		return nil
	case airport.FieldImportance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportance(v)
		return nil
	case airport.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case airport.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case airport.FieldElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElevation(v)
		return nil
	}
	return fmt.Errorf("unknown Airport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(airport.FieldIcaoCode) {
		fields = append(fields, airport.FieldIcaoCode)
	}
	if m.FieldCleared(airport.FieldIataCode) {
		fields = append(fields, airport.FieldIataCode)
	}
	if m.FieldCleared(airport.FieldTimezone) {
		fields = append(fields, airport.FieldTimezone)
	}
	if m.FieldCleared(airport.FieldElevation) {
		fields = append(fields, airport.FieldElevation)
	}
	if m.FieldCleared(airport.FieldMunicipality) {
		fields = append(fields, airport.FieldMunicipality)
	}
	if m.FieldCleared(airport.FieldGpsCode) {
		fields = append(fields, airport.FieldGpsCode)
	}
	if m.FieldCleared(airport.FieldLocalCode) {
		fields = append(fields, airport.FieldLocalCode)
	}
	if m.FieldCleared(airport.FieldWebsite) {
		fields = append(fields, airport.FieldWebsite)
	}
	if m.FieldCleared(airport.FieldWikipedia) {
		fields = append(fields, airport.FieldWikipedia)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirportMutation) ClearField(name string) error {
	switch name {
	case airport.FieldIcaoCode:
		m.ClearIcaoCode()
		return nil
	case airport.FieldIataCode:
		m.ClearIataCode()
		return nil
	case airport.FieldTimezone:
		m.ClearTimezone()
		return nil
	case airport.FieldElevation:
		m.ClearElevation()
		return nil
	case airport.FieldMunicipality:
		m.ClearMunicipality()
		return nil
	case airport.FieldGpsCode:
		m.ClearGpsCode()
		return nil
	case airport.FieldLocalCode:
		m.ClearLocalCode()
		return nil
	case airport.FieldWebsite:
		m.ClearWebsite()
		return nil
	case airport.FieldWikipedia:
		m.ClearWikipedia()
		return nil
	}
	return fmt.Errorf("unknown Airport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirportMutation) ResetField(name string) error {
	switch name {
	case airport.FieldImportID:
		m.ResetImportID()
		return nil
	case airport.FieldHash:
		m.ResetHash()
		return nil
	case airport.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case airport.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case airport.FieldIcaoCode:
		m.ResetIcaoCode()
		return nil
	case airport.FieldIataCode:
		m.ResetIataCode()
		return nil
	case airport.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case airport.FieldType:
		m.ResetType()
		return nil
	case airport.FieldImportance:
		m.ResetImportance()
		return nil
	case airport.FieldName:
		m.ResetName()
		return nil
	case airport.FieldLatitude:
		m.ResetLatitude()
		return nil
	case airport.FieldLongitude:
		m.ResetLongitude()
		return nil
	case airport.FieldTimezone:
		m.ResetTimezone()
		return nil
	case airport.FieldElevation:
		m.ResetElevation()
		return nil
	case airport.FieldMunicipality:
		m.ResetMunicipality()
		return nil
	case airport.FieldScheduledService:
		m.ResetScheduledService()
		return nil
	case airport.FieldGpsCode:
		m.ResetGpsCode()
		return nil
	case airport.FieldLocalCode:
		m.ResetLocalCode()
		return nil
	case airport.FieldWebsite:
		m.ResetWebsite()
		return nil
	case airport.FieldWikipedia:
		m.ResetWikipedia()
		return nil
	case airport.FieldKeywords:
		m.ResetKeywords()
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirportMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.region != nil {
		edges = append(edges, airport.EdgeRegion)
	}
	if m.country != nil {
		edges = append(edges, airport.EdgeCountry)
	}
	if m.runways != nil {
		edges = append(edges, airport.EdgeRunways)
	}
	if m.frequencies != nil {
		edges = append(edges, airport.EdgeFrequencies)
	}
	if m.station != nil {
		edges = append(edges, airport.EdgeStation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	case airport.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case airport.EdgeRunways:
		ids := make([]ent.Value, 0, len(m.runways))
		for id := range m.runways {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeFrequencies:
		ids := make([]ent.Value, 0, len(m.frequencies))
		for id := range m.frequencies {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrunways != nil {
		edges = append(edges, airport.EdgeRunways)
	}
	if m.removedfrequencies != nil {
		edges = append(edges, airport.EdgeFrequencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeRunways:
		ids := make([]ent.Value, 0, len(m.removedrunways))
		for id := range m.removedrunways {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeFrequencies:
		ids := make([]ent.Value, 0, len(m.removedfrequencies))
		for id := range m.removedfrequencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedregion {
		edges = append(edges, airport.EdgeRegion)
	}
	if m.clearedcountry {
		edges = append(edges, airport.EdgeCountry)
	}
	if m.clearedrunways {
		edges = append(edges, airport.EdgeRunways)
	}
	if m.clearedfrequencies {
		edges = append(edges, airport.EdgeFrequencies)
	}
	if m.clearedstation {
		edges = append(edges, airport.EdgeStation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirportMutation) EdgeCleared(name string) bool {
	switch name {
	case airport.EdgeRegion:
		return m.clearedregion
	case airport.EdgeCountry:
		return m.clearedcountry
	case airport.EdgeRunways:
		return m.clearedrunways
	case airport.EdgeFrequencies:
		return m.clearedfrequencies
	case airport.EdgeStation:
		return m.clearedstation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirportMutation) ClearEdge(name string) error {
	switch name {
	case airport.EdgeRegion:
		m.ClearRegion()
		return nil
	case airport.EdgeCountry:
		m.ClearCountry()
		return nil
	case airport.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Airport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirportMutation) ResetEdge(name string) error {
	switch name {
	case airport.EdgeRegion:
		m.ResetRegion()
		return nil
	case airport.EdgeCountry:
		m.ResetCountry()
		return nil
	case airport.EdgeRunways:
		m.ResetRunways()
		return nil
	case airport.EdgeFrequencies:
		m.ResetFrequencies()
		return nil
	case airport.EdgeStation:
		m.ResetStation()
		return nil
	}
	return fmt.Errorf("unknown Airport edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	import_id       *int
	addimport_id    *int
	hash            *string
	import_flag     *bool
	last_updated    *time.Time
	code            *string
	name            *string
	continent       *country.Continent
	wikipedia_link  *string
	keywords        *[]string
	appendkeywords  []string
	clearedFields   map[string]struct{}
	airports        map[uuid.UUID]struct{}
	removedairports map[uuid.UUID]struct{}
	clearedairports bool
	done            bool
	oldValue        func(context.Context) (*Country, error)
	predicates      []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id uuid.UUID) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Country entities.
func (m *CountryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImportID sets the "import_id" field.
func (m *CountryMutation) SetImportID(i int) {
	m.import_id = &i
	m.addimport_id = nil
}

// ImportID returns the value of the "import_id" field in the mutation.
func (m *CountryMutation) ImportID() (r int, exists bool) {
	v := m.import_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImportID returns the old "import_id" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldImportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportID: %w", err)
	}
	return oldValue.ImportID, nil
}

// AddImportID adds i to the "import_id" field.
func (m *CountryMutation) AddImportID(i int) {
	if m.addimport_id != nil {
		*m.addimport_id += i
	} else {
		m.addimport_id = &i
	}
}

// AddedImportID returns the value that was added to the "import_id" field in this mutation.
func (m *CountryMutation) AddedImportID() (r int, exists bool) {
	v := m.addimport_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetImportID resets all changes to the "import_id" field.
func (m *CountryMutation) ResetImportID() {
	m.import_id = nil
	m.addimport_id = nil
}

// SetHash sets the "hash" field.
func (m *CountryMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *CountryMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *CountryMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *CountryMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *CountryMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *CountryMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *CountryMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *CountryMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *CountryMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetContinent sets the "continent" field.
func (m *CountryMutation) SetContinent(c country.Continent) {
	m.continent = &c
}

// Continent returns the value of the "continent" field in the mutation.
func (m *CountryMutation) Continent() (r country.Continent, exists bool) {
	v := m.continent
	if v == nil {
		return
	}
	return *v, true
}

// OldContinent returns the old "continent" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldContinent(ctx context.Context) (v country.Continent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinent: %w", err)
	}
	return oldValue.Continent, nil
}

// ResetContinent resets all changes to the "continent" field.
func (m *CountryMutation) ResetContinent() {
	m.continent = nil
}

// SetWikipediaLink sets the "wikipedia_link" field.
func (m *CountryMutation) SetWikipediaLink(s string) {
	m.wikipedia_link = &s
}

// WikipediaLink returns the value of the "wikipedia_link" field in the mutation.
func (m *CountryMutation) WikipediaLink() (r string, exists bool) {
	v := m.wikipedia_link
	if v == nil {
		return
	}
	return *v, true
}

// OldWikipediaLink returns the old "wikipedia_link" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldWikipediaLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWikipediaLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWikipediaLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWikipediaLink: %w", err)
	}
	return oldValue.WikipediaLink, nil
}

// ResetWikipediaLink resets all changes to the "wikipedia_link" field.
func (m *CountryMutation) ResetWikipediaLink() {
	m.wikipedia_link = nil
}

// SetKeywords sets the "keywords" field.
func (m *CountryMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *CountryMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *CountryMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *CountryMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *CountryMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
}

// AddAirportIDs adds the "airports" edge to the Airport entity by ids.
func (m *CountryMutation) AddAirportIDs(ids ...uuid.UUID) {
	if m.airports == nil {
		m.airports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.airports[ids[i]] = struct{}{}
	}
}

// ClearAirports clears the "airports" edge to the Airport entity.
func (m *CountryMutation) ClearAirports() {
	m.clearedairports = true
}

// AirportsCleared reports if the "airports" edge to the Airport entity was cleared.
func (m *CountryMutation) AirportsCleared() bool {
	return m.clearedairports
}

// RemoveAirportIDs removes the "airports" edge to the Airport entity by IDs.
func (m *CountryMutation) RemoveAirportIDs(ids ...uuid.UUID) {
	if m.removedairports == nil {
		m.removedairports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.airports, ids[i])
		m.removedairports[ids[i]] = struct{}{}
	}
}

// RemovedAirports returns the removed IDs of the "airports" edge to the Airport entity.
func (m *CountryMutation) RemovedAirportsIDs() (ids []uuid.UUID) {
	for id := range m.removedairports {
		ids = append(ids, id)
	}
	return
}

// AirportsIDs returns the "airports" edge IDs in the mutation.
func (m *CountryMutation) AirportsIDs() (ids []uuid.UUID) {
	for id := range m.airports {
		ids = append(ids, id)
	}
	return
}

// ResetAirports resets all changes to the "airports" edge.
func (m *CountryMutation) ResetAirports() {
	m.airports = nil
	m.clearedairports = false
	m.removedairports = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.import_id != nil {
		fields = append(fields, country.FieldImportID)
	}
	if m.hash != nil {
		fields = append(fields, country.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, country.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, country.FieldLastUpdated)
	}
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.continent != nil {
		fields = append(fields, country.FieldContinent)
	}
	if m.wikipedia_link != nil {
		fields = append(fields, country.FieldWikipediaLink)
	}
	if m.keywords != nil {
		fields = append(fields, country.FieldKeywords)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldImportID:
		return m.ImportID()
	case country.FieldHash:
		return m.Hash()
	case country.FieldImportFlag:
		return m.ImportFlag()
	case country.FieldLastUpdated:
		return m.LastUpdated()
	case country.FieldCode:
		return m.Code()
	case country.FieldName:
		return m.Name()
	case country.FieldContinent:
		return m.Continent()
	case country.FieldWikipediaLink:
		return m.WikipediaLink()
	case country.FieldKeywords:
		return m.Keywords()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldImportID:
		return m.OldImportID(ctx)
	case country.FieldHash:
		return m.OldHash(ctx)
	case country.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case country.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case country.FieldCode:
		return m.OldCode(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldContinent:
		return m.OldContinent(ctx)
	case country.FieldWikipediaLink:
		return m.OldWikipediaLink(ctx)
	case country.FieldKeywords:
		return m.OldKeywords(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportID(v)
		return nil
	case country.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case country.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case country.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldContinent:
		v, ok := value.(country.Continent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinent(v)
		return nil
	case country.FieldWikipediaLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWikipediaLink(v)
		return nil
	case country.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	var fields []string
	if m.addimport_id != nil {
		fields = append(fields, country.FieldImportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case country.FieldImportID:
		return m.AddedImportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case country.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportID(v)
		return nil
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldImportID:
		m.ResetImportID()
		return nil
	case country.FieldHash:
		m.ResetHash()
		return nil
	case country.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case country.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case country.FieldCode:
		m.ResetCode()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldContinent:
		m.ResetContinent()
		return nil
	case country.FieldWikipediaLink:
		m.ResetWikipediaLink()
		return nil
	case country.FieldKeywords:
		m.ResetKeywords()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.airports != nil {
		edges = append(edges, country.EdgeAirports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.airports))
		for id := range m.airports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedairports != nil {
		edges = append(edges, country.EdgeAirports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.removedairports))
		for id := range m.removedairports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedairports {
		edges = append(edges, country.EdgeAirports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeAirports:
		return m.clearedairports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeAirports:
		m.ResetAirports()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// ForecastMutation represents an operation that mutates the Forecast nodes in the graph.
type ForecastMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	from_time                          *time.Time
	to_time                            *time.Time
	change_indicator                   *forecast.ChangeIndicator
	change_time                        *time.Time
	change_probability                 *int
	addchange_probability              *int
	wind_direction                     *int
	addwind_direction                  *int
	wind_direction_variable            *bool
	wind_speed                         *int
	addwind_speed                      *int
	wind_gust                          *int
	addwind_gust                       *int
	wind_shear_height                  *int
	addwind_shear_height               *int
	wind_shear_direction               *int
	addwind_shear_direction            *int
	wind_shear_speed                   *int
	addwind_shear_speed                *int
	visibility_horizontal              *float64
	addvisibility_horizontal           *float64
	visibility_horizontal_is_more_than *bool
	visibility_vertical                *int
	addvisibility_vertical             *int
	altimeter                          *float64
	addaltimeter                       *float64
	weather                            *string
	not_decoded                        *string
	clearedFields                      map[string]struct{}
	sky_conditions                     map[uuid.UUID]struct{}
	removedsky_conditions              map[uuid.UUID]struct{}
	clearedsky_conditions              bool
	turbulence_conditions              map[uuid.UUID]struct{}
	removedturbulence_conditions       map[uuid.UUID]struct{}
	clearedturbulence_conditions       bool
	icing_conditions                   map[uuid.UUID]struct{}
	removedicing_conditions            map[uuid.UUID]struct{}
	clearedicing_conditions            bool
	temperature_data                   map[uuid.UUID]struct{}
	removedtemperature_data            map[uuid.UUID]struct{}
	clearedtemperature_data            bool
	done                               bool
	oldValue                           func(context.Context) (*Forecast, error)
	predicates                         []predicate.Forecast
}

var _ ent.Mutation = (*ForecastMutation)(nil)

// forecastOption allows management of the mutation configuration using functional options.
type forecastOption func(*ForecastMutation)

// newForecastMutation creates new mutation for the Forecast entity.
func newForecastMutation(c config, op Op, opts ...forecastOption) *ForecastMutation {
	m := &ForecastMutation{
		config:        c,
		op:            op,
		typ:           TypeForecast,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withForecastID sets the ID field of the mutation.
func withForecastID(id uuid.UUID) forecastOption {
	return func(m *ForecastMutation) {
		var (
			err   error
			once  sync.Once
			value *Forecast
		)
		m.oldValue = func(ctx context.Context) (*Forecast, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Forecast.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withForecast sets the old Forecast of the mutation.
func withForecast(node *Forecast) forecastOption {
	return func(m *ForecastMutation) {
		m.oldValue = func(context.Context) (*Forecast, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ForecastMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ForecastMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Forecast entities.
func (m *ForecastMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ForecastMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ForecastMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Forecast.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromTime sets the "from_time" field.
func (m *ForecastMutation) SetFromTime(t time.Time) {
	m.from_time = &t
}

// FromTime returns the value of the "from_time" field in the mutation.
func (m *ForecastMutation) FromTime() (r time.Time, exists bool) {
	v := m.from_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFromTime returns the old "from_time" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldFromTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromTime: %w", err)
	}
	return oldValue.FromTime, nil
}

// ResetFromTime resets all changes to the "from_time" field.
func (m *ForecastMutation) ResetFromTime() {
	m.from_time = nil
}

// SetToTime sets the "to_time" field.
func (m *ForecastMutation) SetToTime(t time.Time) {
	m.to_time = &t
}

// ToTime returns the value of the "to_time" field in the mutation.
func (m *ForecastMutation) ToTime() (r time.Time, exists bool) {
	v := m.to_time
	if v == nil {
		return
	}
	return *v, true
}

// OldToTime returns the old "to_time" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldToTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToTime: %w", err)
	}
	return oldValue.ToTime, nil
}

// ResetToTime resets all changes to the "to_time" field.
func (m *ForecastMutation) ResetToTime() {
	m.to_time = nil
}

// SetChangeIndicator sets the "change_indicator" field.
func (m *ForecastMutation) SetChangeIndicator(fi forecast.ChangeIndicator) {
	m.change_indicator = &fi
}

// ChangeIndicator returns the value of the "change_indicator" field in the mutation.
func (m *ForecastMutation) ChangeIndicator() (r forecast.ChangeIndicator, exists bool) {
	v := m.change_indicator
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeIndicator returns the old "change_indicator" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldChangeIndicator(ctx context.Context) (v *forecast.ChangeIndicator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeIndicator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeIndicator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeIndicator: %w", err)
	}
	return oldValue.ChangeIndicator, nil
}

// ClearChangeIndicator clears the value of the "change_indicator" field.
func (m *ForecastMutation) ClearChangeIndicator() {
	m.change_indicator = nil
	m.clearedFields[forecast.FieldChangeIndicator] = struct{}{}
}

// ChangeIndicatorCleared returns if the "change_indicator" field was cleared in this mutation.
func (m *ForecastMutation) ChangeIndicatorCleared() bool {
	_, ok := m.clearedFields[forecast.FieldChangeIndicator]
	return ok
}

// ResetChangeIndicator resets all changes to the "change_indicator" field.
func (m *ForecastMutation) ResetChangeIndicator() {
	m.change_indicator = nil
	delete(m.clearedFields, forecast.FieldChangeIndicator)
}

// SetChangeTime sets the "change_time" field.
func (m *ForecastMutation) SetChangeTime(t time.Time) {
	m.change_time = &t
}

// ChangeTime returns the value of the "change_time" field in the mutation.
func (m *ForecastMutation) ChangeTime() (r time.Time, exists bool) {
	v := m.change_time
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeTime returns the old "change_time" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldChangeTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeTime: %w", err)
	}
	return oldValue.ChangeTime, nil
}

// ClearChangeTime clears the value of the "change_time" field.
func (m *ForecastMutation) ClearChangeTime() {
	m.change_time = nil
	m.clearedFields[forecast.FieldChangeTime] = struct{}{}
}

// ChangeTimeCleared returns if the "change_time" field was cleared in this mutation.
func (m *ForecastMutation) ChangeTimeCleared() bool {
	_, ok := m.clearedFields[forecast.FieldChangeTime]
	return ok
}

// ResetChangeTime resets all changes to the "change_time" field.
func (m *ForecastMutation) ResetChangeTime() {
	m.change_time = nil
	delete(m.clearedFields, forecast.FieldChangeTime)
}

// SetChangeProbability sets the "change_probability" field.
func (m *ForecastMutation) SetChangeProbability(i int) {
	m.change_probability = &i
	m.addchange_probability = nil
}

// ChangeProbability returns the value of the "change_probability" field in the mutation.
func (m *ForecastMutation) ChangeProbability() (r int, exists bool) {
	v := m.change_probability
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeProbability returns the old "change_probability" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldChangeProbability(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeProbability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeProbability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeProbability: %w", err)
	}
	return oldValue.ChangeProbability, nil
}

// AddChangeProbability adds i to the "change_probability" field.
func (m *ForecastMutation) AddChangeProbability(i int) {
	if m.addchange_probability != nil {
		*m.addchange_probability += i
	} else {
		m.addchange_probability = &i
	}
}

// AddedChangeProbability returns the value that was added to the "change_probability" field in this mutation.
func (m *ForecastMutation) AddedChangeProbability() (r int, exists bool) {
	v := m.addchange_probability
	if v == nil {
		return
	}
	return *v, true
}

// ClearChangeProbability clears the value of the "change_probability" field.
func (m *ForecastMutation) ClearChangeProbability() {
	m.change_probability = nil
	m.addchange_probability = nil
	m.clearedFields[forecast.FieldChangeProbability] = struct{}{}
}

// ChangeProbabilityCleared returns if the "change_probability" field was cleared in this mutation.
func (m *ForecastMutation) ChangeProbabilityCleared() bool {
	_, ok := m.clearedFields[forecast.FieldChangeProbability]
	return ok
}

// ResetChangeProbability resets all changes to the "change_probability" field.
func (m *ForecastMutation) ResetChangeProbability() {
	m.change_probability = nil
	m.addchange_probability = nil
	delete(m.clearedFields, forecast.FieldChangeProbability)
}

// SetWindDirection sets the "wind_direction" field.
func (m *ForecastMutation) SetWindDirection(i int) {
	m.wind_direction = &i
	m.addwind_direction = nil
}

// WindDirection returns the value of the "wind_direction" field in the mutation.
func (m *ForecastMutation) WindDirection() (r int, exists bool) {
	v := m.wind_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirection returns the old "wind_direction" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWindDirection(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirection: %w", err)
	}
	return oldValue.WindDirection, nil
}

// AddWindDirection adds i to the "wind_direction" field.
func (m *ForecastMutation) AddWindDirection(i int) {
	if m.addwind_direction != nil {
		*m.addwind_direction += i
	} else {
		m.addwind_direction = &i
	}
}

// AddedWindDirection returns the value that was added to the "wind_direction" field in this mutation.
func (m *ForecastMutation) AddedWindDirection() (r int, exists bool) {
	v := m.addwind_direction
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindDirection clears the value of the "wind_direction" field.
func (m *ForecastMutation) ClearWindDirection() {
	m.wind_direction = nil
	m.addwind_direction = nil
	m.clearedFields[forecast.FieldWindDirection] = struct{}{}
}

// WindDirectionCleared returns if the "wind_direction" field was cleared in this mutation.
func (m *ForecastMutation) WindDirectionCleared() bool {
	_, ok := m.clearedFields[forecast.FieldWindDirection]
	return ok
}

// ResetWindDirection resets all changes to the "wind_direction" field.
func (m *ForecastMutation) ResetWindDirection() {
	m.wind_direction = nil
	m.addwind_direction = nil
	delete(m.clearedFields, forecast.FieldWindDirection)
}

// SetWindDirectionVariable sets the "wind_direction_variable" field.
func (m *ForecastMutation) SetWindDirectionVariable(b bool) {
	m.wind_direction_variable = &b
}

// WindDirectionVariable returns the value of the "wind_direction_variable" field in the mutation.
func (m *ForecastMutation) WindDirectionVariable() (r bool, exists bool) {
	v := m.wind_direction_variable
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirectionVariable returns the old "wind_direction_variable" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWindDirectionVariable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindDirectionVariable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindDirectionVariable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirectionVariable: %w", err)
	}
	return oldValue.WindDirectionVariable, nil
}

// ResetWindDirectionVariable resets all changes to the "wind_direction_variable" field.
func (m *ForecastMutation) ResetWindDirectionVariable() {
	m.wind_direction_variable = nil
}

// SetWindSpeed sets the "wind_speed" field.
func (m *ForecastMutation) SetWindSpeed(i int) {
	m.wind_speed = &i
	m.addwind_speed = nil
}

// WindSpeed returns the value of the "wind_speed" field in the mutation.
func (m *ForecastMutation) WindSpeed() (r int, exists bool) {
	v := m.wind_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldWindSpeed returns the old "wind_speed" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWindSpeed(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindSpeed: %w", err)
	}
	return oldValue.WindSpeed, nil
}

// AddWindSpeed adds i to the "wind_speed" field.
func (m *ForecastMutation) AddWindSpeed(i int) {
	if m.addwind_speed != nil {
		*m.addwind_speed += i
	} else {
		m.addwind_speed = &i
	}
}

// AddedWindSpeed returns the value that was added to the "wind_speed" field in this mutation.
func (m *ForecastMutation) AddedWindSpeed() (r int, exists bool) {
	v := m.addwind_speed
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindSpeed clears the value of the "wind_speed" field.
func (m *ForecastMutation) ClearWindSpeed() {
	m.wind_speed = nil
	m.addwind_speed = nil
	m.clearedFields[forecast.FieldWindSpeed] = struct{}{}
}

// WindSpeedCleared returns if the "wind_speed" field was cleared in this mutation.
func (m *ForecastMutation) WindSpeedCleared() bool {
	_, ok := m.clearedFields[forecast.FieldWindSpeed]
	return ok
}

// ResetWindSpeed resets all changes to the "wind_speed" field.
func (m *ForecastMutation) ResetWindSpeed() {
	m.wind_speed = nil
	m.addwind_speed = nil
	delete(m.clearedFields, forecast.FieldWindSpeed)
}

// SetWindGust sets the "wind_gust" field.
func (m *ForecastMutation) SetWindGust(i int) {
	m.wind_gust = &i
	m.addwind_gust = nil
}

// WindGust returns the value of the "wind_gust" field in the mutation.
func (m *ForecastMutation) WindGust() (r int, exists bool) {
	v := m.wind_gust
	if v == nil {
		return
	}
	return *v, true
}

// OldWindGust returns the old "wind_gust" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWindGust(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindGust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindGust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindGust: %w", err)
	}
	return oldValue.WindGust, nil
}

// AddWindGust adds i to the "wind_gust" field.
func (m *ForecastMutation) AddWindGust(i int) {
	if m.addwind_gust != nil {
		*m.addwind_gust += i
	} else {
		m.addwind_gust = &i
	}
}

// AddedWindGust returns the value that was added to the "wind_gust" field in this mutation.
func (m *ForecastMutation) AddedWindGust() (r int, exists bool) {
	v := m.addwind_gust
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindGust clears the value of the "wind_gust" field.
func (m *ForecastMutation) ClearWindGust() {
	m.wind_gust = nil
	m.addwind_gust = nil
	m.clearedFields[forecast.FieldWindGust] = struct{}{}
}

// WindGustCleared returns if the "wind_gust" field was cleared in this mutation.
func (m *ForecastMutation) WindGustCleared() bool {
	_, ok := m.clearedFields[forecast.FieldWindGust]
	return ok
}

// ResetWindGust resets all changes to the "wind_gust" field.
func (m *ForecastMutation) ResetWindGust() {
	m.wind_gust = nil
	m.addwind_gust = nil
	delete(m.clearedFields, forecast.FieldWindGust)
}

// SetWindShearHeight sets the "wind_shear_height" field.
func (m *ForecastMutation) SetWindShearHeight(i int) {
	m.wind_shear_height = &i
	m.addwind_shear_height = nil
}

// WindShearHeight returns the value of the "wind_shear_height" field in the mutation.
func (m *ForecastMutation) WindShearHeight() (r int, exists bool) {
	v := m.wind_shear_height
	if v == nil {
		return
	}
	return *v, true
}

// OldWindShearHeight returns the old "wind_shear_height" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWindShearHeight(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindShearHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindShearHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindShearHeight: %w", err)
	}
	return oldValue.WindShearHeight, nil
}

// AddWindShearHeight adds i to the "wind_shear_height" field.
func (m *ForecastMutation) AddWindShearHeight(i int) {
	if m.addwind_shear_height != nil {
		*m.addwind_shear_height += i
	} else {
		m.addwind_shear_height = &i
	}
}

// AddedWindShearHeight returns the value that was added to the "wind_shear_height" field in this mutation.
func (m *ForecastMutation) AddedWindShearHeight() (r int, exists bool) {
	v := m.addwind_shear_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindShearHeight clears the value of the "wind_shear_height" field.
func (m *ForecastMutation) ClearWindShearHeight() {
	m.wind_shear_height = nil
	m.addwind_shear_height = nil
	m.clearedFields[forecast.FieldWindShearHeight] = struct{}{}
}

// WindShearHeightCleared returns if the "wind_shear_height" field was cleared in this mutation.
func (m *ForecastMutation) WindShearHeightCleared() bool {
	_, ok := m.clearedFields[forecast.FieldWindShearHeight]
	return ok
}

// ResetWindShearHeight resets all changes to the "wind_shear_height" field.
func (m *ForecastMutation) ResetWindShearHeight() {
	m.wind_shear_height = nil
	m.addwind_shear_height = nil
	delete(m.clearedFields, forecast.FieldWindShearHeight)
}

// SetWindShearDirection sets the "wind_shear_direction" field.
func (m *ForecastMutation) SetWindShearDirection(i int) {
	m.wind_shear_direction = &i
	m.addwind_shear_direction = nil
}

// WindShearDirection returns the value of the "wind_shear_direction" field in the mutation.
func (m *ForecastMutation) WindShearDirection() (r int, exists bool) {
	v := m.wind_shear_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldWindShearDirection returns the old "wind_shear_direction" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWindShearDirection(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindShearDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindShearDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindShearDirection: %w", err)
	}
	return oldValue.WindShearDirection, nil
}

// AddWindShearDirection adds i to the "wind_shear_direction" field.
func (m *ForecastMutation) AddWindShearDirection(i int) {
	if m.addwind_shear_direction != nil {
		*m.addwind_shear_direction += i
	} else {
		m.addwind_shear_direction = &i
	}
}

// AddedWindShearDirection returns the value that was added to the "wind_shear_direction" field in this mutation.
func (m *ForecastMutation) AddedWindShearDirection() (r int, exists bool) {
	v := m.addwind_shear_direction
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindShearDirection clears the value of the "wind_shear_direction" field.
func (m *ForecastMutation) ClearWindShearDirection() {
	m.wind_shear_direction = nil
	m.addwind_shear_direction = nil
	m.clearedFields[forecast.FieldWindShearDirection] = struct{}{}
}

// WindShearDirectionCleared returns if the "wind_shear_direction" field was cleared in this mutation.
func (m *ForecastMutation) WindShearDirectionCleared() bool {
	_, ok := m.clearedFields[forecast.FieldWindShearDirection]
	return ok
}

// ResetWindShearDirection resets all changes to the "wind_shear_direction" field.
func (m *ForecastMutation) ResetWindShearDirection() {
	m.wind_shear_direction = nil
	m.addwind_shear_direction = nil
	delete(m.clearedFields, forecast.FieldWindShearDirection)
}

// SetWindShearSpeed sets the "wind_shear_speed" field.
func (m *ForecastMutation) SetWindShearSpeed(i int) {
	m.wind_shear_speed = &i
	m.addwind_shear_speed = nil
}

// WindShearSpeed returns the value of the "wind_shear_speed" field in the mutation.
func (m *ForecastMutation) WindShearSpeed() (r int, exists bool) {
	v := m.wind_shear_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldWindShearSpeed returns the old "wind_shear_speed" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWindShearSpeed(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindShearSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindShearSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindShearSpeed: %w", err)
	}
	return oldValue.WindShearSpeed, nil
}

// AddWindShearSpeed adds i to the "wind_shear_speed" field.
func (m *ForecastMutation) AddWindShearSpeed(i int) {
	if m.addwind_shear_speed != nil {
		*m.addwind_shear_speed += i
	} else {
		m.addwind_shear_speed = &i
	}
}

// AddedWindShearSpeed returns the value that was added to the "wind_shear_speed" field in this mutation.
func (m *ForecastMutation) AddedWindShearSpeed() (r int, exists bool) {
	v := m.addwind_shear_speed
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindShearSpeed clears the value of the "wind_shear_speed" field.
func (m *ForecastMutation) ClearWindShearSpeed() {
	m.wind_shear_speed = nil
	m.addwind_shear_speed = nil
	m.clearedFields[forecast.FieldWindShearSpeed] = struct{}{}
}

// WindShearSpeedCleared returns if the "wind_shear_speed" field was cleared in this mutation.
func (m *ForecastMutation) WindShearSpeedCleared() bool {
	_, ok := m.clearedFields[forecast.FieldWindShearSpeed]
	return ok
}

// ResetWindShearSpeed resets all changes to the "wind_shear_speed" field.
func (m *ForecastMutation) ResetWindShearSpeed() {
	m.wind_shear_speed = nil
	m.addwind_shear_speed = nil
	delete(m.clearedFields, forecast.FieldWindShearSpeed)
}

// SetVisibilityHorizontal sets the "visibility_horizontal" field.
func (m *ForecastMutation) SetVisibilityHorizontal(f float64) {
	m.visibility_horizontal = &f
	m.addvisibility_horizontal = nil
}

// VisibilityHorizontal returns the value of the "visibility_horizontal" field in the mutation.
func (m *ForecastMutation) VisibilityHorizontal() (r float64, exists bool) {
	v := m.visibility_horizontal
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibilityHorizontal returns the old "visibility_horizontal" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldVisibilityHorizontal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibilityHorizontal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibilityHorizontal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibilityHorizontal: %w", err)
	}
	return oldValue.VisibilityHorizontal, nil
}

// AddVisibilityHorizontal adds f to the "visibility_horizontal" field.
func (m *ForecastMutation) AddVisibilityHorizontal(f float64) {
	if m.addvisibility_horizontal != nil {
		*m.addvisibility_horizontal += f
	} else {
		m.addvisibility_horizontal = &f
	}
}

// AddedVisibilityHorizontal returns the value that was added to the "visibility_horizontal" field in this mutation.
func (m *ForecastMutation) AddedVisibilityHorizontal() (r float64, exists bool) {
	v := m.addvisibility_horizontal
	if v == nil {
		return
	}
	return *v, true
}

// ClearVisibilityHorizontal clears the value of the "visibility_horizontal" field.
func (m *ForecastMutation) ClearVisibilityHorizontal() {
	m.visibility_horizontal = nil
	m.addvisibility_horizontal = nil
	m.clearedFields[forecast.FieldVisibilityHorizontal] = struct{}{}
}

// VisibilityHorizontalCleared returns if the "visibility_horizontal" field was cleared in this mutation.
func (m *ForecastMutation) VisibilityHorizontalCleared() bool {
	_, ok := m.clearedFields[forecast.FieldVisibilityHorizontal]
	return ok
}

// ResetVisibilityHorizontal resets all changes to the "visibility_horizontal" field.
func (m *ForecastMutation) ResetVisibilityHorizontal() {
	m.visibility_horizontal = nil
	m.addvisibility_horizontal = nil
	delete(m.clearedFields, forecast.FieldVisibilityHorizontal)
}

// SetVisibilityHorizontalIsMoreThan sets the "visibility_horizontal_is_more_than" field.
func (m *ForecastMutation) SetVisibilityHorizontalIsMoreThan(b bool) {
	m.visibility_horizontal_is_more_than = &b
}

// VisibilityHorizontalIsMoreThan returns the value of the "visibility_horizontal_is_more_than" field in the mutation.
func (m *ForecastMutation) VisibilityHorizontalIsMoreThan() (r bool, exists bool) {
	v := m.visibility_horizontal_is_more_than
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibilityHorizontalIsMoreThan returns the old "visibility_horizontal_is_more_than" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldVisibilityHorizontalIsMoreThan(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibilityHorizontalIsMoreThan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibilityHorizontalIsMoreThan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibilityHorizontalIsMoreThan: %w", err)
	}
	return oldValue.VisibilityHorizontalIsMoreThan, nil
}

// ResetVisibilityHorizontalIsMoreThan resets all changes to the "visibility_horizontal_is_more_than" field.
func (m *ForecastMutation) ResetVisibilityHorizontalIsMoreThan() {
	m.visibility_horizontal_is_more_than = nil
}

// SetVisibilityVertical sets the "visibility_vertical" field.
func (m *ForecastMutation) SetVisibilityVertical(i int) {
	m.visibility_vertical = &i
	m.addvisibility_vertical = nil
}

// VisibilityVertical returns the value of the "visibility_vertical" field in the mutation.
func (m *ForecastMutation) VisibilityVertical() (r int, exists bool) {
	v := m.visibility_vertical
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibilityVertical returns the old "visibility_vertical" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldVisibilityVertical(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibilityVertical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibilityVertical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibilityVertical: %w", err)
	}
	return oldValue.VisibilityVertical, nil
}

// AddVisibilityVertical adds i to the "visibility_vertical" field.
func (m *ForecastMutation) AddVisibilityVertical(i int) {
	if m.addvisibility_vertical != nil {
		*m.addvisibility_vertical += i
	} else {
		m.addvisibility_vertical = &i
	}
}

// AddedVisibilityVertical returns the value that was added to the "visibility_vertical" field in this mutation.
func (m *ForecastMutation) AddedVisibilityVertical() (r int, exists bool) {
	v := m.addvisibility_vertical
	if v == nil {
		return
	}
	return *v, true
}

// ClearVisibilityVertical clears the value of the "visibility_vertical" field.
func (m *ForecastMutation) ClearVisibilityVertical() {
	m.visibility_vertical = nil
	m.addvisibility_vertical = nil
	m.clearedFields[forecast.FieldVisibilityVertical] = struct{}{}
}

// VisibilityVerticalCleared returns if the "visibility_vertical" field was cleared in this mutation.
func (m *ForecastMutation) VisibilityVerticalCleared() bool {
	_, ok := m.clearedFields[forecast.FieldVisibilityVertical]
	return ok
}

// ResetVisibilityVertical resets all changes to the "visibility_vertical" field.
func (m *ForecastMutation) ResetVisibilityVertical() {
	m.visibility_vertical = nil
	m.addvisibility_vertical = nil
	delete(m.clearedFields, forecast.FieldVisibilityVertical)
}

// SetAltimeter sets the "altimeter" field.
func (m *ForecastMutation) SetAltimeter(f float64) {
	m.altimeter = &f
	m.addaltimeter = nil
}

// Altimeter returns the value of the "altimeter" field in the mutation.
func (m *ForecastMutation) Altimeter() (r float64, exists bool) {
	v := m.altimeter
	if v == nil {
		return
	}
	return *v, true
}

// OldAltimeter returns the old "altimeter" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldAltimeter(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltimeter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltimeter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltimeter: %w", err)
	}
	return oldValue.Altimeter, nil
}

// AddAltimeter adds f to the "altimeter" field.
func (m *ForecastMutation) AddAltimeter(f float64) {
	if m.addaltimeter != nil {
		*m.addaltimeter += f
	} else {
		m.addaltimeter = &f
	}
}

// AddedAltimeter returns the value that was added to the "altimeter" field in this mutation.
func (m *ForecastMutation) AddedAltimeter() (r float64, exists bool) {
	v := m.addaltimeter
	if v == nil {
		return
	}
	return *v, true
}

// ClearAltimeter clears the value of the "altimeter" field.
func (m *ForecastMutation) ClearAltimeter() {
	m.altimeter = nil
	m.addaltimeter = nil
	m.clearedFields[forecast.FieldAltimeter] = struct{}{}
}

// AltimeterCleared returns if the "altimeter" field was cleared in this mutation.
func (m *ForecastMutation) AltimeterCleared() bool {
	_, ok := m.clearedFields[forecast.FieldAltimeter]
	return ok
}

// ResetAltimeter resets all changes to the "altimeter" field.
func (m *ForecastMutation) ResetAltimeter() {
	m.altimeter = nil
	m.addaltimeter = nil
	delete(m.clearedFields, forecast.FieldAltimeter)
}

// SetWeather sets the "weather" field.
func (m *ForecastMutation) SetWeather(s string) {
	m.weather = &s
}

// Weather returns the value of the "weather" field in the mutation.
func (m *ForecastMutation) Weather() (r string, exists bool) {
	v := m.weather
	if v == nil {
		return
	}
	return *v, true
}

// OldWeather returns the old "weather" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldWeather(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeather is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeather: %w", err)
	}
	return oldValue.Weather, nil
}

// ClearWeather clears the value of the "weather" field.
func (m *ForecastMutation) ClearWeather() {
	m.weather = nil
	m.clearedFields[forecast.FieldWeather] = struct{}{}
}

// WeatherCleared returns if the "weather" field was cleared in this mutation.
func (m *ForecastMutation) WeatherCleared() bool {
	_, ok := m.clearedFields[forecast.FieldWeather]
	return ok
}

// ResetWeather resets all changes to the "weather" field.
func (m *ForecastMutation) ResetWeather() {
	m.weather = nil
	delete(m.clearedFields, forecast.FieldWeather)
}

// SetNotDecoded sets the "not_decoded" field.
func (m *ForecastMutation) SetNotDecoded(s string) {
	m.not_decoded = &s
}

// NotDecoded returns the value of the "not_decoded" field in the mutation.
func (m *ForecastMutation) NotDecoded() (r string, exists bool) {
	v := m.not_decoded
	if v == nil {
		return
	}
	return *v, true
}

// OldNotDecoded returns the old "not_decoded" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldNotDecoded(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotDecoded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotDecoded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotDecoded: %w", err)
	}
	return oldValue.NotDecoded, nil
}

// ClearNotDecoded clears the value of the "not_decoded" field.
func (m *ForecastMutation) ClearNotDecoded() {
	m.not_decoded = nil
	m.clearedFields[forecast.FieldNotDecoded] = struct{}{}
}

// NotDecodedCleared returns if the "not_decoded" field was cleared in this mutation.
func (m *ForecastMutation) NotDecodedCleared() bool {
	_, ok := m.clearedFields[forecast.FieldNotDecoded]
	return ok
}

// ResetNotDecoded resets all changes to the "not_decoded" field.
func (m *ForecastMutation) ResetNotDecoded() {
	m.not_decoded = nil
	delete(m.clearedFields, forecast.FieldNotDecoded)
}

// AddSkyConditionIDs adds the "sky_conditions" edge to the SkyCondition entity by ids.
func (m *ForecastMutation) AddSkyConditionIDs(ids ...uuid.UUID) {
	if m.sky_conditions == nil {
		m.sky_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sky_conditions[ids[i]] = struct{}{}
	}
}

// ClearSkyConditions clears the "sky_conditions" edge to the SkyCondition entity.
func (m *ForecastMutation) ClearSkyConditions() {
	m.clearedsky_conditions = true
}

// SkyConditionsCleared reports if the "sky_conditions" edge to the SkyCondition entity was cleared.
func (m *ForecastMutation) SkyConditionsCleared() bool {
	return m.clearedsky_conditions
}

// RemoveSkyConditionIDs removes the "sky_conditions" edge to the SkyCondition entity by IDs.
func (m *ForecastMutation) RemoveSkyConditionIDs(ids ...uuid.UUID) {
	if m.removedsky_conditions == nil {
		m.removedsky_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sky_conditions, ids[i])
		m.removedsky_conditions[ids[i]] = struct{}{}
	}
}

// RemovedSkyConditions returns the removed IDs of the "sky_conditions" edge to the SkyCondition entity.
func (m *ForecastMutation) RemovedSkyConditionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsky_conditions {
		ids = append(ids, id)
	}
	return
}

// SkyConditionsIDs returns the "sky_conditions" edge IDs in the mutation.
func (m *ForecastMutation) SkyConditionsIDs() (ids []uuid.UUID) {
	for id := range m.sky_conditions {
		ids = append(ids, id)
	}
	return
}

// ResetSkyConditions resets all changes to the "sky_conditions" edge.
func (m *ForecastMutation) ResetSkyConditions() {
	m.sky_conditions = nil
	m.clearedsky_conditions = false
	m.removedsky_conditions = nil
}

// AddTurbulenceConditionIDs adds the "turbulence_conditions" edge to the TurbulenceCondition entity by ids.
func (m *ForecastMutation) AddTurbulenceConditionIDs(ids ...uuid.UUID) {
	if m.turbulence_conditions == nil {
		m.turbulence_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.turbulence_conditions[ids[i]] = struct{}{}
	}
}

// ClearTurbulenceConditions clears the "turbulence_conditions" edge to the TurbulenceCondition entity.
func (m *ForecastMutation) ClearTurbulenceConditions() {
	m.clearedturbulence_conditions = true
}

// TurbulenceConditionsCleared reports if the "turbulence_conditions" edge to the TurbulenceCondition entity was cleared.
func (m *ForecastMutation) TurbulenceConditionsCleared() bool {
	return m.clearedturbulence_conditions
}

// RemoveTurbulenceConditionIDs removes the "turbulence_conditions" edge to the TurbulenceCondition entity by IDs.
func (m *ForecastMutation) RemoveTurbulenceConditionIDs(ids ...uuid.UUID) {
	if m.removedturbulence_conditions == nil {
		m.removedturbulence_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.turbulence_conditions, ids[i])
		m.removedturbulence_conditions[ids[i]] = struct{}{}
	}
}

// RemovedTurbulenceConditions returns the removed IDs of the "turbulence_conditions" edge to the TurbulenceCondition entity.
func (m *ForecastMutation) RemovedTurbulenceConditionsIDs() (ids []uuid.UUID) {
	for id := range m.removedturbulence_conditions {
		ids = append(ids, id)
	}
	return
}

// TurbulenceConditionsIDs returns the "turbulence_conditions" edge IDs in the mutation.
func (m *ForecastMutation) TurbulenceConditionsIDs() (ids []uuid.UUID) {
	for id := range m.turbulence_conditions {
		ids = append(ids, id)
	}
	return
}

// ResetTurbulenceConditions resets all changes to the "turbulence_conditions" edge.
func (m *ForecastMutation) ResetTurbulenceConditions() {
	m.turbulence_conditions = nil
	m.clearedturbulence_conditions = false
	m.removedturbulence_conditions = nil
}

// AddIcingConditionIDs adds the "icing_conditions" edge to the IcingCondition entity by ids.
func (m *ForecastMutation) AddIcingConditionIDs(ids ...uuid.UUID) {
	if m.icing_conditions == nil {
		m.icing_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.icing_conditions[ids[i]] = struct{}{}
	}
}

// ClearIcingConditions clears the "icing_conditions" edge to the IcingCondition entity.
func (m *ForecastMutation) ClearIcingConditions() {
	m.clearedicing_conditions = true
}

// IcingConditionsCleared reports if the "icing_conditions" edge to the IcingCondition entity was cleared.
func (m *ForecastMutation) IcingConditionsCleared() bool {
	return m.clearedicing_conditions
}

// RemoveIcingConditionIDs removes the "icing_conditions" edge to the IcingCondition entity by IDs.
func (m *ForecastMutation) RemoveIcingConditionIDs(ids ...uuid.UUID) {
	if m.removedicing_conditions == nil {
		m.removedicing_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.icing_conditions, ids[i])
		m.removedicing_conditions[ids[i]] = struct{}{}
	}
}

// RemovedIcingConditions returns the removed IDs of the "icing_conditions" edge to the IcingCondition entity.
func (m *ForecastMutation) RemovedIcingConditionsIDs() (ids []uuid.UUID) {
	for id := range m.removedicing_conditions {
		ids = append(ids, id)
	}
	return
}

// IcingConditionsIDs returns the "icing_conditions" edge IDs in the mutation.
func (m *ForecastMutation) IcingConditionsIDs() (ids []uuid.UUID) {
	for id := range m.icing_conditions {
		ids = append(ids, id)
	}
	return
}

// ResetIcingConditions resets all changes to the "icing_conditions" edge.
func (m *ForecastMutation) ResetIcingConditions() {
	m.icing_conditions = nil
	m.clearedicing_conditions = false
	m.removedicing_conditions = nil
}

// AddTemperatureDatumIDs adds the "temperature_data" edge to the TemperatureData entity by ids.
func (m *ForecastMutation) AddTemperatureDatumIDs(ids ...uuid.UUID) {
	if m.temperature_data == nil {
		m.temperature_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.temperature_data[ids[i]] = struct{}{}
	}
}

// ClearTemperatureData clears the "temperature_data" edge to the TemperatureData entity.
func (m *ForecastMutation) ClearTemperatureData() {
	m.clearedtemperature_data = true
}

// TemperatureDataCleared reports if the "temperature_data" edge to the TemperatureData entity was cleared.
func (m *ForecastMutation) TemperatureDataCleared() bool {
	return m.clearedtemperature_data
}

// RemoveTemperatureDatumIDs removes the "temperature_data" edge to the TemperatureData entity by IDs.
func (m *ForecastMutation) RemoveTemperatureDatumIDs(ids ...uuid.UUID) {
	if m.removedtemperature_data == nil {
		m.removedtemperature_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.temperature_data, ids[i])
		m.removedtemperature_data[ids[i]] = struct{}{}
	}
}

// RemovedTemperatureData returns the removed IDs of the "temperature_data" edge to the TemperatureData entity.
func (m *ForecastMutation) RemovedTemperatureDataIDs() (ids []uuid.UUID) {
	for id := range m.removedtemperature_data {
		ids = append(ids, id)
	}
	return
}

// TemperatureDataIDs returns the "temperature_data" edge IDs in the mutation.
func (m *ForecastMutation) TemperatureDataIDs() (ids []uuid.UUID) {
	for id := range m.temperature_data {
		ids = append(ids, id)
	}
	return
}

// ResetTemperatureData resets all changes to the "temperature_data" edge.
func (m *ForecastMutation) ResetTemperatureData() {
	m.temperature_data = nil
	m.clearedtemperature_data = false
	m.removedtemperature_data = nil
}

// Where appends a list predicates to the ForecastMutation builder.
func (m *ForecastMutation) Where(ps ...predicate.Forecast) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ForecastMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ForecastMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Forecast, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ForecastMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ForecastMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Forecast).
func (m *ForecastMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ForecastMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.from_time != nil {
		fields = append(fields, forecast.FieldFromTime)
	}
	if m.to_time != nil {
		fields = append(fields, forecast.FieldToTime)
	}
	if m.change_indicator != nil {
		fields = append(fields, forecast.FieldChangeIndicator)
	}
	if m.change_time != nil {
		fields = append(fields, forecast.FieldChangeTime)
	}
	if m.change_probability != nil {
		fields = append(fields, forecast.FieldChangeProbability)
	}
	if m.wind_direction != nil {
		fields = append(fields, forecast.FieldWindDirection)
	}
	if m.wind_direction_variable != nil {
		fields = append(fields, forecast.FieldWindDirectionVariable)
	}
	if m.wind_speed != nil {
		fields = append(fields, forecast.FieldWindSpeed)
	}
	if m.wind_gust != nil {
		fields = append(fields, forecast.FieldWindGust)
	}
	if m.wind_shear_height != nil {
		fields = append(fields, forecast.FieldWindShearHeight)
	}
	if m.wind_shear_direction != nil {
		fields = append(fields, forecast.FieldWindShearDirection)
	}
	if m.wind_shear_speed != nil {
		fields = append(fields, forecast.FieldWindShearSpeed)
	}
	if m.visibility_horizontal != nil {
		fields = append(fields, forecast.FieldVisibilityHorizontal)
	}
	if m.visibility_horizontal_is_more_than != nil {
		fields = append(fields, forecast.FieldVisibilityHorizontalIsMoreThan)
	}
	if m.visibility_vertical != nil {
		fields = append(fields, forecast.FieldVisibilityVertical)
	}
	if m.altimeter != nil {
		fields = append(fields, forecast.FieldAltimeter)
	}
	if m.weather != nil {
		fields = append(fields, forecast.FieldWeather)
	}
	if m.not_decoded != nil {
		fields = append(fields, forecast.FieldNotDecoded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ForecastMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case forecast.FieldFromTime:
		return m.FromTime()
	case forecast.FieldToTime:
		return m.ToTime()
	case forecast.FieldChangeIndicator:
		return m.ChangeIndicator()
	case forecast.FieldChangeTime:
		return m.ChangeTime()
	case forecast.FieldChangeProbability:
		return m.ChangeProbability()
	case forecast.FieldWindDirection:
		return m.WindDirection()
	case forecast.FieldWindDirectionVariable:
		return m.WindDirectionVariable()
	case forecast.FieldWindSpeed:
		return m.WindSpeed()
	case forecast.FieldWindGust:
		return m.WindGust()
	case forecast.FieldWindShearHeight:
		return m.WindShearHeight()
	case forecast.FieldWindShearDirection:
		return m.WindShearDirection()
	case forecast.FieldWindShearSpeed:
		return m.WindShearSpeed()
	case forecast.FieldVisibilityHorizontal:
		return m.VisibilityHorizontal()
	case forecast.FieldVisibilityHorizontalIsMoreThan:
		return m.VisibilityHorizontalIsMoreThan()
	case forecast.FieldVisibilityVertical:
		return m.VisibilityVertical()
	case forecast.FieldAltimeter:
		return m.Altimeter()
	case forecast.FieldWeather:
		return m.Weather()
	case forecast.FieldNotDecoded:
		return m.NotDecoded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ForecastMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case forecast.FieldFromTime:
		return m.OldFromTime(ctx)
	case forecast.FieldToTime:
		return m.OldToTime(ctx)
	case forecast.FieldChangeIndicator:
		return m.OldChangeIndicator(ctx)
	case forecast.FieldChangeTime:
		return m.OldChangeTime(ctx)
	case forecast.FieldChangeProbability:
		return m.OldChangeProbability(ctx)
	case forecast.FieldWindDirection:
		return m.OldWindDirection(ctx)
	case forecast.FieldWindDirectionVariable:
		return m.OldWindDirectionVariable(ctx)
	case forecast.FieldWindSpeed:
		return m.OldWindSpeed(ctx)
	case forecast.FieldWindGust:
		return m.OldWindGust(ctx)
	case forecast.FieldWindShearHeight:
		return m.OldWindShearHeight(ctx)
	case forecast.FieldWindShearDirection:
		return m.OldWindShearDirection(ctx)
	case forecast.FieldWindShearSpeed:
		return m.OldWindShearSpeed(ctx)
	case forecast.FieldVisibilityHorizontal:
		return m.OldVisibilityHorizontal(ctx)
	case forecast.FieldVisibilityHorizontalIsMoreThan:
		return m.OldVisibilityHorizontalIsMoreThan(ctx)
	case forecast.FieldVisibilityVertical:
		return m.OldVisibilityVertical(ctx)
	case forecast.FieldAltimeter:
		return m.OldAltimeter(ctx)
	case forecast.FieldWeather:
		return m.OldWeather(ctx)
	case forecast.FieldNotDecoded:
		return m.OldNotDecoded(ctx)
	}
	return nil, fmt.Errorf("unknown Forecast field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForecastMutation) SetField(name string, value ent.Value) error {
	switch name {
	case forecast.FieldFromTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromTime(v)
		return nil
	case forecast.FieldToTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToTime(v)
		return nil
	case forecast.FieldChangeIndicator:
		v, ok := value.(forecast.ChangeIndicator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeIndicator(v)
		return nil
	case forecast.FieldChangeTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeTime(v)
		return nil
	case forecast.FieldChangeProbability:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeProbability(v)
		return nil
	case forecast.FieldWindDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirection(v)
		return nil
	case forecast.FieldWindDirectionVariable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirectionVariable(v)
		return nil
	case forecast.FieldWindSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindSpeed(v)
		return nil
	case forecast.FieldWindGust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindGust(v)
		return nil
	case forecast.FieldWindShearHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindShearHeight(v)
		return nil
	case forecast.FieldWindShearDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindShearDirection(v)
		return nil
	case forecast.FieldWindShearSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindShearSpeed(v)
		return nil
	case forecast.FieldVisibilityHorizontal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibilityHorizontal(v)
		return nil
	case forecast.FieldVisibilityHorizontalIsMoreThan:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibilityHorizontalIsMoreThan(v)
		return nil
	case forecast.FieldVisibilityVertical:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibilityVertical(v)
		return nil
	case forecast.FieldAltimeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltimeter(v)
		return nil
	case forecast.FieldWeather:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeather(v)
		return nil
	case forecast.FieldNotDecoded:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotDecoded(v)
		return nil
	}
	return fmt.Errorf("unknown Forecast field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ForecastMutation) AddedFields() []string {
	var fields []string
	if m.addchange_probability != nil {
		fields = append(fields, forecast.FieldChangeProbability)
	}
	if m.addwind_direction != nil {
		fields = append(fields, forecast.FieldWindDirection)
	}
	if m.addwind_speed != nil {
		fields = append(fields, forecast.FieldWindSpeed)
	}
	if m.addwind_gust != nil {
		fields = append(fields, forecast.FieldWindGust)
	}
	if m.addwind_shear_height != nil {
		fields = append(fields, forecast.FieldWindShearHeight)
	}
	if m.addwind_shear_direction != nil {
		fields = append(fields, forecast.FieldWindShearDirection)
	}
	if m.addwind_shear_speed != nil {
		fields = append(fields, forecast.FieldWindShearSpeed)
	}
	if m.addvisibility_horizontal != nil {
		fields = append(fields, forecast.FieldVisibilityHorizontal)
	}
	if m.addvisibility_vertical != nil {
		fields = append(fields, forecast.FieldVisibilityVertical)
	}
	if m.addaltimeter != nil {
		fields = append(fields, forecast.FieldAltimeter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ForecastMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case forecast.FieldChangeProbability:
		return m.AddedChangeProbability()
	case forecast.FieldWindDirection:
		return m.AddedWindDirection()
	case forecast.FieldWindSpeed:
		return m.AddedWindSpeed()
	case forecast.FieldWindGust:
		return m.AddedWindGust()
	case forecast.FieldWindShearHeight:
		return m.AddedWindShearHeight()
	case forecast.FieldWindShearDirection:
		return m.AddedWindShearDirection()
	case forecast.FieldWindShearSpeed:
		return m.AddedWindShearSpeed()
	case forecast.FieldVisibilityHorizontal:
		return m.AddedVisibilityHorizontal()
	case forecast.FieldVisibilityVertical:
		return m.AddedVisibilityVertical()
	case forecast.FieldAltimeter:
		return m.AddedAltimeter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForecastMutation) AddField(name string, value ent.Value) error {
	switch name {
	case forecast.FieldChangeProbability:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChangeProbability(v)
		return nil
	case forecast.FieldWindDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindDirection(v)
		return nil
	case forecast.FieldWindSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindSpeed(v)
		return nil
	case forecast.FieldWindGust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindGust(v)
		return nil
	case forecast.FieldWindShearHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindShearHeight(v)
		return nil
	case forecast.FieldWindShearDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindShearDirection(v)
		return nil
	case forecast.FieldWindShearSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindShearSpeed(v)
		return nil
	case forecast.FieldVisibilityHorizontal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisibilityHorizontal(v)
		return nil
	case forecast.FieldVisibilityVertical:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisibilityVertical(v)
		return nil
	case forecast.FieldAltimeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAltimeter(v)
		return nil
	}
	return fmt.Errorf("unknown Forecast numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ForecastMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(forecast.FieldChangeIndicator) {
		fields = append(fields, forecast.FieldChangeIndicator)
	}
	if m.FieldCleared(forecast.FieldChangeTime) {
		fields = append(fields, forecast.FieldChangeTime)
	}
	if m.FieldCleared(forecast.FieldChangeProbability) {
		fields = append(fields, forecast.FieldChangeProbability)
	}
	if m.FieldCleared(forecast.FieldWindDirection) {
		fields = append(fields, forecast.FieldWindDirection)
	}
	if m.FieldCleared(forecast.FieldWindSpeed) {
		fields = append(fields, forecast.FieldWindSpeed)
	}
	if m.FieldCleared(forecast.FieldWindGust) {
		fields = append(fields, forecast.FieldWindGust)
	}
	if m.FieldCleared(forecast.FieldWindShearHeight) {
		fields = append(fields, forecast.FieldWindShearHeight)
	}
	if m.FieldCleared(forecast.FieldWindShearDirection) {
		fields = append(fields, forecast.FieldWindShearDirection)
	}
	if m.FieldCleared(forecast.FieldWindShearSpeed) {
		fields = append(fields, forecast.FieldWindShearSpeed)
	}
	if m.FieldCleared(forecast.FieldVisibilityHorizontal) {
		fields = append(fields, forecast.FieldVisibilityHorizontal)
	}
	if m.FieldCleared(forecast.FieldVisibilityVertical) {
		fields = append(fields, forecast.FieldVisibilityVertical)
	}
	if m.FieldCleared(forecast.FieldAltimeter) {
		fields = append(fields, forecast.FieldAltimeter)
	}
	if m.FieldCleared(forecast.FieldWeather) {
		fields = append(fields, forecast.FieldWeather)
	}
	if m.FieldCleared(forecast.FieldNotDecoded) {
		fields = append(fields, forecast.FieldNotDecoded)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ForecastMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ForecastMutation) ClearField(name string) error {
	switch name {
	case forecast.FieldChangeIndicator:
		m.ClearChangeIndicator()
		return nil
	case forecast.FieldChangeTime:
		m.ClearChangeTime()
		return nil
	case forecast.FieldChangeProbability:
		m.ClearChangeProbability()
		return nil
	case forecast.FieldWindDirection:
		m.ClearWindDirection()
		return nil
	case forecast.FieldWindSpeed:
		m.ClearWindSpeed()
		return nil
	case forecast.FieldWindGust:
		m.ClearWindGust()
		return nil
	case forecast.FieldWindShearHeight:
		m.ClearWindShearHeight()
		return nil
	case forecast.FieldWindShearDirection:
		m.ClearWindShearDirection()
		return nil
	case forecast.FieldWindShearSpeed:
		m.ClearWindShearSpeed()
		return nil
	case forecast.FieldVisibilityHorizontal:
		m.ClearVisibilityHorizontal()
		return nil
	case forecast.FieldVisibilityVertical:
		m.ClearVisibilityVertical()
		return nil
	case forecast.FieldAltimeter:
		m.ClearAltimeter()
		return nil
	case forecast.FieldWeather:
		m.ClearWeather()
		return nil
	case forecast.FieldNotDecoded:
		m.ClearNotDecoded()
		return nil
	}
	return fmt.Errorf("unknown Forecast nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ForecastMutation) ResetField(name string) error {
	switch name {
	case forecast.FieldFromTime:
		m.ResetFromTime()
		return nil
	case forecast.FieldToTime:
		m.ResetToTime()
		return nil
	case forecast.FieldChangeIndicator:
		m.ResetChangeIndicator()
		return nil
	case forecast.FieldChangeTime:
		m.ResetChangeTime()
		return nil
	case forecast.FieldChangeProbability:
		m.ResetChangeProbability()
		return nil
	case forecast.FieldWindDirection:
		m.ResetWindDirection()
		return nil
	case forecast.FieldWindDirectionVariable:
		m.ResetWindDirectionVariable()
		return nil
	case forecast.FieldWindSpeed:
		m.ResetWindSpeed()
		return nil
	case forecast.FieldWindGust:
		m.ResetWindGust()
		return nil
	case forecast.FieldWindShearHeight:
		m.ResetWindShearHeight()
		return nil
	case forecast.FieldWindShearDirection:
		m.ResetWindShearDirection()
		return nil
	case forecast.FieldWindShearSpeed:
		m.ResetWindShearSpeed()
		return nil
	case forecast.FieldVisibilityHorizontal:
		m.ResetVisibilityHorizontal()
		return nil
	case forecast.FieldVisibilityHorizontalIsMoreThan:
		m.ResetVisibilityHorizontalIsMoreThan()
		return nil
	case forecast.FieldVisibilityVertical:
		m.ResetVisibilityVertical()
		return nil
	case forecast.FieldAltimeter:
		m.ResetAltimeter()
		return nil
	case forecast.FieldWeather:
		m.ResetWeather()
		return nil
	case forecast.FieldNotDecoded:
		m.ResetNotDecoded()
		return nil
	}
	return fmt.Errorf("unknown Forecast field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ForecastMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.sky_conditions != nil {
		edges = append(edges, forecast.EdgeSkyConditions)
	}
	if m.turbulence_conditions != nil {
		edges = append(edges, forecast.EdgeTurbulenceConditions)
	}
	if m.icing_conditions != nil {
		edges = append(edges, forecast.EdgeIcingConditions)
	}
	if m.temperature_data != nil {
		edges = append(edges, forecast.EdgeTemperatureData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ForecastMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case forecast.EdgeSkyConditions:
		ids := make([]ent.Value, 0, len(m.sky_conditions))
		for id := range m.sky_conditions {
			ids = append(ids, id)
		}
		return ids
	case forecast.EdgeTurbulenceConditions:
		ids := make([]ent.Value, 0, len(m.turbulence_conditions))
		for id := range m.turbulence_conditions {
			ids = append(ids, id)
		}
		return ids
	case forecast.EdgeIcingConditions:
		ids := make([]ent.Value, 0, len(m.icing_conditions))
		for id := range m.icing_conditions {
			ids = append(ids, id)
		}
		return ids
	case forecast.EdgeTemperatureData:
		ids := make([]ent.Value, 0, len(m.temperature_data))
		for id := range m.temperature_data {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ForecastMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsky_conditions != nil {
		edges = append(edges, forecast.EdgeSkyConditions)
	}
	if m.removedturbulence_conditions != nil {
		edges = append(edges, forecast.EdgeTurbulenceConditions)
	}
	if m.removedicing_conditions != nil {
		edges = append(edges, forecast.EdgeIcingConditions)
	}
	if m.removedtemperature_data != nil {
		edges = append(edges, forecast.EdgeTemperatureData)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ForecastMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case forecast.EdgeSkyConditions:
		ids := make([]ent.Value, 0, len(m.removedsky_conditions))
		for id := range m.removedsky_conditions {
			ids = append(ids, id)
		}
		return ids
	case forecast.EdgeTurbulenceConditions:
		ids := make([]ent.Value, 0, len(m.removedturbulence_conditions))
		for id := range m.removedturbulence_conditions {
			ids = append(ids, id)
		}
		return ids
	case forecast.EdgeIcingConditions:
		ids := make([]ent.Value, 0, len(m.removedicing_conditions))
		for id := range m.removedicing_conditions {
			ids = append(ids, id)
		}
		return ids
	case forecast.EdgeTemperatureData:
		ids := make([]ent.Value, 0, len(m.removedtemperature_data))
		for id := range m.removedtemperature_data {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ForecastMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsky_conditions {
		edges = append(edges, forecast.EdgeSkyConditions)
	}
	if m.clearedturbulence_conditions {
		edges = append(edges, forecast.EdgeTurbulenceConditions)
	}
	if m.clearedicing_conditions {
		edges = append(edges, forecast.EdgeIcingConditions)
	}
	if m.clearedtemperature_data {
		edges = append(edges, forecast.EdgeTemperatureData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ForecastMutation) EdgeCleared(name string) bool {
	switch name {
	case forecast.EdgeSkyConditions:
		return m.clearedsky_conditions
	case forecast.EdgeTurbulenceConditions:
		return m.clearedturbulence_conditions
	case forecast.EdgeIcingConditions:
		return m.clearedicing_conditions
	case forecast.EdgeTemperatureData:
		return m.clearedtemperature_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ForecastMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Forecast unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ForecastMutation) ResetEdge(name string) error {
	switch name {
	case forecast.EdgeSkyConditions:
		m.ResetSkyConditions()
		return nil
	case forecast.EdgeTurbulenceConditions:
		m.ResetTurbulenceConditions()
		return nil
	case forecast.EdgeIcingConditions:
		m.ResetIcingConditions()
		return nil
	case forecast.EdgeTemperatureData:
		m.ResetTemperatureData()
		return nil
	}
	return fmt.Errorf("unknown Forecast edge %s", name)
}

// FrequencyMutation represents an operation that mutates the Frequency nodes in the graph.
type FrequencyMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	import_id      *int
	addimport_id   *int
	hash           *string
	import_flag    *bool
	last_updated   *time.Time
	_type          *string
	description    *string
	frequency      *float64
	addfrequency   *float64
	clearedFields  map[string]struct{}
	airport        *uuid.UUID
	clearedairport bool
	done           bool
	oldValue       func(context.Context) (*Frequency, error)
	predicates     []predicate.Frequency
}

var _ ent.Mutation = (*FrequencyMutation)(nil)

// frequencyOption allows management of the mutation configuration using functional options.
type frequencyOption func(*FrequencyMutation)

// newFrequencyMutation creates new mutation for the Frequency entity.
func newFrequencyMutation(c config, op Op, opts ...frequencyOption) *FrequencyMutation {
	m := &FrequencyMutation{
		config:        c,
		op:            op,
		typ:           TypeFrequency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrequencyID sets the ID field of the mutation.
func withFrequencyID(id uuid.UUID) frequencyOption {
	return func(m *FrequencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Frequency
		)
		m.oldValue = func(ctx context.Context) (*Frequency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Frequency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrequency sets the old Frequency of the mutation.
func withFrequency(node *Frequency) frequencyOption {
	return func(m *FrequencyMutation) {
		m.oldValue = func(context.Context) (*Frequency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrequencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrequencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Frequency entities.
func (m *FrequencyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrequencyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrequencyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Frequency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImportID sets the "import_id" field.
func (m *FrequencyMutation) SetImportID(i int) {
	m.import_id = &i
	m.addimport_id = nil
}

// ImportID returns the value of the "import_id" field in the mutation.
func (m *FrequencyMutation) ImportID() (r int, exists bool) {
	v := m.import_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImportID returns the old "import_id" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldImportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportID: %w", err)
	}
	return oldValue.ImportID, nil
}

// AddImportID adds i to the "import_id" field.
func (m *FrequencyMutation) AddImportID(i int) {
	if m.addimport_id != nil {
		*m.addimport_id += i
	} else {
		m.addimport_id = &i
	}
}

// AddedImportID returns the value that was added to the "import_id" field in this mutation.
func (m *FrequencyMutation) AddedImportID() (r int, exists bool) {
	v := m.addimport_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetImportID resets all changes to the "import_id" field.
func (m *FrequencyMutation) ResetImportID() {
	m.import_id = nil
	m.addimport_id = nil
}

// SetHash sets the "hash" field.
func (m *FrequencyMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *FrequencyMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *FrequencyMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *FrequencyMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *FrequencyMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *FrequencyMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *FrequencyMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *FrequencyMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *FrequencyMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetType sets the "type" field.
func (m *FrequencyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FrequencyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FrequencyMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *FrequencyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FrequencyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FrequencyMutation) ResetDescription() {
	m.description = nil
}

// SetFrequency sets the "frequency" field.
func (m *FrequencyMutation) SetFrequency(f float64) {
	m.frequency = &f
	m.addfrequency = nil
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *FrequencyMutation) Frequency() (r float64, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the Frequency entity.
// If the Frequency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrequencyMutation) OldFrequency(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// AddFrequency adds f to the "frequency" field.
func (m *FrequencyMutation) AddFrequency(f float64) {
	if m.addfrequency != nil {
		*m.addfrequency += f
	} else {
		m.addfrequency = &f
	}
}

// AddedFrequency returns the value that was added to the "frequency" field in this mutation.
func (m *FrequencyMutation) AddedFrequency() (r float64, exists bool) {
	v := m.addfrequency
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *FrequencyMutation) ResetFrequency() {
	m.frequency = nil
	m.addfrequency = nil
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *FrequencyMutation) SetAirportID(id uuid.UUID) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *FrequencyMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *FrequencyMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *FrequencyMutation) AirportID() (id uuid.UUID, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *FrequencyMutation) AirportIDs() (ids []uuid.UUID) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *FrequencyMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// Where appends a list predicates to the FrequencyMutation builder.
func (m *FrequencyMutation) Where(ps ...predicate.Frequency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FrequencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FrequencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Frequency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FrequencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FrequencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Frequency).
func (m *FrequencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrequencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.import_id != nil {
		fields = append(fields, frequency.FieldImportID)
	}
	if m.hash != nil {
		fields = append(fields, frequency.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, frequency.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, frequency.FieldLastUpdated)
	}
	if m._type != nil {
		fields = append(fields, frequency.FieldType)
	}
	if m.description != nil {
		fields = append(fields, frequency.FieldDescription)
	}
	if m.frequency != nil {
		fields = append(fields, frequency.FieldFrequency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrequencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frequency.FieldImportID:
		return m.ImportID()
	case frequency.FieldHash:
		return m.Hash()
	case frequency.FieldImportFlag:
		return m.ImportFlag()
	case frequency.FieldLastUpdated:
		return m.LastUpdated()
	case frequency.FieldType:
		return m.GetType()
	case frequency.FieldDescription:
		return m.Description()
	case frequency.FieldFrequency:
		return m.Frequency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrequencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frequency.FieldImportID:
		return m.OldImportID(ctx)
	case frequency.FieldHash:
		return m.OldHash(ctx)
	case frequency.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case frequency.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case frequency.FieldType:
		return m.OldType(ctx)
	case frequency.FieldDescription:
		return m.OldDescription(ctx)
	case frequency.FieldFrequency:
		return m.OldFrequency(ctx)
	}
	return nil, fmt.Errorf("unknown Frequency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrequencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frequency.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportID(v)
		return nil
	case frequency.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case frequency.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case frequency.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case frequency.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case frequency.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case frequency.FieldFrequency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	}
	return fmt.Errorf("unknown Frequency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrequencyMutation) AddedFields() []string {
	var fields []string
	if m.addimport_id != nil {
		fields = append(fields, frequency.FieldImportID)
	}
	if m.addfrequency != nil {
		fields = append(fields, frequency.FieldFrequency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrequencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frequency.FieldImportID:
		return m.AddedImportID()
	case frequency.FieldFrequency:
		return m.AddedFrequency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrequencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frequency.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportID(v)
		return nil
	case frequency.FieldFrequency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrequency(v)
		return nil
	}
	return fmt.Errorf("unknown Frequency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrequencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrequencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrequencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Frequency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrequencyMutation) ResetField(name string) error {
	switch name {
	case frequency.FieldImportID:
		m.ResetImportID()
		return nil
	case frequency.FieldHash:
		m.ResetHash()
		return nil
	case frequency.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case frequency.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case frequency.FieldType:
		m.ResetType()
		return nil
	case frequency.FieldDescription:
		m.ResetDescription()
		return nil
	case frequency.FieldFrequency:
		m.ResetFrequency()
		return nil
	}
	return fmt.Errorf("unknown Frequency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrequencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.airport != nil {
		edges = append(edges, frequency.EdgeAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrequencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frequency.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrequencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrequencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrequencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedairport {
		edges = append(edges, frequency.EdgeAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrequencyMutation) EdgeCleared(name string) bool {
	switch name {
	case frequency.EdgeAirport:
		return m.clearedairport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrequencyMutation) ClearEdge(name string) error {
	switch name {
	case frequency.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown Frequency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrequencyMutation) ResetEdge(name string) error {
	switch name {
	case frequency.EdgeAirport:
		m.ResetAirport()
		return nil
	}
	return fmt.Errorf("unknown Frequency edge %s", name)
}

// IcingConditionMutation represents an operation that mutates the IcingCondition nodes in the graph.
type IcingConditionMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	intensity       *string
	min_altitude    *int
	addmin_altitude *int
	max_altitude    *int
	addmax_altitude *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*IcingCondition, error)
	predicates      []predicate.IcingCondition
}

var _ ent.Mutation = (*IcingConditionMutation)(nil)

// icingconditionOption allows management of the mutation configuration using functional options.
type icingconditionOption func(*IcingConditionMutation)

// newIcingConditionMutation creates new mutation for the IcingCondition entity.
func newIcingConditionMutation(c config, op Op, opts ...icingconditionOption) *IcingConditionMutation {
	m := &IcingConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeIcingCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIcingConditionID sets the ID field of the mutation.
func withIcingConditionID(id uuid.UUID) icingconditionOption {
	return func(m *IcingConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *IcingCondition
		)
		m.oldValue = func(ctx context.Context) (*IcingCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IcingCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIcingCondition sets the old IcingCondition of the mutation.
func withIcingCondition(node *IcingCondition) icingconditionOption {
	return func(m *IcingConditionMutation) {
		m.oldValue = func(context.Context) (*IcingCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IcingConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IcingConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IcingCondition entities.
func (m *IcingConditionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IcingConditionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IcingConditionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IcingCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIntensity sets the "intensity" field.
func (m *IcingConditionMutation) SetIntensity(s string) {
	m.intensity = &s
}

// Intensity returns the value of the "intensity" field in the mutation.
func (m *IcingConditionMutation) Intensity() (r string, exists bool) {
	v := m.intensity
	if v == nil {
		return
	}
	return *v, true
}

// OldIntensity returns the old "intensity" field's value of the IcingCondition entity.
// If the IcingCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcingConditionMutation) OldIntensity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntensity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntensity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntensity: %w", err)
	}
	return oldValue.Intensity, nil
}

// ResetIntensity resets all changes to the "intensity" field.
func (m *IcingConditionMutation) ResetIntensity() {
	m.intensity = nil
}

// SetMinAltitude sets the "min_altitude" field.
func (m *IcingConditionMutation) SetMinAltitude(i int) {
	m.min_altitude = &i
	m.addmin_altitude = nil
}

// MinAltitude returns the value of the "min_altitude" field in the mutation.
func (m *IcingConditionMutation) MinAltitude() (r int, exists bool) {
	v := m.min_altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldMinAltitude returns the old "min_altitude" field's value of the IcingCondition entity.
// If the IcingCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcingConditionMutation) OldMinAltitude(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinAltitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinAltitude: %w", err)
	}
	return oldValue.MinAltitude, nil
}

// AddMinAltitude adds i to the "min_altitude" field.
func (m *IcingConditionMutation) AddMinAltitude(i int) {
	if m.addmin_altitude != nil {
		*m.addmin_altitude += i
	} else {
		m.addmin_altitude = &i
	}
}

// AddedMinAltitude returns the value that was added to the "min_altitude" field in this mutation.
func (m *IcingConditionMutation) AddedMinAltitude() (r int, exists bool) {
	v := m.addmin_altitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinAltitude clears the value of the "min_altitude" field.
func (m *IcingConditionMutation) ClearMinAltitude() {
	m.min_altitude = nil
	m.addmin_altitude = nil
	m.clearedFields[icingcondition.FieldMinAltitude] = struct{}{}
}

// MinAltitudeCleared returns if the "min_altitude" field was cleared in this mutation.
func (m *IcingConditionMutation) MinAltitudeCleared() bool {
	_, ok := m.clearedFields[icingcondition.FieldMinAltitude]
	return ok
}

// ResetMinAltitude resets all changes to the "min_altitude" field.
func (m *IcingConditionMutation) ResetMinAltitude() {
	m.min_altitude = nil
	m.addmin_altitude = nil
	delete(m.clearedFields, icingcondition.FieldMinAltitude)
}

// SetMaxAltitude sets the "max_altitude" field.
func (m *IcingConditionMutation) SetMaxAltitude(i int) {
	m.max_altitude = &i
	m.addmax_altitude = nil
}

// MaxAltitude returns the value of the "max_altitude" field in the mutation.
func (m *IcingConditionMutation) MaxAltitude() (r int, exists bool) {
	v := m.max_altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAltitude returns the old "max_altitude" field's value of the IcingCondition entity.
// If the IcingCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcingConditionMutation) OldMaxAltitude(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAltitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAltitude: %w", err)
	}
	return oldValue.MaxAltitude, nil
}

// AddMaxAltitude adds i to the "max_altitude" field.
func (m *IcingConditionMutation) AddMaxAltitude(i int) {
	if m.addmax_altitude != nil {
		*m.addmax_altitude += i
	} else {
		m.addmax_altitude = &i
	}
}

// AddedMaxAltitude returns the value that was added to the "max_altitude" field in this mutation.
func (m *IcingConditionMutation) AddedMaxAltitude() (r int, exists bool) {
	v := m.addmax_altitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxAltitude clears the value of the "max_altitude" field.
func (m *IcingConditionMutation) ClearMaxAltitude() {
	m.max_altitude = nil
	m.addmax_altitude = nil
	m.clearedFields[icingcondition.FieldMaxAltitude] = struct{}{}
}

// MaxAltitudeCleared returns if the "max_altitude" field was cleared in this mutation.
func (m *IcingConditionMutation) MaxAltitudeCleared() bool {
	_, ok := m.clearedFields[icingcondition.FieldMaxAltitude]
	return ok
}

// ResetMaxAltitude resets all changes to the "max_altitude" field.
func (m *IcingConditionMutation) ResetMaxAltitude() {
	m.max_altitude = nil
	m.addmax_altitude = nil
	delete(m.clearedFields, icingcondition.FieldMaxAltitude)
}

// Where appends a list predicates to the IcingConditionMutation builder.
func (m *IcingConditionMutation) Where(ps ...predicate.IcingCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IcingConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IcingConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IcingCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IcingConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IcingConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IcingCondition).
func (m *IcingConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IcingConditionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.intensity != nil {
		fields = append(fields, icingcondition.FieldIntensity)
	}
	if m.min_altitude != nil {
		fields = append(fields, icingcondition.FieldMinAltitude)
	}
	if m.max_altitude != nil {
		fields = append(fields, icingcondition.FieldMaxAltitude)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IcingConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case icingcondition.FieldIntensity:
		return m.Intensity()
	case icingcondition.FieldMinAltitude:
		return m.MinAltitude()
	case icingcondition.FieldMaxAltitude:
		return m.MaxAltitude()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IcingConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case icingcondition.FieldIntensity:
		return m.OldIntensity(ctx)
	case icingcondition.FieldMinAltitude:
		return m.OldMinAltitude(ctx)
	case icingcondition.FieldMaxAltitude:
		return m.OldMaxAltitude(ctx)
	}
	return nil, fmt.Errorf("unknown IcingCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcingConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case icingcondition.FieldIntensity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntensity(v)
		return nil
	case icingcondition.FieldMinAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinAltitude(v)
		return nil
	case icingcondition.FieldMaxAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAltitude(v)
		return nil
	}
	return fmt.Errorf("unknown IcingCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IcingConditionMutation) AddedFields() []string {
	var fields []string
	if m.addmin_altitude != nil {
		fields = append(fields, icingcondition.FieldMinAltitude)
	}
	if m.addmax_altitude != nil {
		fields = append(fields, icingcondition.FieldMaxAltitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IcingConditionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case icingcondition.FieldMinAltitude:
		return m.AddedMinAltitude()
	case icingcondition.FieldMaxAltitude:
		return m.AddedMaxAltitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcingConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case icingcondition.FieldMinAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinAltitude(v)
		return nil
	case icingcondition.FieldMaxAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAltitude(v)
		return nil
	}
	return fmt.Errorf("unknown IcingCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IcingConditionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(icingcondition.FieldMinAltitude) {
		fields = append(fields, icingcondition.FieldMinAltitude)
	}
	if m.FieldCleared(icingcondition.FieldMaxAltitude) {
		fields = append(fields, icingcondition.FieldMaxAltitude)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IcingConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IcingConditionMutation) ClearField(name string) error {
	switch name {
	case icingcondition.FieldMinAltitude:
		m.ClearMinAltitude()
		return nil
	case icingcondition.FieldMaxAltitude:
		m.ClearMaxAltitude()
		return nil
	}
	return fmt.Errorf("unknown IcingCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IcingConditionMutation) ResetField(name string) error {
	switch name {
	case icingcondition.FieldIntensity:
		m.ResetIntensity()
		return nil
	case icingcondition.FieldMinAltitude:
		m.ResetMinAltitude()
		return nil
	case icingcondition.FieldMaxAltitude:
		m.ResetMaxAltitude()
		return nil
	}
	return fmt.Errorf("unknown IcingCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IcingConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IcingConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IcingConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IcingConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IcingConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IcingConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IcingConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IcingCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IcingConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IcingCondition edge %s", name)
}

// MetarMutation represents an operation that mutates the Metar nodes in the graph.
type MetarMutation struct {
	config
	op                                         Op
	typ                                        string
	id                                         *uuid.UUID
	raw_text                                   *string
	observation_time                           *time.Time
	import_time                                *time.Time
	next_import_time_prediction                *time.Time
	temperature                                *float64
	addtemperature                             *float64
	dewpoint                                   *float64
	adddewpoint                                *float64
	wind_speed                                 *int
	addwind_speed                              *int
	wind_gust                                  *int
	addwind_gust                               *int
	wind_direction                             *int
	addwind_direction                          *int
	wind_direction_variable                    *bool
	visibility                                 *float64
	addvisibility                              *float64
	visibility_is_more_than                    *bool
	altimeter                                  *float64
	addaltimeter                               *float64
	present_weather                            *string
	flight_category                            *metar.FlightCategory
	quality_control_corrected                  *bool
	quality_control_auto_station               *bool
	quality_control_maintenance_indicator_on   *bool
	quality_control_no_signal                  *bool
	quality_control_lightning_sensor_off       *bool
	quality_control_freezing_rain_sensor_off   *bool
	quality_control_present_weather_sensor_off *bool
	sea_level_pressure                         *float64
	addsea_level_pressure                      *float64
	pressure_tendency                          *float64
	addpressure_tendency                       *float64
	max_temp_6                                 *float64
	addmax_temp_6                              *float64
	min_temp_6                                 *float64
	addmin_temp_6                              *float64
	max_temp_24                                *float64
	addmax_temp_24                             *float64
	min_temp_24                                *float64
	addmin_temp_24                             *float64
	precipitation                              *float64
	addprecipitation                           *float64
	precipitation_3                            *float64
	addprecipitation_3                         *float64
	precipitation_6                            *float64
	addprecipitation_6                         *float64
	precipitation_24                           *float64
	addprecipitation_24                        *float64
	snow_depth                                 *float64
	addsnow_depth                              *float64
	vert_vis                                   *float64
	addvert_vis                                *float64
	metar_type                                 *metar.MetarType
	hash                                       *string
	clearedFields                              map[string]struct{}
	station                                    *uuid.UUID
	clearedstation                             bool
	sky_conditions                             map[uuid.UUID]struct{}
	removedsky_conditions                      map[uuid.UUID]struct{}
	clearedsky_conditions                      bool
	done                                       bool
	oldValue                                   func(context.Context) (*Metar, error)
	predicates                                 []predicate.Metar
}

var _ ent.Mutation = (*MetarMutation)(nil)

// metarOption allows management of the mutation configuration using functional options.
type metarOption func(*MetarMutation)

// newMetarMutation creates new mutation for the Metar entity.
func newMetarMutation(c config, op Op, opts ...metarOption) *MetarMutation {
	m := &MetarMutation{
		config:        c,
		op:            op,
		typ:           TypeMetar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetarID sets the ID field of the mutation.
func withMetarID(id uuid.UUID) metarOption {
	return func(m *MetarMutation) {
		var (
			err   error
			once  sync.Once
			value *Metar
		)
		m.oldValue = func(ctx context.Context) (*Metar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetar sets the old Metar of the mutation.
func withMetar(node *Metar) metarOption {
	return func(m *MetarMutation) {
		m.oldValue = func(context.Context) (*Metar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metar entities.
func (m *MetarMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetarMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetarMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRawText sets the "raw_text" field.
func (m *MetarMutation) SetRawText(s string) {
	m.raw_text = &s
}

// RawText returns the value of the "raw_text" field in the mutation.
func (m *MetarMutation) RawText() (r string, exists bool) {
	v := m.raw_text
	if v == nil {
		return
	}
	return *v, true
}

// OldRawText returns the old "raw_text" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldRawText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawText: %w", err)
	}
	return oldValue.RawText, nil
}

// ResetRawText resets all changes to the "raw_text" field.
func (m *MetarMutation) ResetRawText() {
	m.raw_text = nil
}

// SetObservationTime sets the "observation_time" field.
func (m *MetarMutation) SetObservationTime(t time.Time) {
	m.observation_time = &t
}

// ObservationTime returns the value of the "observation_time" field in the mutation.
func (m *MetarMutation) ObservationTime() (r time.Time, exists bool) {
	v := m.observation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldObservationTime returns the old "observation_time" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldObservationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObservationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObservationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObservationTime: %w", err)
	}
	return oldValue.ObservationTime, nil
}

// ResetObservationTime resets all changes to the "observation_time" field.
func (m *MetarMutation) ResetObservationTime() {
	m.observation_time = nil
}

// SetImportTime sets the "import_time" field.
func (m *MetarMutation) SetImportTime(t time.Time) {
	m.import_time = &t
}

// ImportTime returns the value of the "import_time" field in the mutation.
func (m *MetarMutation) ImportTime() (r time.Time, exists bool) {
	v := m.import_time
	if v == nil {
		return
	}
	return *v, true
}

// OldImportTime returns the old "import_time" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldImportTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportTime: %w", err)
	}
	return oldValue.ImportTime, nil
}

// ResetImportTime resets all changes to the "import_time" field.
func (m *MetarMutation) ResetImportTime() {
	m.import_time = nil
}

// SetNextImportTimePrediction sets the "next_import_time_prediction" field.
func (m *MetarMutation) SetNextImportTimePrediction(t time.Time) {
	m.next_import_time_prediction = &t
}

// NextImportTimePrediction returns the value of the "next_import_time_prediction" field in the mutation.
func (m *MetarMutation) NextImportTimePrediction() (r time.Time, exists bool) {
	v := m.next_import_time_prediction
	if v == nil {
		return
	}
	return *v, true
}

// OldNextImportTimePrediction returns the old "next_import_time_prediction" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldNextImportTimePrediction(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextImportTimePrediction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextImportTimePrediction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextImportTimePrediction: %w", err)
	}
	return oldValue.NextImportTimePrediction, nil
}

// ClearNextImportTimePrediction clears the value of the "next_import_time_prediction" field.
func (m *MetarMutation) ClearNextImportTimePrediction() {
	m.next_import_time_prediction = nil
	m.clearedFields[metar.FieldNextImportTimePrediction] = struct{}{}
}

// NextImportTimePredictionCleared returns if the "next_import_time_prediction" field was cleared in this mutation.
func (m *MetarMutation) NextImportTimePredictionCleared() bool {
	_, ok := m.clearedFields[metar.FieldNextImportTimePrediction]
	return ok
}

// ResetNextImportTimePrediction resets all changes to the "next_import_time_prediction" field.
func (m *MetarMutation) ResetNextImportTimePrediction() {
	m.next_import_time_prediction = nil
	delete(m.clearedFields, metar.FieldNextImportTimePrediction)
}

// SetTemperature sets the "temperature" field.
func (m *MetarMutation) SetTemperature(f float64) {
	m.temperature = &f
	m.addtemperature = nil
}

// Temperature returns the value of the "temperature" field in the mutation.
func (m *MetarMutation) Temperature() (r float64, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old "temperature" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldTemperature(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds f to the "temperature" field.
func (m *MetarMutation) AddTemperature(f float64) {
	if m.addtemperature != nil {
		*m.addtemperature += f
	} else {
		m.addtemperature = &f
	}
}

// AddedTemperature returns the value that was added to the "temperature" field in this mutation.
func (m *MetarMutation) AddedTemperature() (r float64, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ClearTemperature clears the value of the "temperature" field.
func (m *MetarMutation) ClearTemperature() {
	m.temperature = nil
	m.addtemperature = nil
	m.clearedFields[metar.FieldTemperature] = struct{}{}
}

// TemperatureCleared returns if the "temperature" field was cleared in this mutation.
func (m *MetarMutation) TemperatureCleared() bool {
	_, ok := m.clearedFields[metar.FieldTemperature]
	return ok
}

// ResetTemperature resets all changes to the "temperature" field.
func (m *MetarMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
	delete(m.clearedFields, metar.FieldTemperature)
}

// SetDewpoint sets the "dewpoint" field.
func (m *MetarMutation) SetDewpoint(f float64) {
	m.dewpoint = &f
	m.adddewpoint = nil
}

// Dewpoint returns the value of the "dewpoint" field in the mutation.
func (m *MetarMutation) Dewpoint() (r float64, exists bool) {
	v := m.dewpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldDewpoint returns the old "dewpoint" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldDewpoint(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDewpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDewpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDewpoint: %w", err)
	}
	return oldValue.Dewpoint, nil
}

// AddDewpoint adds f to the "dewpoint" field.
func (m *MetarMutation) AddDewpoint(f float64) {
	if m.adddewpoint != nil {
		*m.adddewpoint += f
	} else {
		m.adddewpoint = &f
	}
}

// AddedDewpoint returns the value that was added to the "dewpoint" field in this mutation.
func (m *MetarMutation) AddedDewpoint() (r float64, exists bool) {
	v := m.adddewpoint
	if v == nil {
		return
	}
	return *v, true
}

// ClearDewpoint clears the value of the "dewpoint" field.
func (m *MetarMutation) ClearDewpoint() {
	m.dewpoint = nil
	m.adddewpoint = nil
	m.clearedFields[metar.FieldDewpoint] = struct{}{}
}

// DewpointCleared returns if the "dewpoint" field was cleared in this mutation.
func (m *MetarMutation) DewpointCleared() bool {
	_, ok := m.clearedFields[metar.FieldDewpoint]
	return ok
}

// ResetDewpoint resets all changes to the "dewpoint" field.
func (m *MetarMutation) ResetDewpoint() {
	m.dewpoint = nil
	m.adddewpoint = nil
	delete(m.clearedFields, metar.FieldDewpoint)
}

// SetWindSpeed sets the "wind_speed" field.
func (m *MetarMutation) SetWindSpeed(i int) {
	m.wind_speed = &i
	m.addwind_speed = nil
}

// WindSpeed returns the value of the "wind_speed" field in the mutation.
func (m *MetarMutation) WindSpeed() (r int, exists bool) {
	v := m.wind_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldWindSpeed returns the old "wind_speed" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldWindSpeed(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindSpeed: %w", err)
	}
	return oldValue.WindSpeed, nil
}

// AddWindSpeed adds i to the "wind_speed" field.
func (m *MetarMutation) AddWindSpeed(i int) {
	if m.addwind_speed != nil {
		*m.addwind_speed += i
	} else {
		m.addwind_speed = &i
	}
}

// AddedWindSpeed returns the value that was added to the "wind_speed" field in this mutation.
func (m *MetarMutation) AddedWindSpeed() (r int, exists bool) {
	v := m.addwind_speed
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindSpeed clears the value of the "wind_speed" field.
func (m *MetarMutation) ClearWindSpeed() {
	m.wind_speed = nil
	m.addwind_speed = nil
	m.clearedFields[metar.FieldWindSpeed] = struct{}{}
}

// WindSpeedCleared returns if the "wind_speed" field was cleared in this mutation.
func (m *MetarMutation) WindSpeedCleared() bool {
	_, ok := m.clearedFields[metar.FieldWindSpeed]
	return ok
}

// ResetWindSpeed resets all changes to the "wind_speed" field.
func (m *MetarMutation) ResetWindSpeed() {
	m.wind_speed = nil
	m.addwind_speed = nil
	delete(m.clearedFields, metar.FieldWindSpeed)
}

// SetWindGust sets the "wind_gust" field.
func (m *MetarMutation) SetWindGust(i int) {
	m.wind_gust = &i
	m.addwind_gust = nil
}

// WindGust returns the value of the "wind_gust" field in the mutation.
func (m *MetarMutation) WindGust() (r int, exists bool) {
	v := m.wind_gust
	if v == nil {
		return
	}
	return *v, true
}

// OldWindGust returns the old "wind_gust" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldWindGust(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindGust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindGust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindGust: %w", err)
	}
	return oldValue.WindGust, nil
}

// AddWindGust adds i to the "wind_gust" field.
func (m *MetarMutation) AddWindGust(i int) {
	if m.addwind_gust != nil {
		*m.addwind_gust += i
	} else {
		m.addwind_gust = &i
	}
}

// AddedWindGust returns the value that was added to the "wind_gust" field in this mutation.
func (m *MetarMutation) AddedWindGust() (r int, exists bool) {
	v := m.addwind_gust
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindGust clears the value of the "wind_gust" field.
func (m *MetarMutation) ClearWindGust() {
	m.wind_gust = nil
	m.addwind_gust = nil
	m.clearedFields[metar.FieldWindGust] = struct{}{}
}

// WindGustCleared returns if the "wind_gust" field was cleared in this mutation.
func (m *MetarMutation) WindGustCleared() bool {
	_, ok := m.clearedFields[metar.FieldWindGust]
	return ok
}

// ResetWindGust resets all changes to the "wind_gust" field.
func (m *MetarMutation) ResetWindGust() {
	m.wind_gust = nil
	m.addwind_gust = nil
	delete(m.clearedFields, metar.FieldWindGust)
}

// SetWindDirection sets the "wind_direction" field.
func (m *MetarMutation) SetWindDirection(i int) {
	m.wind_direction = &i
	m.addwind_direction = nil
}

// WindDirection returns the value of the "wind_direction" field in the mutation.
func (m *MetarMutation) WindDirection() (r int, exists bool) {
	v := m.wind_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirection returns the old "wind_direction" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldWindDirection(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirection: %w", err)
	}
	return oldValue.WindDirection, nil
}

// AddWindDirection adds i to the "wind_direction" field.
func (m *MetarMutation) AddWindDirection(i int) {
	if m.addwind_direction != nil {
		*m.addwind_direction += i
	} else {
		m.addwind_direction = &i
	}
}

// AddedWindDirection returns the value that was added to the "wind_direction" field in this mutation.
func (m *MetarMutation) AddedWindDirection() (r int, exists bool) {
	v := m.addwind_direction
	if v == nil {
		return
	}
	return *v, true
}

// ClearWindDirection clears the value of the "wind_direction" field.
func (m *MetarMutation) ClearWindDirection() {
	m.wind_direction = nil
	m.addwind_direction = nil
	m.clearedFields[metar.FieldWindDirection] = struct{}{}
}

// WindDirectionCleared returns if the "wind_direction" field was cleared in this mutation.
func (m *MetarMutation) WindDirectionCleared() bool {
	_, ok := m.clearedFields[metar.FieldWindDirection]
	return ok
}

// ResetWindDirection resets all changes to the "wind_direction" field.
func (m *MetarMutation) ResetWindDirection() {
	m.wind_direction = nil
	m.addwind_direction = nil
	delete(m.clearedFields, metar.FieldWindDirection)
}

// SetWindDirectionVariable sets the "wind_direction_variable" field.
func (m *MetarMutation) SetWindDirectionVariable(b bool) {
	m.wind_direction_variable = &b
}

// WindDirectionVariable returns the value of the "wind_direction_variable" field in the mutation.
func (m *MetarMutation) WindDirectionVariable() (r bool, exists bool) {
	v := m.wind_direction_variable
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirectionVariable returns the old "wind_direction_variable" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldWindDirectionVariable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindDirectionVariable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindDirectionVariable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirectionVariable: %w", err)
	}
	return oldValue.WindDirectionVariable, nil
}

// ResetWindDirectionVariable resets all changes to the "wind_direction_variable" field.
func (m *MetarMutation) ResetWindDirectionVariable() {
	m.wind_direction_variable = nil
}

// SetVisibility sets the "visibility" field.
func (m *MetarMutation) SetVisibility(f float64) {
	m.visibility = &f
	m.addvisibility = nil
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *MetarMutation) Visibility() (r float64, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldVisibility(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// AddVisibility adds f to the "visibility" field.
func (m *MetarMutation) AddVisibility(f float64) {
	if m.addvisibility != nil {
		*m.addvisibility += f
	} else {
		m.addvisibility = &f
	}
}

// AddedVisibility returns the value that was added to the "visibility" field in this mutation.
func (m *MetarMutation) AddedVisibility() (r float64, exists bool) {
	v := m.addvisibility
	if v == nil {
		return
	}
	return *v, true
}

// ClearVisibility clears the value of the "visibility" field.
func (m *MetarMutation) ClearVisibility() {
	m.visibility = nil
	m.addvisibility = nil
	m.clearedFields[metar.FieldVisibility] = struct{}{}
}

// VisibilityCleared returns if the "visibility" field was cleared in this mutation.
func (m *MetarMutation) VisibilityCleared() bool {
	_, ok := m.clearedFields[metar.FieldVisibility]
	return ok
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *MetarMutation) ResetVisibility() {
	m.visibility = nil
	m.addvisibility = nil
	delete(m.clearedFields, metar.FieldVisibility)
}

// SetVisibilityIsMoreThan sets the "visibility_is_more_than" field.
func (m *MetarMutation) SetVisibilityIsMoreThan(b bool) {
	m.visibility_is_more_than = &b
}

// VisibilityIsMoreThan returns the value of the "visibility_is_more_than" field in the mutation.
func (m *MetarMutation) VisibilityIsMoreThan() (r bool, exists bool) {
	v := m.visibility_is_more_than
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibilityIsMoreThan returns the old "visibility_is_more_than" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldVisibilityIsMoreThan(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibilityIsMoreThan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibilityIsMoreThan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibilityIsMoreThan: %w", err)
	}
	return oldValue.VisibilityIsMoreThan, nil
}

// ResetVisibilityIsMoreThan resets all changes to the "visibility_is_more_than" field.
func (m *MetarMutation) ResetVisibilityIsMoreThan() {
	m.visibility_is_more_than = nil
}

// SetAltimeter sets the "altimeter" field.
func (m *MetarMutation) SetAltimeter(f float64) {
	m.altimeter = &f
	m.addaltimeter = nil
}

// Altimeter returns the value of the "altimeter" field in the mutation.
func (m *MetarMutation) Altimeter() (r float64, exists bool) {
	v := m.altimeter
	if v == nil {
		return
	}
	return *v, true
}

// OldAltimeter returns the old "altimeter" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldAltimeter(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltimeter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltimeter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltimeter: %w", err)
	}
	return oldValue.Altimeter, nil
}

// AddAltimeter adds f to the "altimeter" field.
func (m *MetarMutation) AddAltimeter(f float64) {
	if m.addaltimeter != nil {
		*m.addaltimeter += f
	} else {
		m.addaltimeter = &f
	}
}

// AddedAltimeter returns the value that was added to the "altimeter" field in this mutation.
func (m *MetarMutation) AddedAltimeter() (r float64, exists bool) {
	v := m.addaltimeter
	if v == nil {
		return
	}
	return *v, true
}

// ClearAltimeter clears the value of the "altimeter" field.
func (m *MetarMutation) ClearAltimeter() {
	m.altimeter = nil
	m.addaltimeter = nil
	m.clearedFields[metar.FieldAltimeter] = struct{}{}
}

// AltimeterCleared returns if the "altimeter" field was cleared in this mutation.
func (m *MetarMutation) AltimeterCleared() bool {
	_, ok := m.clearedFields[metar.FieldAltimeter]
	return ok
}

// ResetAltimeter resets all changes to the "altimeter" field.
func (m *MetarMutation) ResetAltimeter() {
	m.altimeter = nil
	m.addaltimeter = nil
	delete(m.clearedFields, metar.FieldAltimeter)
}

// SetPresentWeather sets the "present_weather" field.
func (m *MetarMutation) SetPresentWeather(s string) {
	m.present_weather = &s
}

// PresentWeather returns the value of the "present_weather" field in the mutation.
func (m *MetarMutation) PresentWeather() (r string, exists bool) {
	v := m.present_weather
	if v == nil {
		return
	}
	return *v, true
}

// OldPresentWeather returns the old "present_weather" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPresentWeather(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresentWeather is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresentWeather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresentWeather: %w", err)
	}
	return oldValue.PresentWeather, nil
}

// ClearPresentWeather clears the value of the "present_weather" field.
func (m *MetarMutation) ClearPresentWeather() {
	m.present_weather = nil
	m.clearedFields[metar.FieldPresentWeather] = struct{}{}
}

// PresentWeatherCleared returns if the "present_weather" field was cleared in this mutation.
func (m *MetarMutation) PresentWeatherCleared() bool {
	_, ok := m.clearedFields[metar.FieldPresentWeather]
	return ok
}

// ResetPresentWeather resets all changes to the "present_weather" field.
func (m *MetarMutation) ResetPresentWeather() {
	m.present_weather = nil
	delete(m.clearedFields, metar.FieldPresentWeather)
}

// SetFlightCategory sets the "flight_category" field.
func (m *MetarMutation) SetFlightCategory(mc metar.FlightCategory) {
	m.flight_category = &mc
}

// FlightCategory returns the value of the "flight_category" field in the mutation.
func (m *MetarMutation) FlightCategory() (r metar.FlightCategory, exists bool) {
	v := m.flight_category
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightCategory returns the old "flight_category" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldFlightCategory(ctx context.Context) (v *metar.FlightCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightCategory: %w", err)
	}
	return oldValue.FlightCategory, nil
}

// ClearFlightCategory clears the value of the "flight_category" field.
func (m *MetarMutation) ClearFlightCategory() {
	m.flight_category = nil
	m.clearedFields[metar.FieldFlightCategory] = struct{}{}
}

// FlightCategoryCleared returns if the "flight_category" field was cleared in this mutation.
func (m *MetarMutation) FlightCategoryCleared() bool {
	_, ok := m.clearedFields[metar.FieldFlightCategory]
	return ok
}

// ResetFlightCategory resets all changes to the "flight_category" field.
func (m *MetarMutation) ResetFlightCategory() {
	m.flight_category = nil
	delete(m.clearedFields, metar.FieldFlightCategory)
}

// SetQualityControlCorrected sets the "quality_control_corrected" field.
func (m *MetarMutation) SetQualityControlCorrected(b bool) {
	m.quality_control_corrected = &b
}

// QualityControlCorrected returns the value of the "quality_control_corrected" field in the mutation.
func (m *MetarMutation) QualityControlCorrected() (r bool, exists bool) {
	v := m.quality_control_corrected
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlCorrected returns the old "quality_control_corrected" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlCorrected(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlCorrected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlCorrected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlCorrected: %w", err)
	}
	return oldValue.QualityControlCorrected, nil
}

// ClearQualityControlCorrected clears the value of the "quality_control_corrected" field.
func (m *MetarMutation) ClearQualityControlCorrected() {
	m.quality_control_corrected = nil
	m.clearedFields[metar.FieldQualityControlCorrected] = struct{}{}
}

// QualityControlCorrectedCleared returns if the "quality_control_corrected" field was cleared in this mutation.
func (m *MetarMutation) QualityControlCorrectedCleared() bool {
	_, ok := m.clearedFields[metar.FieldQualityControlCorrected]
	return ok
}

// ResetQualityControlCorrected resets all changes to the "quality_control_corrected" field.
func (m *MetarMutation) ResetQualityControlCorrected() {
	m.quality_control_corrected = nil
	delete(m.clearedFields, metar.FieldQualityControlCorrected)
}

// SetQualityControlAutoStation sets the "quality_control_auto_station" field.
func (m *MetarMutation) SetQualityControlAutoStation(b bool) {
	m.quality_control_auto_station = &b
}

// QualityControlAutoStation returns the value of the "quality_control_auto_station" field in the mutation.
func (m *MetarMutation) QualityControlAutoStation() (r bool, exists bool) {
	v := m.quality_control_auto_station
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlAutoStation returns the old "quality_control_auto_station" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlAutoStation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlAutoStation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlAutoStation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlAutoStation: %w", err)
	}
	return oldValue.QualityControlAutoStation, nil
}

// ResetQualityControlAutoStation resets all changes to the "quality_control_auto_station" field.
func (m *MetarMutation) ResetQualityControlAutoStation() {
	m.quality_control_auto_station = nil
}

// SetQualityControlMaintenanceIndicatorOn sets the "quality_control_maintenance_indicator_on" field.
func (m *MetarMutation) SetQualityControlMaintenanceIndicatorOn(b bool) {
	m.quality_control_maintenance_indicator_on = &b
}

// QualityControlMaintenanceIndicatorOn returns the value of the "quality_control_maintenance_indicator_on" field in the mutation.
func (m *MetarMutation) QualityControlMaintenanceIndicatorOn() (r bool, exists bool) {
	v := m.quality_control_maintenance_indicator_on
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlMaintenanceIndicatorOn returns the old "quality_control_maintenance_indicator_on" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlMaintenanceIndicatorOn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlMaintenanceIndicatorOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlMaintenanceIndicatorOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlMaintenanceIndicatorOn: %w", err)
	}
	return oldValue.QualityControlMaintenanceIndicatorOn, nil
}

// ResetQualityControlMaintenanceIndicatorOn resets all changes to the "quality_control_maintenance_indicator_on" field.
func (m *MetarMutation) ResetQualityControlMaintenanceIndicatorOn() {
	m.quality_control_maintenance_indicator_on = nil
}

// SetQualityControlNoSignal sets the "quality_control_no_signal" field.
func (m *MetarMutation) SetQualityControlNoSignal(b bool) {
	m.quality_control_no_signal = &b
}

// QualityControlNoSignal returns the value of the "quality_control_no_signal" field in the mutation.
func (m *MetarMutation) QualityControlNoSignal() (r bool, exists bool) {
	v := m.quality_control_no_signal
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlNoSignal returns the old "quality_control_no_signal" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlNoSignal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlNoSignal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlNoSignal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlNoSignal: %w", err)
	}
	return oldValue.QualityControlNoSignal, nil
}

// ResetQualityControlNoSignal resets all changes to the "quality_control_no_signal" field.
func (m *MetarMutation) ResetQualityControlNoSignal() {
	m.quality_control_no_signal = nil
}

// SetQualityControlLightningSensorOff sets the "quality_control_lightning_sensor_off" field.
func (m *MetarMutation) SetQualityControlLightningSensorOff(b bool) {
	m.quality_control_lightning_sensor_off = &b
}

// QualityControlLightningSensorOff returns the value of the "quality_control_lightning_sensor_off" field in the mutation.
func (m *MetarMutation) QualityControlLightningSensorOff() (r bool, exists bool) {
	v := m.quality_control_lightning_sensor_off
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlLightningSensorOff returns the old "quality_control_lightning_sensor_off" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlLightningSensorOff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlLightningSensorOff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlLightningSensorOff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlLightningSensorOff: %w", err)
	}
	return oldValue.QualityControlLightningSensorOff, nil
}

// ResetQualityControlLightningSensorOff resets all changes to the "quality_control_lightning_sensor_off" field.
func (m *MetarMutation) ResetQualityControlLightningSensorOff() {
	m.quality_control_lightning_sensor_off = nil
}

// SetQualityControlFreezingRainSensorOff sets the "quality_control_freezing_rain_sensor_off" field.
func (m *MetarMutation) SetQualityControlFreezingRainSensorOff(b bool) {
	m.quality_control_freezing_rain_sensor_off = &b
}

// QualityControlFreezingRainSensorOff returns the value of the "quality_control_freezing_rain_sensor_off" field in the mutation.
func (m *MetarMutation) QualityControlFreezingRainSensorOff() (r bool, exists bool) {
	v := m.quality_control_freezing_rain_sensor_off
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlFreezingRainSensorOff returns the old "quality_control_freezing_rain_sensor_off" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlFreezingRainSensorOff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlFreezingRainSensorOff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlFreezingRainSensorOff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlFreezingRainSensorOff: %w", err)
	}
	return oldValue.QualityControlFreezingRainSensorOff, nil
}

// ResetQualityControlFreezingRainSensorOff resets all changes to the "quality_control_freezing_rain_sensor_off" field.
func (m *MetarMutation) ResetQualityControlFreezingRainSensorOff() {
	m.quality_control_freezing_rain_sensor_off = nil
}

// SetQualityControlPresentWeatherSensorOff sets the "quality_control_present_weather_sensor_off" field.
func (m *MetarMutation) SetQualityControlPresentWeatherSensorOff(b bool) {
	m.quality_control_present_weather_sensor_off = &b
}

// QualityControlPresentWeatherSensorOff returns the value of the "quality_control_present_weather_sensor_off" field in the mutation.
func (m *MetarMutation) QualityControlPresentWeatherSensorOff() (r bool, exists bool) {
	v := m.quality_control_present_weather_sensor_off
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityControlPresentWeatherSensorOff returns the old "quality_control_present_weather_sensor_off" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldQualityControlPresentWeatherSensorOff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityControlPresentWeatherSensorOff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityControlPresentWeatherSensorOff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityControlPresentWeatherSensorOff: %w", err)
	}
	return oldValue.QualityControlPresentWeatherSensorOff, nil
}

// ResetQualityControlPresentWeatherSensorOff resets all changes to the "quality_control_present_weather_sensor_off" field.
func (m *MetarMutation) ResetQualityControlPresentWeatherSensorOff() {
	m.quality_control_present_weather_sensor_off = nil
}

// SetSeaLevelPressure sets the "sea_level_pressure" field.
func (m *MetarMutation) SetSeaLevelPressure(f float64) {
	m.sea_level_pressure = &f
	m.addsea_level_pressure = nil
}

// SeaLevelPressure returns the value of the "sea_level_pressure" field in the mutation.
func (m *MetarMutation) SeaLevelPressure() (r float64, exists bool) {
	v := m.sea_level_pressure
	if v == nil {
		return
	}
	return *v, true
}

// OldSeaLevelPressure returns the old "sea_level_pressure" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldSeaLevelPressure(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeaLevelPressure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeaLevelPressure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeaLevelPressure: %w", err)
	}
	return oldValue.SeaLevelPressure, nil
}

// AddSeaLevelPressure adds f to the "sea_level_pressure" field.
func (m *MetarMutation) AddSeaLevelPressure(f float64) {
	if m.addsea_level_pressure != nil {
		*m.addsea_level_pressure += f
	} else {
		m.addsea_level_pressure = &f
	}
}

// AddedSeaLevelPressure returns the value that was added to the "sea_level_pressure" field in this mutation.
func (m *MetarMutation) AddedSeaLevelPressure() (r float64, exists bool) {
	v := m.addsea_level_pressure
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeaLevelPressure clears the value of the "sea_level_pressure" field.
func (m *MetarMutation) ClearSeaLevelPressure() {
	m.sea_level_pressure = nil
	m.addsea_level_pressure = nil
	m.clearedFields[metar.FieldSeaLevelPressure] = struct{}{}
}

// SeaLevelPressureCleared returns if the "sea_level_pressure" field was cleared in this mutation.
func (m *MetarMutation) SeaLevelPressureCleared() bool {
	_, ok := m.clearedFields[metar.FieldSeaLevelPressure]
	return ok
}

// ResetSeaLevelPressure resets all changes to the "sea_level_pressure" field.
func (m *MetarMutation) ResetSeaLevelPressure() {
	m.sea_level_pressure = nil
	m.addsea_level_pressure = nil
	delete(m.clearedFields, metar.FieldSeaLevelPressure)
}

// SetPressureTendency sets the "pressure_tendency" field.
func (m *MetarMutation) SetPressureTendency(f float64) {
	m.pressure_tendency = &f
	m.addpressure_tendency = nil
}

// PressureTendency returns the value of the "pressure_tendency" field in the mutation.
func (m *MetarMutation) PressureTendency() (r float64, exists bool) {
	v := m.pressure_tendency
	if v == nil {
		return
	}
	return *v, true
}

// OldPressureTendency returns the old "pressure_tendency" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPressureTendency(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPressureTendency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPressureTendency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPressureTendency: %w", err)
	}
	return oldValue.PressureTendency, nil
}

// AddPressureTendency adds f to the "pressure_tendency" field.
func (m *MetarMutation) AddPressureTendency(f float64) {
	if m.addpressure_tendency != nil {
		*m.addpressure_tendency += f
	} else {
		m.addpressure_tendency = &f
	}
}

// AddedPressureTendency returns the value that was added to the "pressure_tendency" field in this mutation.
func (m *MetarMutation) AddedPressureTendency() (r float64, exists bool) {
	v := m.addpressure_tendency
	if v == nil {
		return
	}
	return *v, true
}

// ClearPressureTendency clears the value of the "pressure_tendency" field.
func (m *MetarMutation) ClearPressureTendency() {
	m.pressure_tendency = nil
	m.addpressure_tendency = nil
	m.clearedFields[metar.FieldPressureTendency] = struct{}{}
}

// PressureTendencyCleared returns if the "pressure_tendency" field was cleared in this mutation.
func (m *MetarMutation) PressureTendencyCleared() bool {
	_, ok := m.clearedFields[metar.FieldPressureTendency]
	return ok
}

// ResetPressureTendency resets all changes to the "pressure_tendency" field.
func (m *MetarMutation) ResetPressureTendency() {
	m.pressure_tendency = nil
	m.addpressure_tendency = nil
	delete(m.clearedFields, metar.FieldPressureTendency)
}

// SetMaxTemp6 sets the "max_temp_6" field.
func (m *MetarMutation) SetMaxTemp6(f float64) {
	m.max_temp_6 = &f
	m.addmax_temp_6 = nil
}

// MaxTemp6 returns the value of the "max_temp_6" field in the mutation.
func (m *MetarMutation) MaxTemp6() (r float64, exists bool) {
	v := m.max_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemp6 returns the old "max_temp_6" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMaxTemp6(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemp6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemp6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemp6: %w", err)
	}
	return oldValue.MaxTemp6, nil
}

// AddMaxTemp6 adds f to the "max_temp_6" field.
func (m *MetarMutation) AddMaxTemp6(f float64) {
	if m.addmax_temp_6 != nil {
		*m.addmax_temp_6 += f
	} else {
		m.addmax_temp_6 = &f
	}
}

// AddedMaxTemp6 returns the value that was added to the "max_temp_6" field in this mutation.
func (m *MetarMutation) AddedMaxTemp6() (r float64, exists bool) {
	v := m.addmax_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTemp6 clears the value of the "max_temp_6" field.
func (m *MetarMutation) ClearMaxTemp6() {
	m.max_temp_6 = nil
	m.addmax_temp_6 = nil
	m.clearedFields[metar.FieldMaxTemp6] = struct{}{}
}

// MaxTemp6Cleared returns if the "max_temp_6" field was cleared in this mutation.
func (m *MetarMutation) MaxTemp6Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMaxTemp6]
	return ok
}

// ResetMaxTemp6 resets all changes to the "max_temp_6" field.
func (m *MetarMutation) ResetMaxTemp6() {
	m.max_temp_6 = nil
	m.addmax_temp_6 = nil
	delete(m.clearedFields, metar.FieldMaxTemp6)
}

// SetMinTemp6 sets the "min_temp_6" field.
func (m *MetarMutation) SetMinTemp6(f float64) {
	m.min_temp_6 = &f
	m.addmin_temp_6 = nil
}

// MinTemp6 returns the value of the "min_temp_6" field in the mutation.
func (m *MetarMutation) MinTemp6() (r float64, exists bool) {
	v := m.min_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemp6 returns the old "min_temp_6" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMinTemp6(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemp6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemp6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemp6: %w", err)
	}
	return oldValue.MinTemp6, nil
}

// AddMinTemp6 adds f to the "min_temp_6" field.
func (m *MetarMutation) AddMinTemp6(f float64) {
	if m.addmin_temp_6 != nil {
		*m.addmin_temp_6 += f
	} else {
		m.addmin_temp_6 = &f
	}
}

// AddedMinTemp6 returns the value that was added to the "min_temp_6" field in this mutation.
func (m *MetarMutation) AddedMinTemp6() (r float64, exists bool) {
	v := m.addmin_temp_6
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinTemp6 clears the value of the "min_temp_6" field.
func (m *MetarMutation) ClearMinTemp6() {
	m.min_temp_6 = nil
	m.addmin_temp_6 = nil
	m.clearedFields[metar.FieldMinTemp6] = struct{}{}
}

// MinTemp6Cleared returns if the "min_temp_6" field was cleared in this mutation.
func (m *MetarMutation) MinTemp6Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMinTemp6]
	return ok
}

// ResetMinTemp6 resets all changes to the "min_temp_6" field.
func (m *MetarMutation) ResetMinTemp6() {
	m.min_temp_6 = nil
	m.addmin_temp_6 = nil
	delete(m.clearedFields, metar.FieldMinTemp6)
}

// SetMaxTemp24 sets the "max_temp_24" field.
func (m *MetarMutation) SetMaxTemp24(f float64) {
	m.max_temp_24 = &f
	m.addmax_temp_24 = nil
}

// MaxTemp24 returns the value of the "max_temp_24" field in the mutation.
func (m *MetarMutation) MaxTemp24() (r float64, exists bool) {
	v := m.max_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemp24 returns the old "max_temp_24" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMaxTemp24(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemp24 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemp24 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemp24: %w", err)
	}
	return oldValue.MaxTemp24, nil
}

// AddMaxTemp24 adds f to the "max_temp_24" field.
func (m *MetarMutation) AddMaxTemp24(f float64) {
	if m.addmax_temp_24 != nil {
		*m.addmax_temp_24 += f
	} else {
		m.addmax_temp_24 = &f
	}
}

// AddedMaxTemp24 returns the value that was added to the "max_temp_24" field in this mutation.
func (m *MetarMutation) AddedMaxTemp24() (r float64, exists bool) {
	v := m.addmax_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTemp24 clears the value of the "max_temp_24" field.
func (m *MetarMutation) ClearMaxTemp24() {
	m.max_temp_24 = nil
	m.addmax_temp_24 = nil
	m.clearedFields[metar.FieldMaxTemp24] = struct{}{}
}

// MaxTemp24Cleared returns if the "max_temp_24" field was cleared in this mutation.
func (m *MetarMutation) MaxTemp24Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMaxTemp24]
	return ok
}

// ResetMaxTemp24 resets all changes to the "max_temp_24" field.
func (m *MetarMutation) ResetMaxTemp24() {
	m.max_temp_24 = nil
	m.addmax_temp_24 = nil
	delete(m.clearedFields, metar.FieldMaxTemp24)
}

// SetMinTemp24 sets the "min_temp_24" field.
func (m *MetarMutation) SetMinTemp24(f float64) {
	m.min_temp_24 = &f
	m.addmin_temp_24 = nil
}

// MinTemp24 returns the value of the "min_temp_24" field in the mutation.
func (m *MetarMutation) MinTemp24() (r float64, exists bool) {
	v := m.min_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemp24 returns the old "min_temp_24" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMinTemp24(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemp24 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemp24 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemp24: %w", err)
	}
	return oldValue.MinTemp24, nil
}

// AddMinTemp24 adds f to the "min_temp_24" field.
func (m *MetarMutation) AddMinTemp24(f float64) {
	if m.addmin_temp_24 != nil {
		*m.addmin_temp_24 += f
	} else {
		m.addmin_temp_24 = &f
	}
}

// AddedMinTemp24 returns the value that was added to the "min_temp_24" field in this mutation.
func (m *MetarMutation) AddedMinTemp24() (r float64, exists bool) {
	v := m.addmin_temp_24
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinTemp24 clears the value of the "min_temp_24" field.
func (m *MetarMutation) ClearMinTemp24() {
	m.min_temp_24 = nil
	m.addmin_temp_24 = nil
	m.clearedFields[metar.FieldMinTemp24] = struct{}{}
}

// MinTemp24Cleared returns if the "min_temp_24" field was cleared in this mutation.
func (m *MetarMutation) MinTemp24Cleared() bool {
	_, ok := m.clearedFields[metar.FieldMinTemp24]
	return ok
}

// ResetMinTemp24 resets all changes to the "min_temp_24" field.
func (m *MetarMutation) ResetMinTemp24() {
	m.min_temp_24 = nil
	m.addmin_temp_24 = nil
	delete(m.clearedFields, metar.FieldMinTemp24)
}

// SetPrecipitation sets the "precipitation" field.
func (m *MetarMutation) SetPrecipitation(f float64) {
	m.precipitation = &f
	m.addprecipitation = nil
}

// Precipitation returns the value of the "precipitation" field in the mutation.
func (m *MetarMutation) Precipitation() (r float64, exists bool) {
	v := m.precipitation
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation returns the old "precipitation" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation: %w", err)
	}
	return oldValue.Precipitation, nil
}

// AddPrecipitation adds f to the "precipitation" field.
func (m *MetarMutation) AddPrecipitation(f float64) {
	if m.addprecipitation != nil {
		*m.addprecipitation += f
	} else {
		m.addprecipitation = &f
	}
}

// AddedPrecipitation returns the value that was added to the "precipitation" field in this mutation.
func (m *MetarMutation) AddedPrecipitation() (r float64, exists bool) {
	v := m.addprecipitation
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation clears the value of the "precipitation" field.
func (m *MetarMutation) ClearPrecipitation() {
	m.precipitation = nil
	m.addprecipitation = nil
	m.clearedFields[metar.FieldPrecipitation] = struct{}{}
}

// PrecipitationCleared returns if the "precipitation" field was cleared in this mutation.
func (m *MetarMutation) PrecipitationCleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation]
	return ok
}

// ResetPrecipitation resets all changes to the "precipitation" field.
func (m *MetarMutation) ResetPrecipitation() {
	m.precipitation = nil
	m.addprecipitation = nil
	delete(m.clearedFields, metar.FieldPrecipitation)
}

// SetPrecipitation3 sets the "precipitation_3" field.
func (m *MetarMutation) SetPrecipitation3(f float64) {
	m.precipitation_3 = &f
	m.addprecipitation_3 = nil
}

// Precipitation3 returns the value of the "precipitation_3" field in the mutation.
func (m *MetarMutation) Precipitation3() (r float64, exists bool) {
	v := m.precipitation_3
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation3 returns the old "precipitation_3" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation3(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation3: %w", err)
	}
	return oldValue.Precipitation3, nil
}

// AddPrecipitation3 adds f to the "precipitation_3" field.
func (m *MetarMutation) AddPrecipitation3(f float64) {
	if m.addprecipitation_3 != nil {
		*m.addprecipitation_3 += f
	} else {
		m.addprecipitation_3 = &f
	}
}

// AddedPrecipitation3 returns the value that was added to the "precipitation_3" field in this mutation.
func (m *MetarMutation) AddedPrecipitation3() (r float64, exists bool) {
	v := m.addprecipitation_3
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation3 clears the value of the "precipitation_3" field.
func (m *MetarMutation) ClearPrecipitation3() {
	m.precipitation_3 = nil
	m.addprecipitation_3 = nil
	m.clearedFields[metar.FieldPrecipitation3] = struct{}{}
}

// Precipitation3Cleared returns if the "precipitation_3" field was cleared in this mutation.
func (m *MetarMutation) Precipitation3Cleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation3]
	return ok
}

// ResetPrecipitation3 resets all changes to the "precipitation_3" field.
func (m *MetarMutation) ResetPrecipitation3() {
	m.precipitation_3 = nil
	m.addprecipitation_3 = nil
	delete(m.clearedFields, metar.FieldPrecipitation3)
}

// SetPrecipitation6 sets the "precipitation_6" field.
func (m *MetarMutation) SetPrecipitation6(f float64) {
	m.precipitation_6 = &f
	m.addprecipitation_6 = nil
}

// Precipitation6 returns the value of the "precipitation_6" field in the mutation.
func (m *MetarMutation) Precipitation6() (r float64, exists bool) {
	v := m.precipitation_6
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation6 returns the old "precipitation_6" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation6(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation6: %w", err)
	}
	return oldValue.Precipitation6, nil
}

// AddPrecipitation6 adds f to the "precipitation_6" field.
func (m *MetarMutation) AddPrecipitation6(f float64) {
	if m.addprecipitation_6 != nil {
		*m.addprecipitation_6 += f
	} else {
		m.addprecipitation_6 = &f
	}
}

// AddedPrecipitation6 returns the value that was added to the "precipitation_6" field in this mutation.
func (m *MetarMutation) AddedPrecipitation6() (r float64, exists bool) {
	v := m.addprecipitation_6
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation6 clears the value of the "precipitation_6" field.
func (m *MetarMutation) ClearPrecipitation6() {
	m.precipitation_6 = nil
	m.addprecipitation_6 = nil
	m.clearedFields[metar.FieldPrecipitation6] = struct{}{}
}

// Precipitation6Cleared returns if the "precipitation_6" field was cleared in this mutation.
func (m *MetarMutation) Precipitation6Cleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation6]
	return ok
}

// ResetPrecipitation6 resets all changes to the "precipitation_6" field.
func (m *MetarMutation) ResetPrecipitation6() {
	m.precipitation_6 = nil
	m.addprecipitation_6 = nil
	delete(m.clearedFields, metar.FieldPrecipitation6)
}

// SetPrecipitation24 sets the "precipitation_24" field.
func (m *MetarMutation) SetPrecipitation24(f float64) {
	m.precipitation_24 = &f
	m.addprecipitation_24 = nil
}

// Precipitation24 returns the value of the "precipitation_24" field in the mutation.
func (m *MetarMutation) Precipitation24() (r float64, exists bool) {
	v := m.precipitation_24
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecipitation24 returns the old "precipitation_24" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldPrecipitation24(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecipitation24 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecipitation24 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecipitation24: %w", err)
	}
	return oldValue.Precipitation24, nil
}

// AddPrecipitation24 adds f to the "precipitation_24" field.
func (m *MetarMutation) AddPrecipitation24(f float64) {
	if m.addprecipitation_24 != nil {
		*m.addprecipitation_24 += f
	} else {
		m.addprecipitation_24 = &f
	}
}

// AddedPrecipitation24 returns the value that was added to the "precipitation_24" field in this mutation.
func (m *MetarMutation) AddedPrecipitation24() (r float64, exists bool) {
	v := m.addprecipitation_24
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrecipitation24 clears the value of the "precipitation_24" field.
func (m *MetarMutation) ClearPrecipitation24() {
	m.precipitation_24 = nil
	m.addprecipitation_24 = nil
	m.clearedFields[metar.FieldPrecipitation24] = struct{}{}
}

// Precipitation24Cleared returns if the "precipitation_24" field was cleared in this mutation.
func (m *MetarMutation) Precipitation24Cleared() bool {
	_, ok := m.clearedFields[metar.FieldPrecipitation24]
	return ok
}

// ResetPrecipitation24 resets all changes to the "precipitation_24" field.
func (m *MetarMutation) ResetPrecipitation24() {
	m.precipitation_24 = nil
	m.addprecipitation_24 = nil
	delete(m.clearedFields, metar.FieldPrecipitation24)
}

// SetSnowDepth sets the "snow_depth" field.
func (m *MetarMutation) SetSnowDepth(f float64) {
	m.snow_depth = &f
	m.addsnow_depth = nil
}

// SnowDepth returns the value of the "snow_depth" field in the mutation.
func (m *MetarMutation) SnowDepth() (r float64, exists bool) {
	v := m.snow_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldSnowDepth returns the old "snow_depth" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldSnowDepth(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnowDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnowDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnowDepth: %w", err)
	}
	return oldValue.SnowDepth, nil
}

// AddSnowDepth adds f to the "snow_depth" field.
func (m *MetarMutation) AddSnowDepth(f float64) {
	if m.addsnow_depth != nil {
		*m.addsnow_depth += f
	} else {
		m.addsnow_depth = &f
	}
}

// AddedSnowDepth returns the value that was added to the "snow_depth" field in this mutation.
func (m *MetarMutation) AddedSnowDepth() (r float64, exists bool) {
	v := m.addsnow_depth
	if v == nil {
		return
	}
	return *v, true
}

// ClearSnowDepth clears the value of the "snow_depth" field.
func (m *MetarMutation) ClearSnowDepth() {
	m.snow_depth = nil
	m.addsnow_depth = nil
	m.clearedFields[metar.FieldSnowDepth] = struct{}{}
}

// SnowDepthCleared returns if the "snow_depth" field was cleared in this mutation.
func (m *MetarMutation) SnowDepthCleared() bool {
	_, ok := m.clearedFields[metar.FieldSnowDepth]
	return ok
}

// ResetSnowDepth resets all changes to the "snow_depth" field.
func (m *MetarMutation) ResetSnowDepth() {
	m.snow_depth = nil
	m.addsnow_depth = nil
	delete(m.clearedFields, metar.FieldSnowDepth)
}

// SetVertVis sets the "vert_vis" field.
func (m *MetarMutation) SetVertVis(f float64) {
	m.vert_vis = &f
	m.addvert_vis = nil
}

// VertVis returns the value of the "vert_vis" field in the mutation.
func (m *MetarMutation) VertVis() (r float64, exists bool) {
	v := m.vert_vis
	if v == nil {
		return
	}
	return *v, true
}

// OldVertVis returns the old "vert_vis" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldVertVis(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVertVis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVertVis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVertVis: %w", err)
	}
	return oldValue.VertVis, nil
}

// AddVertVis adds f to the "vert_vis" field.
func (m *MetarMutation) AddVertVis(f float64) {
	if m.addvert_vis != nil {
		*m.addvert_vis += f
	} else {
		m.addvert_vis = &f
	}
}

// AddedVertVis returns the value that was added to the "vert_vis" field in this mutation.
func (m *MetarMutation) AddedVertVis() (r float64, exists bool) {
	v := m.addvert_vis
	if v == nil {
		return
	}
	return *v, true
}

// ClearVertVis clears the value of the "vert_vis" field.
func (m *MetarMutation) ClearVertVis() {
	m.vert_vis = nil
	m.addvert_vis = nil
	m.clearedFields[metar.FieldVertVis] = struct{}{}
}

// VertVisCleared returns if the "vert_vis" field was cleared in this mutation.
func (m *MetarMutation) VertVisCleared() bool {
	_, ok := m.clearedFields[metar.FieldVertVis]
	return ok
}

// ResetVertVis resets all changes to the "vert_vis" field.
func (m *MetarMutation) ResetVertVis() {
	m.vert_vis = nil
	m.addvert_vis = nil
	delete(m.clearedFields, metar.FieldVertVis)
}

// SetMetarType sets the "metar_type" field.
func (m *MetarMutation) SetMetarType(mt metar.MetarType) {
	m.metar_type = &mt
}

// MetarType returns the value of the "metar_type" field in the mutation.
func (m *MetarMutation) MetarType() (r metar.MetarType, exists bool) {
	v := m.metar_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMetarType returns the old "metar_type" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldMetarType(ctx context.Context) (v metar.MetarType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetarType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetarType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetarType: %w", err)
	}
	return oldValue.MetarType, nil
}

// ResetMetarType resets all changes to the "metar_type" field.
func (m *MetarMutation) ResetMetarType() {
	m.metar_type = nil
}

// SetHash sets the "hash" field.
func (m *MetarMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *MetarMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Metar entity.
// If the Metar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetarMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *MetarMutation) ResetHash() {
	m.hash = nil
}

// SetStationID sets the "station" edge to the WeatherStation entity by id.
func (m *MetarMutation) SetStationID(id uuid.UUID) {
	m.station = &id
}

// ClearStation clears the "station" edge to the WeatherStation entity.
func (m *MetarMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the WeatherStation entity was cleared.
func (m *MetarMutation) StationCleared() bool {
	return m.clearedstation
}

// StationID returns the "station" edge ID in the mutation.
func (m *MetarMutation) StationID() (id uuid.UUID, exists bool) {
	if m.station != nil {
		return *m.station, true
	}
	return
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *MetarMutation) StationIDs() (ids []uuid.UUID) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *MetarMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// AddSkyConditionIDs adds the "sky_conditions" edge to the SkyCondition entity by ids.
func (m *MetarMutation) AddSkyConditionIDs(ids ...uuid.UUID) {
	if m.sky_conditions == nil {
		m.sky_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sky_conditions[ids[i]] = struct{}{}
	}
}

// ClearSkyConditions clears the "sky_conditions" edge to the SkyCondition entity.
func (m *MetarMutation) ClearSkyConditions() {
	m.clearedsky_conditions = true
}

// SkyConditionsCleared reports if the "sky_conditions" edge to the SkyCondition entity was cleared.
func (m *MetarMutation) SkyConditionsCleared() bool {
	return m.clearedsky_conditions
}

// RemoveSkyConditionIDs removes the "sky_conditions" edge to the SkyCondition entity by IDs.
func (m *MetarMutation) RemoveSkyConditionIDs(ids ...uuid.UUID) {
	if m.removedsky_conditions == nil {
		m.removedsky_conditions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sky_conditions, ids[i])
		m.removedsky_conditions[ids[i]] = struct{}{}
	}
}

// RemovedSkyConditions returns the removed IDs of the "sky_conditions" edge to the SkyCondition entity.
func (m *MetarMutation) RemovedSkyConditionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsky_conditions {
		ids = append(ids, id)
	}
	return
}

// SkyConditionsIDs returns the "sky_conditions" edge IDs in the mutation.
func (m *MetarMutation) SkyConditionsIDs() (ids []uuid.UUID) {
	for id := range m.sky_conditions {
		ids = append(ids, id)
	}
	return
}

// ResetSkyConditions resets all changes to the "sky_conditions" edge.
func (m *MetarMutation) ResetSkyConditions() {
	m.sky_conditions = nil
	m.clearedsky_conditions = false
	m.removedsky_conditions = nil
}

// Where appends a list predicates to the MetarMutation builder.
func (m *MetarMutation) Where(ps ...predicate.Metar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metar).
func (m *MetarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetarMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.raw_text != nil {
		fields = append(fields, metar.FieldRawText)
	}
	if m.observation_time != nil {
		fields = append(fields, metar.FieldObservationTime)
	}
	if m.import_time != nil {
		fields = append(fields, metar.FieldImportTime)
	}
	if m.next_import_time_prediction != nil {
		fields = append(fields, metar.FieldNextImportTimePrediction)
	}
	if m.temperature != nil {
		fields = append(fields, metar.FieldTemperature)
	}
	if m.dewpoint != nil {
		fields = append(fields, metar.FieldDewpoint)
	}
	if m.wind_speed != nil {
		fields = append(fields, metar.FieldWindSpeed)
	}
	if m.wind_gust != nil {
		fields = append(fields, metar.FieldWindGust)
	}
	if m.wind_direction != nil {
		fields = append(fields, metar.FieldWindDirection)
	}
	if m.wind_direction_variable != nil {
		fields = append(fields, metar.FieldWindDirectionVariable)
	}
	if m.visibility != nil {
		fields = append(fields, metar.FieldVisibility)
	}
	if m.visibility_is_more_than != nil {
		fields = append(fields, metar.FieldVisibilityIsMoreThan)
	}
	if m.altimeter != nil {
		fields = append(fields, metar.FieldAltimeter)
	}
	if m.present_weather != nil {
		fields = append(fields, metar.FieldPresentWeather)
	}
	if m.flight_category != nil {
		fields = append(fields, metar.FieldFlightCategory)
	}
	if m.quality_control_corrected != nil {
		fields = append(fields, metar.FieldQualityControlCorrected)
	}
	if m.quality_control_auto_station != nil {
		fields = append(fields, metar.FieldQualityControlAutoStation)
	}
	if m.quality_control_maintenance_indicator_on != nil {
		fields = append(fields, metar.FieldQualityControlMaintenanceIndicatorOn)
	}
	if m.quality_control_no_signal != nil {
		fields = append(fields, metar.FieldQualityControlNoSignal)
	}
	if m.quality_control_lightning_sensor_off != nil {
		fields = append(fields, metar.FieldQualityControlLightningSensorOff)
	}
	if m.quality_control_freezing_rain_sensor_off != nil {
		fields = append(fields, metar.FieldQualityControlFreezingRainSensorOff)
	}
	if m.quality_control_present_weather_sensor_off != nil {
		fields = append(fields, metar.FieldQualityControlPresentWeatherSensorOff)
	}
	if m.sea_level_pressure != nil {
		fields = append(fields, metar.FieldSeaLevelPressure)
	}
	if m.pressure_tendency != nil {
		fields = append(fields, metar.FieldPressureTendency)
	}
	if m.max_temp_6 != nil {
		fields = append(fields, metar.FieldMaxTemp6)
	}
	if m.min_temp_6 != nil {
		fields = append(fields, metar.FieldMinTemp6)
	}
	if m.max_temp_24 != nil {
		fields = append(fields, metar.FieldMaxTemp24)
	}
	if m.min_temp_24 != nil {
		fields = append(fields, metar.FieldMinTemp24)
	}
	if m.precipitation != nil {
		fields = append(fields, metar.FieldPrecipitation)
	}
	if m.precipitation_3 != nil {
		fields = append(fields, metar.FieldPrecipitation3)
	}
	if m.precipitation_6 != nil {
		fields = append(fields, metar.FieldPrecipitation6)
	}
	if m.precipitation_24 != nil {
		fields = append(fields, metar.FieldPrecipitation24)
	}
	if m.snow_depth != nil {
		fields = append(fields, metar.FieldSnowDepth)
	}
	if m.vert_vis != nil {
		fields = append(fields, metar.FieldVertVis)
	}
	if m.metar_type != nil {
		fields = append(fields, metar.FieldMetarType)
	}
	if m.hash != nil {
		fields = append(fields, metar.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metar.FieldRawText:
		return m.RawText()
	case metar.FieldObservationTime:
		return m.ObservationTime()
	case metar.FieldImportTime:
		return m.ImportTime()
	case metar.FieldNextImportTimePrediction:
		return m.NextImportTimePrediction()
	case metar.FieldTemperature:
		return m.Temperature()
	case metar.FieldDewpoint:
		return m.Dewpoint()
	case metar.FieldWindSpeed:
		return m.WindSpeed()
	case metar.FieldWindGust:
		return m.WindGust()
	case metar.FieldWindDirection:
		return m.WindDirection()
	case metar.FieldWindDirectionVariable:
		return m.WindDirectionVariable()
	case metar.FieldVisibility:
		return m.Visibility()
	case metar.FieldVisibilityIsMoreThan:
		return m.VisibilityIsMoreThan()
	case metar.FieldAltimeter:
		return m.Altimeter()
	case metar.FieldPresentWeather:
		return m.PresentWeather()
	case metar.FieldFlightCategory:
		return m.FlightCategory()
	case metar.FieldQualityControlCorrected:
		return m.QualityControlCorrected()
	case metar.FieldQualityControlAutoStation:
		return m.QualityControlAutoStation()
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		return m.QualityControlMaintenanceIndicatorOn()
	case metar.FieldQualityControlNoSignal:
		return m.QualityControlNoSignal()
	case metar.FieldQualityControlLightningSensorOff:
		return m.QualityControlLightningSensorOff()
	case metar.FieldQualityControlFreezingRainSensorOff:
		return m.QualityControlFreezingRainSensorOff()
	case metar.FieldQualityControlPresentWeatherSensorOff:
		return m.QualityControlPresentWeatherSensorOff()
	case metar.FieldSeaLevelPressure:
		return m.SeaLevelPressure()
	case metar.FieldPressureTendency:
		return m.PressureTendency()
	case metar.FieldMaxTemp6:
		return m.MaxTemp6()
	case metar.FieldMinTemp6:
		return m.MinTemp6()
	case metar.FieldMaxTemp24:
		return m.MaxTemp24()
	case metar.FieldMinTemp24:
		return m.MinTemp24()
	case metar.FieldPrecipitation:
		return m.Precipitation()
	case metar.FieldPrecipitation3:
		return m.Precipitation3()
	case metar.FieldPrecipitation6:
		return m.Precipitation6()
	case metar.FieldPrecipitation24:
		return m.Precipitation24()
	case metar.FieldSnowDepth:
		return m.SnowDepth()
	case metar.FieldVertVis:
		return m.VertVis()
	case metar.FieldMetarType:
		return m.MetarType()
	case metar.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metar.FieldRawText:
		return m.OldRawText(ctx)
	case metar.FieldObservationTime:
		return m.OldObservationTime(ctx)
	case metar.FieldImportTime:
		return m.OldImportTime(ctx)
	case metar.FieldNextImportTimePrediction:
		return m.OldNextImportTimePrediction(ctx)
	case metar.FieldTemperature:
		return m.OldTemperature(ctx)
	case metar.FieldDewpoint:
		return m.OldDewpoint(ctx)
	case metar.FieldWindSpeed:
		return m.OldWindSpeed(ctx)
	case metar.FieldWindGust:
		return m.OldWindGust(ctx)
	case metar.FieldWindDirection:
		return m.OldWindDirection(ctx)
	case metar.FieldWindDirectionVariable:
		return m.OldWindDirectionVariable(ctx)
	case metar.FieldVisibility:
		return m.OldVisibility(ctx)
	case metar.FieldVisibilityIsMoreThan:
		return m.OldVisibilityIsMoreThan(ctx)
	case metar.FieldAltimeter:
		return m.OldAltimeter(ctx)
	case metar.FieldPresentWeather:
		return m.OldPresentWeather(ctx)
	case metar.FieldFlightCategory:
		return m.OldFlightCategory(ctx)
	case metar.FieldQualityControlCorrected:
		return m.OldQualityControlCorrected(ctx)
	case metar.FieldQualityControlAutoStation:
		return m.OldQualityControlAutoStation(ctx)
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		return m.OldQualityControlMaintenanceIndicatorOn(ctx)
	case metar.FieldQualityControlNoSignal:
		return m.OldQualityControlNoSignal(ctx)
	case metar.FieldQualityControlLightningSensorOff:
		return m.OldQualityControlLightningSensorOff(ctx)
	case metar.FieldQualityControlFreezingRainSensorOff:
		return m.OldQualityControlFreezingRainSensorOff(ctx)
	case metar.FieldQualityControlPresentWeatherSensorOff:
		return m.OldQualityControlPresentWeatherSensorOff(ctx)
	case metar.FieldSeaLevelPressure:
		return m.OldSeaLevelPressure(ctx)
	case metar.FieldPressureTendency:
		return m.OldPressureTendency(ctx)
	case metar.FieldMaxTemp6:
		return m.OldMaxTemp6(ctx)
	case metar.FieldMinTemp6:
		return m.OldMinTemp6(ctx)
	case metar.FieldMaxTemp24:
		return m.OldMaxTemp24(ctx)
	case metar.FieldMinTemp24:
		return m.OldMinTemp24(ctx)
	case metar.FieldPrecipitation:
		return m.OldPrecipitation(ctx)
	case metar.FieldPrecipitation3:
		return m.OldPrecipitation3(ctx)
	case metar.FieldPrecipitation6:
		return m.OldPrecipitation6(ctx)
	case metar.FieldPrecipitation24:
		return m.OldPrecipitation24(ctx)
	case metar.FieldSnowDepth:
		return m.OldSnowDepth(ctx)
	case metar.FieldVertVis:
		return m.OldVertVis(ctx)
	case metar.FieldMetarType:
		return m.OldMetarType(ctx)
	case metar.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown Metar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metar.FieldRawText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawText(v)
		return nil
	case metar.FieldObservationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObservationTime(v)
		return nil
	case metar.FieldImportTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportTime(v)
		return nil
	case metar.FieldNextImportTimePrediction:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextImportTimePrediction(v)
		return nil
	case metar.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case metar.FieldDewpoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDewpoint(v)
		return nil
	case metar.FieldWindSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindSpeed(v)
		return nil
	case metar.FieldWindGust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindGust(v)
		return nil
	case metar.FieldWindDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirection(v)
		return nil
	case metar.FieldWindDirectionVariable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirectionVariable(v)
		return nil
	case metar.FieldVisibility:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case metar.FieldVisibilityIsMoreThan:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibilityIsMoreThan(v)
		return nil
	case metar.FieldAltimeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltimeter(v)
		return nil
	case metar.FieldPresentWeather:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresentWeather(v)
		return nil
	case metar.FieldFlightCategory:
		v, ok := value.(metar.FlightCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightCategory(v)
		return nil
	case metar.FieldQualityControlCorrected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlCorrected(v)
		return nil
	case metar.FieldQualityControlAutoStation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlAutoStation(v)
		return nil
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlMaintenanceIndicatorOn(v)
		return nil
	case metar.FieldQualityControlNoSignal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlNoSignal(v)
		return nil
	case metar.FieldQualityControlLightningSensorOff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlLightningSensorOff(v)
		return nil
	case metar.FieldQualityControlFreezingRainSensorOff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlFreezingRainSensorOff(v)
		return nil
	case metar.FieldQualityControlPresentWeatherSensorOff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityControlPresentWeatherSensorOff(v)
		return nil
	case metar.FieldSeaLevelPressure:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeaLevelPressure(v)
		return nil
	case metar.FieldPressureTendency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPressureTendency(v)
		return nil
	case metar.FieldMaxTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemp6(v)
		return nil
	case metar.FieldMinTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemp6(v)
		return nil
	case metar.FieldMaxTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemp24(v)
		return nil
	case metar.FieldMinTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemp24(v)
		return nil
	case metar.FieldPrecipitation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation(v)
		return nil
	case metar.FieldPrecipitation3:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation3(v)
		return nil
	case metar.FieldPrecipitation6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation6(v)
		return nil
	case metar.FieldPrecipitation24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecipitation24(v)
		return nil
	case metar.FieldSnowDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnowDepth(v)
		return nil
	case metar.FieldVertVis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVertVis(v)
		return nil
	case metar.FieldMetarType:
		v, ok := value.(metar.MetarType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetarType(v)
		return nil
	case metar.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown Metar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetarMutation) AddedFields() []string {
	var fields []string
	if m.addtemperature != nil {
		fields = append(fields, metar.FieldTemperature)
	}
	if m.adddewpoint != nil {
		fields = append(fields, metar.FieldDewpoint)
	}
	if m.addwind_speed != nil {
		fields = append(fields, metar.FieldWindSpeed)
	}
	if m.addwind_gust != nil {
		fields = append(fields, metar.FieldWindGust)
	}
	if m.addwind_direction != nil {
		fields = append(fields, metar.FieldWindDirection)
	}
	if m.addvisibility != nil {
		fields = append(fields, metar.FieldVisibility)
	}
	if m.addaltimeter != nil {
		fields = append(fields, metar.FieldAltimeter)
	}
	if m.addsea_level_pressure != nil {
		fields = append(fields, metar.FieldSeaLevelPressure)
	}
	if m.addpressure_tendency != nil {
		fields = append(fields, metar.FieldPressureTendency)
	}
	if m.addmax_temp_6 != nil {
		fields = append(fields, metar.FieldMaxTemp6)
	}
	if m.addmin_temp_6 != nil {
		fields = append(fields, metar.FieldMinTemp6)
	}
	if m.addmax_temp_24 != nil {
		fields = append(fields, metar.FieldMaxTemp24)
	}
	if m.addmin_temp_24 != nil {
		fields = append(fields, metar.FieldMinTemp24)
	}
	if m.addprecipitation != nil {
		fields = append(fields, metar.FieldPrecipitation)
	}
	if m.addprecipitation_3 != nil {
		fields = append(fields, metar.FieldPrecipitation3)
	}
	if m.addprecipitation_6 != nil {
		fields = append(fields, metar.FieldPrecipitation6)
	}
	if m.addprecipitation_24 != nil {
		fields = append(fields, metar.FieldPrecipitation24)
	}
	if m.addsnow_depth != nil {
		fields = append(fields, metar.FieldSnowDepth)
	}
	if m.addvert_vis != nil {
		fields = append(fields, metar.FieldVertVis)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case metar.FieldTemperature:
		return m.AddedTemperature()
	case metar.FieldDewpoint:
		return m.AddedDewpoint()
	case metar.FieldWindSpeed:
		return m.AddedWindSpeed()
	case metar.FieldWindGust:
		return m.AddedWindGust()
	case metar.FieldWindDirection:
		return m.AddedWindDirection()
	case metar.FieldVisibility:
		return m.AddedVisibility()
	case metar.FieldAltimeter:
		return m.AddedAltimeter()
	case metar.FieldSeaLevelPressure:
		return m.AddedSeaLevelPressure()
	case metar.FieldPressureTendency:
		return m.AddedPressureTendency()
	case metar.FieldMaxTemp6:
		return m.AddedMaxTemp6()
	case metar.FieldMinTemp6:
		return m.AddedMinTemp6()
	case metar.FieldMaxTemp24:
		return m.AddedMaxTemp24()
	case metar.FieldMinTemp24:
		return m.AddedMinTemp24()
	case metar.FieldPrecipitation:
		return m.AddedPrecipitation()
	case metar.FieldPrecipitation3:
		return m.AddedPrecipitation3()
	case metar.FieldPrecipitation6:
		return m.AddedPrecipitation6()
	case metar.FieldPrecipitation24:
		return m.AddedPrecipitation24()
	case metar.FieldSnowDepth:
		return m.AddedSnowDepth()
	case metar.FieldVertVis:
		return m.AddedVertVis()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case metar.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case metar.FieldDewpoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDewpoint(v)
		return nil
	case metar.FieldWindSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindSpeed(v)
		return nil
	case metar.FieldWindGust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindGust(v)
		return nil
	case metar.FieldWindDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindDirection(v)
		return nil
	case metar.FieldVisibility:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisibility(v)
		return nil
	case metar.FieldAltimeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAltimeter(v)
		return nil
	case metar.FieldSeaLevelPressure:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeaLevelPressure(v)
		return nil
	case metar.FieldPressureTendency:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPressureTendency(v)
		return nil
	case metar.FieldMaxTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemp6(v)
		return nil
	case metar.FieldMinTemp6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemp6(v)
		return nil
	case metar.FieldMaxTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemp24(v)
		return nil
	case metar.FieldMinTemp24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemp24(v)
		return nil
	case metar.FieldPrecipitation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation(v)
		return nil
	case metar.FieldPrecipitation3:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation3(v)
		return nil
	case metar.FieldPrecipitation6:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation6(v)
		return nil
	case metar.FieldPrecipitation24:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecipitation24(v)
		return nil
	case metar.FieldSnowDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSnowDepth(v)
		return nil
	case metar.FieldVertVis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVertVis(v)
		return nil
	}
	return fmt.Errorf("unknown Metar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metar.FieldNextImportTimePrediction) {
		fields = append(fields, metar.FieldNextImportTimePrediction)
	}
	if m.FieldCleared(metar.FieldTemperature) {
		fields = append(fields, metar.FieldTemperature)
	}
	if m.FieldCleared(metar.FieldDewpoint) {
		fields = append(fields, metar.FieldDewpoint)
	}
	if m.FieldCleared(metar.FieldWindSpeed) {
		fields = append(fields, metar.FieldWindSpeed)
	}
	if m.FieldCleared(metar.FieldWindGust) {
		fields = append(fields, metar.FieldWindGust)
	}
	if m.FieldCleared(metar.FieldWindDirection) {
		fields = append(fields, metar.FieldWindDirection)
	}
	if m.FieldCleared(metar.FieldVisibility) {
		fields = append(fields, metar.FieldVisibility)
	}
	if m.FieldCleared(metar.FieldAltimeter) {
		fields = append(fields, metar.FieldAltimeter)
	}
	if m.FieldCleared(metar.FieldPresentWeather) {
		fields = append(fields, metar.FieldPresentWeather)
	}
	if m.FieldCleared(metar.FieldFlightCategory) {
		fields = append(fields, metar.FieldFlightCategory)
	}
	if m.FieldCleared(metar.FieldQualityControlCorrected) {
		fields = append(fields, metar.FieldQualityControlCorrected)
	}
	if m.FieldCleared(metar.FieldSeaLevelPressure) {
		fields = append(fields, metar.FieldSeaLevelPressure)
	}
	if m.FieldCleared(metar.FieldPressureTendency) {
		fields = append(fields, metar.FieldPressureTendency)
	}
	if m.FieldCleared(metar.FieldMaxTemp6) {
		fields = append(fields, metar.FieldMaxTemp6)
	}
	if m.FieldCleared(metar.FieldMinTemp6) {
		fields = append(fields, metar.FieldMinTemp6)
	}
	if m.FieldCleared(metar.FieldMaxTemp24) {
		fields = append(fields, metar.FieldMaxTemp24)
	}
	if m.FieldCleared(metar.FieldMinTemp24) {
		fields = append(fields, metar.FieldMinTemp24)
	}
	if m.FieldCleared(metar.FieldPrecipitation) {
		fields = append(fields, metar.FieldPrecipitation)
	}
	if m.FieldCleared(metar.FieldPrecipitation3) {
		fields = append(fields, metar.FieldPrecipitation3)
	}
	if m.FieldCleared(metar.FieldPrecipitation6) {
		fields = append(fields, metar.FieldPrecipitation6)
	}
	if m.FieldCleared(metar.FieldPrecipitation24) {
		fields = append(fields, metar.FieldPrecipitation24)
	}
	if m.FieldCleared(metar.FieldSnowDepth) {
		fields = append(fields, metar.FieldSnowDepth)
	}
	if m.FieldCleared(metar.FieldVertVis) {
		fields = append(fields, metar.FieldVertVis)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetarMutation) ClearField(name string) error {
	switch name {
	case metar.FieldNextImportTimePrediction:
		m.ClearNextImportTimePrediction()
		return nil
	case metar.FieldTemperature:
		m.ClearTemperature()
		return nil
	case metar.FieldDewpoint:
		m.ClearDewpoint()
		return nil
	case metar.FieldWindSpeed:
		m.ClearWindSpeed()
		return nil
	case metar.FieldWindGust:
		m.ClearWindGust()
		return nil
	case metar.FieldWindDirection:
		m.ClearWindDirection()
		return nil
	case metar.FieldVisibility:
		m.ClearVisibility()
		return nil
	case metar.FieldAltimeter:
		m.ClearAltimeter()
		return nil
	case metar.FieldPresentWeather:
		m.ClearPresentWeather()
		return nil
	case metar.FieldFlightCategory:
		m.ClearFlightCategory()
		return nil
	case metar.FieldQualityControlCorrected:
		m.ClearQualityControlCorrected()
		return nil
	case metar.FieldSeaLevelPressure:
		m.ClearSeaLevelPressure()
		return nil
	case metar.FieldPressureTendency:
		m.ClearPressureTendency()
		return nil
	case metar.FieldMaxTemp6:
		m.ClearMaxTemp6()
		return nil
	case metar.FieldMinTemp6:
		m.ClearMinTemp6()
		return nil
	case metar.FieldMaxTemp24:
		m.ClearMaxTemp24()
		return nil
	case metar.FieldMinTemp24:
		m.ClearMinTemp24()
		return nil
	case metar.FieldPrecipitation:
		m.ClearPrecipitation()
		return nil
	case metar.FieldPrecipitation3:
		m.ClearPrecipitation3()
		return nil
	case metar.FieldPrecipitation6:
		m.ClearPrecipitation6()
		return nil
	case metar.FieldPrecipitation24:
		m.ClearPrecipitation24()
		return nil
	case metar.FieldSnowDepth:
		m.ClearSnowDepth()
		return nil
	case metar.FieldVertVis:
		m.ClearVertVis()
		return nil
	}
	return fmt.Errorf("unknown Metar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetarMutation) ResetField(name string) error {
	switch name {
	case metar.FieldRawText:
		m.ResetRawText()
		return nil
	case metar.FieldObservationTime:
		m.ResetObservationTime()
		return nil
	case metar.FieldImportTime:
		m.ResetImportTime()
		return nil
	case metar.FieldNextImportTimePrediction:
		m.ResetNextImportTimePrediction()
		return nil
	case metar.FieldTemperature:
		m.ResetTemperature()
		return nil
	case metar.FieldDewpoint:
		m.ResetDewpoint()
		return nil
	case metar.FieldWindSpeed:
		m.ResetWindSpeed()
		return nil
	case metar.FieldWindGust:
		m.ResetWindGust()
		return nil
	case metar.FieldWindDirection:
		m.ResetWindDirection()
		return nil
	case metar.FieldWindDirectionVariable:
		m.ResetWindDirectionVariable()
		return nil
	case metar.FieldVisibility:
		m.ResetVisibility()
		return nil
	case metar.FieldVisibilityIsMoreThan:
		m.ResetVisibilityIsMoreThan()
		return nil
	case metar.FieldAltimeter:
		m.ResetAltimeter()
		return nil
	case metar.FieldPresentWeather:
		m.ResetPresentWeather()
		return nil
	case metar.FieldFlightCategory:
		m.ResetFlightCategory()
		return nil
	case metar.FieldQualityControlCorrected:
		m.ResetQualityControlCorrected()
		return nil
	case metar.FieldQualityControlAutoStation:
		m.ResetQualityControlAutoStation()
		return nil
	case metar.FieldQualityControlMaintenanceIndicatorOn:
		m.ResetQualityControlMaintenanceIndicatorOn()
		return nil
	case metar.FieldQualityControlNoSignal:
		m.ResetQualityControlNoSignal()
		return nil
	case metar.FieldQualityControlLightningSensorOff:
		m.ResetQualityControlLightningSensorOff()
		return nil
	case metar.FieldQualityControlFreezingRainSensorOff:
		m.ResetQualityControlFreezingRainSensorOff()
		return nil
	case metar.FieldQualityControlPresentWeatherSensorOff:
		m.ResetQualityControlPresentWeatherSensorOff()
		return nil
	case metar.FieldSeaLevelPressure:
		m.ResetSeaLevelPressure()
		return nil
	case metar.FieldPressureTendency:
		m.ResetPressureTendency()
		return nil
	case metar.FieldMaxTemp6:
		m.ResetMaxTemp6()
		return nil
	case metar.FieldMinTemp6:
		m.ResetMinTemp6()
		return nil
	case metar.FieldMaxTemp24:
		m.ResetMaxTemp24()
		return nil
	case metar.FieldMinTemp24:
		m.ResetMinTemp24()
		return nil
	case metar.FieldPrecipitation:
		m.ResetPrecipitation()
		return nil
	case metar.FieldPrecipitation3:
		m.ResetPrecipitation3()
		return nil
	case metar.FieldPrecipitation6:
		m.ResetPrecipitation6()
		return nil
	case metar.FieldPrecipitation24:
		m.ResetPrecipitation24()
		return nil
	case metar.FieldSnowDepth:
		m.ResetSnowDepth()
		return nil
	case metar.FieldVertVis:
		m.ResetVertVis()
		return nil
	case metar.FieldMetarType:
		m.ResetMetarType()
		return nil
	case metar.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown Metar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetarMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.station != nil {
		edges = append(edges, metar.EdgeStation)
	}
	if m.sky_conditions != nil {
		edges = append(edges, metar.EdgeSkyConditions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metar.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case metar.EdgeSkyConditions:
		ids := make([]ent.Value, 0, len(m.sky_conditions))
		for id := range m.sky_conditions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsky_conditions != nil {
		edges = append(edges, metar.EdgeSkyConditions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metar.EdgeSkyConditions:
		ids := make([]ent.Value, 0, len(m.removedsky_conditions))
		for id := range m.removedsky_conditions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstation {
		edges = append(edges, metar.EdgeStation)
	}
	if m.clearedsky_conditions {
		edges = append(edges, metar.EdgeSkyConditions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetarMutation) EdgeCleared(name string) bool {
	switch name {
	case metar.EdgeStation:
		return m.clearedstation
	case metar.EdgeSkyConditions:
		return m.clearedsky_conditions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetarMutation) ClearEdge(name string) error {
	switch name {
	case metar.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Metar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetarMutation) ResetEdge(name string) error {
	switch name {
	case metar.EdgeStation:
		m.ResetStation()
		return nil
	case metar.EdgeSkyConditions:
		m.ResetSkyConditions()
		return nil
	}
	return fmt.Errorf("unknown Metar edge %s", name)
}

// RegionMutation represents an operation that mutates the Region nodes in the graph.
type RegionMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	import_id       *int
	addimport_id    *int
	hash            *string
	import_flag     *bool
	last_updated    *time.Time
	code            *string
	local_code      *string
	name            *string
	wikipedia_link  *string
	keywords        *[]string
	appendkeywords  []string
	clearedFields   map[string]struct{}
	airports        map[uuid.UUID]struct{}
	removedairports map[uuid.UUID]struct{}
	clearedairports bool
	done            bool
	oldValue        func(context.Context) (*Region, error)
	predicates      []predicate.Region
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows management of the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for the Region entity.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the ID field of the mutation.
func withRegionID(id uuid.UUID) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Region entities.
func (m *RegionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Region.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImportID sets the "import_id" field.
func (m *RegionMutation) SetImportID(i int) {
	m.import_id = &i
	m.addimport_id = nil
}

// ImportID returns the value of the "import_id" field in the mutation.
func (m *RegionMutation) ImportID() (r int, exists bool) {
	v := m.import_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImportID returns the old "import_id" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldImportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportID: %w", err)
	}
	return oldValue.ImportID, nil
}

// AddImportID adds i to the "import_id" field.
func (m *RegionMutation) AddImportID(i int) {
	if m.addimport_id != nil {
		*m.addimport_id += i
	} else {
		m.addimport_id = &i
	}
}

// AddedImportID returns the value that was added to the "import_id" field in this mutation.
func (m *RegionMutation) AddedImportID() (r int, exists bool) {
	v := m.addimport_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetImportID resets all changes to the "import_id" field.
func (m *RegionMutation) ResetImportID() {
	m.import_id = nil
	m.addimport_id = nil
}

// SetHash sets the "hash" field.
func (m *RegionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *RegionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *RegionMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *RegionMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *RegionMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *RegionMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *RegionMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *RegionMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *RegionMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetCode sets the "code" field.
func (m *RegionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RegionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RegionMutation) ResetCode() {
	m.code = nil
}

// SetLocalCode sets the "local_code" field.
func (m *RegionMutation) SetLocalCode(s string) {
	m.local_code = &s
}

// LocalCode returns the value of the "local_code" field in the mutation.
func (m *RegionMutation) LocalCode() (r string, exists bool) {
	v := m.local_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalCode returns the old "local_code" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldLocalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalCode: %w", err)
	}
	return oldValue.LocalCode, nil
}

// ResetLocalCode resets all changes to the "local_code" field.
func (m *RegionMutation) ResetLocalCode() {
	m.local_code = nil
}

// SetName sets the "name" field.
func (m *RegionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RegionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RegionMutation) ResetName() {
	m.name = nil
}

// SetWikipediaLink sets the "wikipedia_link" field.
func (m *RegionMutation) SetWikipediaLink(s string) {
	m.wikipedia_link = &s
}

// WikipediaLink returns the value of the "wikipedia_link" field in the mutation.
func (m *RegionMutation) WikipediaLink() (r string, exists bool) {
	v := m.wikipedia_link
	if v == nil {
		return
	}
	return *v, true
}

// OldWikipediaLink returns the old "wikipedia_link" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldWikipediaLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWikipediaLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWikipediaLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWikipediaLink: %w", err)
	}
	return oldValue.WikipediaLink, nil
}

// ResetWikipediaLink resets all changes to the "wikipedia_link" field.
func (m *RegionMutation) ResetWikipediaLink() {
	m.wikipedia_link = nil
}

// SetKeywords sets the "keywords" field.
func (m *RegionMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *RegionMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *RegionMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *RegionMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *RegionMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
}

// AddAirportIDs adds the "airports" edge to the Airport entity by ids.
func (m *RegionMutation) AddAirportIDs(ids ...uuid.UUID) {
	if m.airports == nil {
		m.airports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.airports[ids[i]] = struct{}{}
	}
}

// ClearAirports clears the "airports" edge to the Airport entity.
func (m *RegionMutation) ClearAirports() {
	m.clearedairports = true
}

// AirportsCleared reports if the "airports" edge to the Airport entity was cleared.
func (m *RegionMutation) AirportsCleared() bool {
	return m.clearedairports
}

// RemoveAirportIDs removes the "airports" edge to the Airport entity by IDs.
func (m *RegionMutation) RemoveAirportIDs(ids ...uuid.UUID) {
	if m.removedairports == nil {
		m.removedairports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.airports, ids[i])
		m.removedairports[ids[i]] = struct{}{}
	}
}

// RemovedAirports returns the removed IDs of the "airports" edge to the Airport entity.
func (m *RegionMutation) RemovedAirportsIDs() (ids []uuid.UUID) {
	for id := range m.removedairports {
		ids = append(ids, id)
	}
	return
}

// AirportsIDs returns the "airports" edge IDs in the mutation.
func (m *RegionMutation) AirportsIDs() (ids []uuid.UUID) {
	for id := range m.airports {
		ids = append(ids, id)
	}
	return
}

// ResetAirports resets all changes to the "airports" edge.
func (m *RegionMutation) ResetAirports() {
	m.airports = nil
	m.clearedairports = false
	m.removedairports = nil
}

// Where appends a list predicates to the RegionMutation builder.
func (m *RegionMutation) Where(ps ...predicate.Region) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Region, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.import_id != nil {
		fields = append(fields, region.FieldImportID)
	}
	if m.hash != nil {
		fields = append(fields, region.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, region.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, region.FieldLastUpdated)
	}
	if m.code != nil {
		fields = append(fields, region.FieldCode)
	}
	if m.local_code != nil {
		fields = append(fields, region.FieldLocalCode)
	}
	if m.name != nil {
		fields = append(fields, region.FieldName)
	}
	if m.wikipedia_link != nil {
		fields = append(fields, region.FieldWikipediaLink)
	}
	if m.keywords != nil {
		fields = append(fields, region.FieldKeywords)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldImportID:
		return m.ImportID()
	case region.FieldHash:
		return m.Hash()
	case region.FieldImportFlag:
		return m.ImportFlag()
	case region.FieldLastUpdated:
		return m.LastUpdated()
	case region.FieldCode:
		return m.Code()
	case region.FieldLocalCode:
		return m.LocalCode()
	case region.FieldName:
		return m.Name()
	case region.FieldWikipediaLink:
		return m.WikipediaLink()
	case region.FieldKeywords:
		return m.Keywords()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldImportID:
		return m.OldImportID(ctx)
	case region.FieldHash:
		return m.OldHash(ctx)
	case region.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case region.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case region.FieldCode:
		return m.OldCode(ctx)
	case region.FieldLocalCode:
		return m.OldLocalCode(ctx)
	case region.FieldName:
		return m.OldName(ctx)
	case region.FieldWikipediaLink:
		return m.OldWikipediaLink(ctx)
	case region.FieldKeywords:
		return m.OldKeywords(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportID(v)
		return nil
	case region.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case region.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case region.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case region.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case region.FieldLocalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalCode(v)
		return nil
	case region.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case region.FieldWikipediaLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWikipediaLink(v)
		return nil
	case region.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMutation) AddedFields() []string {
	var fields []string
	if m.addimport_id != nil {
		fields = append(fields, region.FieldImportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case region.FieldImportID:
		return m.AddedImportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case region.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportID(v)
		return nil
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldImportID:
		m.ResetImportID()
		return nil
	case region.FieldHash:
		m.ResetHash()
		return nil
	case region.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case region.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case region.FieldCode:
		m.ResetCode()
		return nil
	case region.FieldLocalCode:
		m.ResetLocalCode()
		return nil
	case region.FieldName:
		m.ResetName()
		return nil
	case region.FieldWikipediaLink:
		m.ResetWikipediaLink()
		return nil
	case region.FieldKeywords:
		m.ResetKeywords()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.airports != nil {
		edges = append(edges, region.EdgeAirports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.airports))
		for id := range m.airports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedairports != nil {
		edges = append(edges, region.EdgeAirports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.removedairports))
		for id := range m.removedairports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedairports {
		edges = append(edges, region.EdgeAirports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	case region.EdgeAirports:
		return m.clearedairports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgeAirports:
		m.ResetAirports()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}

// RunwayMutation represents an operation that mutates the Runway nodes in the graph.
type RunwayMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	import_id                          *int
	addimport_id                       *int
	hash                               *string
	import_flag                        *bool
	last_updated                       *time.Time
	length                             *int
	addlength                          *int
	width                              *int
	addwidth                           *int
	surface                            *string
	lighted                            *bool
	closed                             *bool
	low_runway_identifier              *string
	low_runway_latitude                *float64
	addlow_runway_latitude             *float64
	low_runway_longitude               *float64
	addlow_runway_longitude            *float64
	low_runway_elevation               *int
	addlow_runway_elevation            *int
	low_runway_heading                 *float64
	addlow_runway_heading              *float64
	low_runway_displaced_threshold     *int
	addlow_runway_displaced_threshold  *int
	high_runway_identifier             *string
	high_runway_latitude               *float64
	addhigh_runway_latitude            *float64
	high_runway_longitude              *float64
	addhigh_runway_longitude           *float64
	high_runway_elevation              *int
	addhigh_runway_elevation           *int
	high_runway_heading                *float64
	addhigh_runway_heading             *float64
	high_runway_displaced_threshold    *int
	addhigh_runway_displaced_threshold *int
	clearedFields                      map[string]struct{}
	airport                            *uuid.UUID
	clearedairport                     bool
	done                               bool
	oldValue                           func(context.Context) (*Runway, error)
	predicates                         []predicate.Runway
}

var _ ent.Mutation = (*RunwayMutation)(nil)

// runwayOption allows management of the mutation configuration using functional options.
type runwayOption func(*RunwayMutation)

// newRunwayMutation creates new mutation for the Runway entity.
func newRunwayMutation(c config, op Op, opts ...runwayOption) *RunwayMutation {
	m := &RunwayMutation{
		config:        c,
		op:            op,
		typ:           TypeRunway,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunwayID sets the ID field of the mutation.
func withRunwayID(id uuid.UUID) runwayOption {
	return func(m *RunwayMutation) {
		var (
			err   error
			once  sync.Once
			value *Runway
		)
		m.oldValue = func(ctx context.Context) (*Runway, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Runway.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRunway sets the old Runway of the mutation.
func withRunway(node *Runway) runwayOption {
	return func(m *RunwayMutation) {
		m.oldValue = func(context.Context) (*Runway, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunwayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunwayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Runway entities.
func (m *RunwayMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RunwayMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RunwayMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Runway.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImportID sets the "import_id" field.
func (m *RunwayMutation) SetImportID(i int) {
	m.import_id = &i
	m.addimport_id = nil
}

// ImportID returns the value of the "import_id" field in the mutation.
func (m *RunwayMutation) ImportID() (r int, exists bool) {
	v := m.import_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImportID returns the old "import_id" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldImportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportID: %w", err)
	}
	return oldValue.ImportID, nil
}

// AddImportID adds i to the "import_id" field.
func (m *RunwayMutation) AddImportID(i int) {
	if m.addimport_id != nil {
		*m.addimport_id += i
	} else {
		m.addimport_id = &i
	}
}

// AddedImportID returns the value that was added to the "import_id" field in this mutation.
func (m *RunwayMutation) AddedImportID() (r int, exists bool) {
	v := m.addimport_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetImportID resets all changes to the "import_id" field.
func (m *RunwayMutation) ResetImportID() {
	m.import_id = nil
	m.addimport_id = nil
}

// SetHash sets the "hash" field.
func (m *RunwayMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *RunwayMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *RunwayMutation) ResetHash() {
	m.hash = nil
}

// SetImportFlag sets the "import_flag" field.
func (m *RunwayMutation) SetImportFlag(b bool) {
	m.import_flag = &b
}

// ImportFlag returns the value of the "import_flag" field in the mutation.
func (m *RunwayMutation) ImportFlag() (r bool, exists bool) {
	v := m.import_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFlag returns the old "import_flag" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldImportFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFlag: %w", err)
	}
	return oldValue.ImportFlag, nil
}

// ResetImportFlag resets all changes to the "import_flag" field.
func (m *RunwayMutation) ResetImportFlag() {
	m.import_flag = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *RunwayMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *RunwayMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *RunwayMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetLength sets the "length" field.
func (m *RunwayMutation) SetLength(i int) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *RunwayMutation) Length() (r int, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *RunwayMutation) AddLength(i int) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *RunwayMutation) AddedLength() (r int, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *RunwayMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the "width" field.
func (m *RunwayMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *RunwayMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *RunwayMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *RunwayMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *RunwayMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetSurface sets the "surface" field.
func (m *RunwayMutation) SetSurface(s string) {
	m.surface = &s
}

// Surface returns the value of the "surface" field in the mutation.
func (m *RunwayMutation) Surface() (r string, exists bool) {
	v := m.surface
	if v == nil {
		return
	}
	return *v, true
}

// OldSurface returns the old "surface" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldSurface(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurface is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurface requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurface: %w", err)
	}
	return oldValue.Surface, nil
}

// ClearSurface clears the value of the "surface" field.
func (m *RunwayMutation) ClearSurface() {
	m.surface = nil
	m.clearedFields[runway.FieldSurface] = struct{}{}
}

// SurfaceCleared returns if the "surface" field was cleared in this mutation.
func (m *RunwayMutation) SurfaceCleared() bool {
	_, ok := m.clearedFields[runway.FieldSurface]
	return ok
}

// ResetSurface resets all changes to the "surface" field.
func (m *RunwayMutation) ResetSurface() {
	m.surface = nil
	delete(m.clearedFields, runway.FieldSurface)
}

// SetLighted sets the "lighted" field.
func (m *RunwayMutation) SetLighted(b bool) {
	m.lighted = &b
}

// Lighted returns the value of the "lighted" field in the mutation.
func (m *RunwayMutation) Lighted() (r bool, exists bool) {
	v := m.lighted
	if v == nil {
		return
	}
	return *v, true
}

// OldLighted returns the old "lighted" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLighted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLighted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLighted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLighted: %w", err)
	}
	return oldValue.Lighted, nil
}

// ResetLighted resets all changes to the "lighted" field.
func (m *RunwayMutation) ResetLighted() {
	m.lighted = nil
}

// SetClosed sets the "closed" field.
func (m *RunwayMutation) SetClosed(b bool) {
	m.closed = &b
}

// Closed returns the value of the "closed" field in the mutation.
func (m *RunwayMutation) Closed() (r bool, exists bool) {
	v := m.closed
	if v == nil {
		return
	}
	return *v, true
}

// OldClosed returns the old "closed" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldClosed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosed: %w", err)
	}
	return oldValue.Closed, nil
}

// ResetClosed resets all changes to the "closed" field.
func (m *RunwayMutation) ResetClosed() {
	m.closed = nil
}

// SetLowRunwayIdentifier sets the "low_runway_identifier" field.
func (m *RunwayMutation) SetLowRunwayIdentifier(s string) {
	m.low_runway_identifier = &s
}

// LowRunwayIdentifier returns the value of the "low_runway_identifier" field in the mutation.
func (m *RunwayMutation) LowRunwayIdentifier() (r string, exists bool) {
	v := m.low_runway_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayIdentifier returns the old "low_runway_identifier" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayIdentifier: %w", err)
	}
	return oldValue.LowRunwayIdentifier, nil
}

// ResetLowRunwayIdentifier resets all changes to the "low_runway_identifier" field.
func (m *RunwayMutation) ResetLowRunwayIdentifier() {
	m.low_runway_identifier = nil
}

// SetLowRunwayLatitude sets the "low_runway_latitude" field.
func (m *RunwayMutation) SetLowRunwayLatitude(f float64) {
	m.low_runway_latitude = &f
	m.addlow_runway_latitude = nil
}

// LowRunwayLatitude returns the value of the "low_runway_latitude" field in the mutation.
func (m *RunwayMutation) LowRunwayLatitude() (r float64, exists bool) {
	v := m.low_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayLatitude returns the old "low_runway_latitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayLatitude: %w", err)
	}
	return oldValue.LowRunwayLatitude, nil
}

// AddLowRunwayLatitude adds f to the "low_runway_latitude" field.
func (m *RunwayMutation) AddLowRunwayLatitude(f float64) {
	if m.addlow_runway_latitude != nil {
		*m.addlow_runway_latitude += f
	} else {
		m.addlow_runway_latitude = &f
	}
}

// AddedLowRunwayLatitude returns the value that was added to the "low_runway_latitude" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayLatitude() (r float64, exists bool) {
	v := m.addlow_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayLatitude clears the value of the "low_runway_latitude" field.
func (m *RunwayMutation) ClearLowRunwayLatitude() {
	m.low_runway_latitude = nil
	m.addlow_runway_latitude = nil
	m.clearedFields[runway.FieldLowRunwayLatitude] = struct{}{}
}

// LowRunwayLatitudeCleared returns if the "low_runway_latitude" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayLatitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayLatitude]
	return ok
}

// ResetLowRunwayLatitude resets all changes to the "low_runway_latitude" field.
func (m *RunwayMutation) ResetLowRunwayLatitude() {
	m.low_runway_latitude = nil
	m.addlow_runway_latitude = nil
	delete(m.clearedFields, runway.FieldLowRunwayLatitude)
}

// SetLowRunwayLongitude sets the "low_runway_longitude" field.
func (m *RunwayMutation) SetLowRunwayLongitude(f float64) {
	m.low_runway_longitude = &f
	m.addlow_runway_longitude = nil
}

// LowRunwayLongitude returns the value of the "low_runway_longitude" field in the mutation.
func (m *RunwayMutation) LowRunwayLongitude() (r float64, exists bool) {
	v := m.low_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayLongitude returns the old "low_runway_longitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayLongitude: %w", err)
	}
	return oldValue.LowRunwayLongitude, nil
}

// AddLowRunwayLongitude adds f to the "low_runway_longitude" field.
func (m *RunwayMutation) AddLowRunwayLongitude(f float64) {
	if m.addlow_runway_longitude != nil {
		*m.addlow_runway_longitude += f
	} else {
		m.addlow_runway_longitude = &f
	}
}

// AddedLowRunwayLongitude returns the value that was added to the "low_runway_longitude" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayLongitude() (r float64, exists bool) {
	v := m.addlow_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayLongitude clears the value of the "low_runway_longitude" field.
func (m *RunwayMutation) ClearLowRunwayLongitude() {
	m.low_runway_longitude = nil
	m.addlow_runway_longitude = nil
	m.clearedFields[runway.FieldLowRunwayLongitude] = struct{}{}
}

// LowRunwayLongitudeCleared returns if the "low_runway_longitude" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayLongitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayLongitude]
	return ok
}

// ResetLowRunwayLongitude resets all changes to the "low_runway_longitude" field.
func (m *RunwayMutation) ResetLowRunwayLongitude() {
	m.low_runway_longitude = nil
	m.addlow_runway_longitude = nil
	delete(m.clearedFields, runway.FieldLowRunwayLongitude)
}

// SetLowRunwayElevation sets the "low_runway_elevation" field.
func (m *RunwayMutation) SetLowRunwayElevation(i int) {
	m.low_runway_elevation = &i
	m.addlow_runway_elevation = nil
}

// LowRunwayElevation returns the value of the "low_runway_elevation" field in the mutation.
func (m *RunwayMutation) LowRunwayElevation() (r int, exists bool) {
	v := m.low_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayElevation returns the old "low_runway_elevation" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayElevation(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayElevation: %w", err)
	}
	return oldValue.LowRunwayElevation, nil
}

// AddLowRunwayElevation adds i to the "low_runway_elevation" field.
func (m *RunwayMutation) AddLowRunwayElevation(i int) {
	if m.addlow_runway_elevation != nil {
		*m.addlow_runway_elevation += i
	} else {
		m.addlow_runway_elevation = &i
	}
}

// AddedLowRunwayElevation returns the value that was added to the "low_runway_elevation" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayElevation() (r int, exists bool) {
	v := m.addlow_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayElevation clears the value of the "low_runway_elevation" field.
func (m *RunwayMutation) ClearLowRunwayElevation() {
	m.low_runway_elevation = nil
	m.addlow_runway_elevation = nil
	m.clearedFields[runway.FieldLowRunwayElevation] = struct{}{}
}

// LowRunwayElevationCleared returns if the "low_runway_elevation" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayElevationCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayElevation]
	return ok
}

// ResetLowRunwayElevation resets all changes to the "low_runway_elevation" field.
func (m *RunwayMutation) ResetLowRunwayElevation() {
	m.low_runway_elevation = nil
	m.addlow_runway_elevation = nil
	delete(m.clearedFields, runway.FieldLowRunwayElevation)
}

// SetLowRunwayHeading sets the "low_runway_heading" field.
func (m *RunwayMutation) SetLowRunwayHeading(f float64) {
	m.low_runway_heading = &f
	m.addlow_runway_heading = nil
}

// LowRunwayHeading returns the value of the "low_runway_heading" field in the mutation.
func (m *RunwayMutation) LowRunwayHeading() (r float64, exists bool) {
	v := m.low_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayHeading returns the old "low_runway_heading" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayHeading(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayHeading is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayHeading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayHeading: %w", err)
	}
	return oldValue.LowRunwayHeading, nil
}

// AddLowRunwayHeading adds f to the "low_runway_heading" field.
func (m *RunwayMutation) AddLowRunwayHeading(f float64) {
	if m.addlow_runway_heading != nil {
		*m.addlow_runway_heading += f
	} else {
		m.addlow_runway_heading = &f
	}
}

// AddedLowRunwayHeading returns the value that was added to the "low_runway_heading" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayHeading() (r float64, exists bool) {
	v := m.addlow_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayHeading clears the value of the "low_runway_heading" field.
func (m *RunwayMutation) ClearLowRunwayHeading() {
	m.low_runway_heading = nil
	m.addlow_runway_heading = nil
	m.clearedFields[runway.FieldLowRunwayHeading] = struct{}{}
}

// LowRunwayHeadingCleared returns if the "low_runway_heading" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayHeadingCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayHeading]
	return ok
}

// ResetLowRunwayHeading resets all changes to the "low_runway_heading" field.
func (m *RunwayMutation) ResetLowRunwayHeading() {
	m.low_runway_heading = nil
	m.addlow_runway_heading = nil
	delete(m.clearedFields, runway.FieldLowRunwayHeading)
}

// SetLowRunwayDisplacedThreshold sets the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) SetLowRunwayDisplacedThreshold(i int) {
	m.low_runway_displaced_threshold = &i
	m.addlow_runway_displaced_threshold = nil
}

// LowRunwayDisplacedThreshold returns the value of the "low_runway_displaced_threshold" field in the mutation.
func (m *RunwayMutation) LowRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.low_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldLowRunwayDisplacedThreshold returns the old "low_runway_displaced_threshold" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldLowRunwayDisplacedThreshold(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowRunwayDisplacedThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowRunwayDisplacedThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowRunwayDisplacedThreshold: %w", err)
	}
	return oldValue.LowRunwayDisplacedThreshold, nil
}

// AddLowRunwayDisplacedThreshold adds i to the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) AddLowRunwayDisplacedThreshold(i int) {
	if m.addlow_runway_displaced_threshold != nil {
		*m.addlow_runway_displaced_threshold += i
	} else {
		m.addlow_runway_displaced_threshold = &i
	}
}

// AddedLowRunwayDisplacedThreshold returns the value that was added to the "low_runway_displaced_threshold" field in this mutation.
func (m *RunwayMutation) AddedLowRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.addlow_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ClearLowRunwayDisplacedThreshold clears the value of the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) ClearLowRunwayDisplacedThreshold() {
	m.low_runway_displaced_threshold = nil
	m.addlow_runway_displaced_threshold = nil
	m.clearedFields[runway.FieldLowRunwayDisplacedThreshold] = struct{}{}
}

// LowRunwayDisplacedThresholdCleared returns if the "low_runway_displaced_threshold" field was cleared in this mutation.
func (m *RunwayMutation) LowRunwayDisplacedThresholdCleared() bool {
	_, ok := m.clearedFields[runway.FieldLowRunwayDisplacedThreshold]
	return ok
}

// ResetLowRunwayDisplacedThreshold resets all changes to the "low_runway_displaced_threshold" field.
func (m *RunwayMutation) ResetLowRunwayDisplacedThreshold() {
	m.low_runway_displaced_threshold = nil
	m.addlow_runway_displaced_threshold = nil
	delete(m.clearedFields, runway.FieldLowRunwayDisplacedThreshold)
}

// SetHighRunwayIdentifier sets the "high_runway_identifier" field.
func (m *RunwayMutation) SetHighRunwayIdentifier(s string) {
	m.high_runway_identifier = &s
}

// HighRunwayIdentifier returns the value of the "high_runway_identifier" field in the mutation.
func (m *RunwayMutation) HighRunwayIdentifier() (r string, exists bool) {
	v := m.high_runway_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayIdentifier returns the old "high_runway_identifier" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayIdentifier: %w", err)
	}
	return oldValue.HighRunwayIdentifier, nil
}

// ResetHighRunwayIdentifier resets all changes to the "high_runway_identifier" field.
func (m *RunwayMutation) ResetHighRunwayIdentifier() {
	m.high_runway_identifier = nil
}

// SetHighRunwayLatitude sets the "high_runway_latitude" field.
func (m *RunwayMutation) SetHighRunwayLatitude(f float64) {
	m.high_runway_latitude = &f
	m.addhigh_runway_latitude = nil
}

// HighRunwayLatitude returns the value of the "high_runway_latitude" field in the mutation.
func (m *RunwayMutation) HighRunwayLatitude() (r float64, exists bool) {
	v := m.high_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayLatitude returns the old "high_runway_latitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayLatitude: %w", err)
	}
	return oldValue.HighRunwayLatitude, nil
}

// AddHighRunwayLatitude adds f to the "high_runway_latitude" field.
func (m *RunwayMutation) AddHighRunwayLatitude(f float64) {
	if m.addhigh_runway_latitude != nil {
		*m.addhigh_runway_latitude += f
	} else {
		m.addhigh_runway_latitude = &f
	}
}

// AddedHighRunwayLatitude returns the value that was added to the "high_runway_latitude" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayLatitude() (r float64, exists bool) {
	v := m.addhigh_runway_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayLatitude clears the value of the "high_runway_latitude" field.
func (m *RunwayMutation) ClearHighRunwayLatitude() {
	m.high_runway_latitude = nil
	m.addhigh_runway_latitude = nil
	m.clearedFields[runway.FieldHighRunwayLatitude] = struct{}{}
}

// HighRunwayLatitudeCleared returns if the "high_runway_latitude" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayLatitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayLatitude]
	return ok
}

// ResetHighRunwayLatitude resets all changes to the "high_runway_latitude" field.
func (m *RunwayMutation) ResetHighRunwayLatitude() {
	m.high_runway_latitude = nil
	m.addhigh_runway_latitude = nil
	delete(m.clearedFields, runway.FieldHighRunwayLatitude)
}

// SetHighRunwayLongitude sets the "high_runway_longitude" field.
func (m *RunwayMutation) SetHighRunwayLongitude(f float64) {
	m.high_runway_longitude = &f
	m.addhigh_runway_longitude = nil
}

// HighRunwayLongitude returns the value of the "high_runway_longitude" field in the mutation.
func (m *RunwayMutation) HighRunwayLongitude() (r float64, exists bool) {
	v := m.high_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayLongitude returns the old "high_runway_longitude" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayLongitude: %w", err)
	}
	return oldValue.HighRunwayLongitude, nil
}

// AddHighRunwayLongitude adds f to the "high_runway_longitude" field.
func (m *RunwayMutation) AddHighRunwayLongitude(f float64) {
	if m.addhigh_runway_longitude != nil {
		*m.addhigh_runway_longitude += f
	} else {
		m.addhigh_runway_longitude = &f
	}
}

// AddedHighRunwayLongitude returns the value that was added to the "high_runway_longitude" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayLongitude() (r float64, exists bool) {
	v := m.addhigh_runway_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayLongitude clears the value of the "high_runway_longitude" field.
func (m *RunwayMutation) ClearHighRunwayLongitude() {
	m.high_runway_longitude = nil
	m.addhigh_runway_longitude = nil
	m.clearedFields[runway.FieldHighRunwayLongitude] = struct{}{}
}

// HighRunwayLongitudeCleared returns if the "high_runway_longitude" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayLongitudeCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayLongitude]
	return ok
}

// ResetHighRunwayLongitude resets all changes to the "high_runway_longitude" field.
func (m *RunwayMutation) ResetHighRunwayLongitude() {
	m.high_runway_longitude = nil
	m.addhigh_runway_longitude = nil
	delete(m.clearedFields, runway.FieldHighRunwayLongitude)
}

// SetHighRunwayElevation sets the "high_runway_elevation" field.
func (m *RunwayMutation) SetHighRunwayElevation(i int) {
	m.high_runway_elevation = &i
	m.addhigh_runway_elevation = nil
}

// HighRunwayElevation returns the value of the "high_runway_elevation" field in the mutation.
func (m *RunwayMutation) HighRunwayElevation() (r int, exists bool) {
	v := m.high_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayElevation returns the old "high_runway_elevation" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayElevation(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayElevation: %w", err)
	}
	return oldValue.HighRunwayElevation, nil
}

// AddHighRunwayElevation adds i to the "high_runway_elevation" field.
func (m *RunwayMutation) AddHighRunwayElevation(i int) {
	if m.addhigh_runway_elevation != nil {
		*m.addhigh_runway_elevation += i
	} else {
		m.addhigh_runway_elevation = &i
	}
}

// AddedHighRunwayElevation returns the value that was added to the "high_runway_elevation" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayElevation() (r int, exists bool) {
	v := m.addhigh_runway_elevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayElevation clears the value of the "high_runway_elevation" field.
func (m *RunwayMutation) ClearHighRunwayElevation() {
	m.high_runway_elevation = nil
	m.addhigh_runway_elevation = nil
	m.clearedFields[runway.FieldHighRunwayElevation] = struct{}{}
}

// HighRunwayElevationCleared returns if the "high_runway_elevation" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayElevationCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayElevation]
	return ok
}

// ResetHighRunwayElevation resets all changes to the "high_runway_elevation" field.
func (m *RunwayMutation) ResetHighRunwayElevation() {
	m.high_runway_elevation = nil
	m.addhigh_runway_elevation = nil
	delete(m.clearedFields, runway.FieldHighRunwayElevation)
}

// SetHighRunwayHeading sets the "high_runway_heading" field.
func (m *RunwayMutation) SetHighRunwayHeading(f float64) {
	m.high_runway_heading = &f
	m.addhigh_runway_heading = nil
}

// HighRunwayHeading returns the value of the "high_runway_heading" field in the mutation.
func (m *RunwayMutation) HighRunwayHeading() (r float64, exists bool) {
	v := m.high_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayHeading returns the old "high_runway_heading" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayHeading(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayHeading is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayHeading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayHeading: %w", err)
	}
	return oldValue.HighRunwayHeading, nil
}

// AddHighRunwayHeading adds f to the "high_runway_heading" field.
func (m *RunwayMutation) AddHighRunwayHeading(f float64) {
	if m.addhigh_runway_heading != nil {
		*m.addhigh_runway_heading += f
	} else {
		m.addhigh_runway_heading = &f
	}
}

// AddedHighRunwayHeading returns the value that was added to the "high_runway_heading" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayHeading() (r float64, exists bool) {
	v := m.addhigh_runway_heading
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayHeading clears the value of the "high_runway_heading" field.
func (m *RunwayMutation) ClearHighRunwayHeading() {
	m.high_runway_heading = nil
	m.addhigh_runway_heading = nil
	m.clearedFields[runway.FieldHighRunwayHeading] = struct{}{}
}

// HighRunwayHeadingCleared returns if the "high_runway_heading" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayHeadingCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayHeading]
	return ok
}

// ResetHighRunwayHeading resets all changes to the "high_runway_heading" field.
func (m *RunwayMutation) ResetHighRunwayHeading() {
	m.high_runway_heading = nil
	m.addhigh_runway_heading = nil
	delete(m.clearedFields, runway.FieldHighRunwayHeading)
}

// SetHighRunwayDisplacedThreshold sets the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) SetHighRunwayDisplacedThreshold(i int) {
	m.high_runway_displaced_threshold = &i
	m.addhigh_runway_displaced_threshold = nil
}

// HighRunwayDisplacedThreshold returns the value of the "high_runway_displaced_threshold" field in the mutation.
func (m *RunwayMutation) HighRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.high_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldHighRunwayDisplacedThreshold returns the old "high_runway_displaced_threshold" field's value of the Runway entity.
// If the Runway object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunwayMutation) OldHighRunwayDisplacedThreshold(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighRunwayDisplacedThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighRunwayDisplacedThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighRunwayDisplacedThreshold: %w", err)
	}
	return oldValue.HighRunwayDisplacedThreshold, nil
}

// AddHighRunwayDisplacedThreshold adds i to the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) AddHighRunwayDisplacedThreshold(i int) {
	if m.addhigh_runway_displaced_threshold != nil {
		*m.addhigh_runway_displaced_threshold += i
	} else {
		m.addhigh_runway_displaced_threshold = &i
	}
}

// AddedHighRunwayDisplacedThreshold returns the value that was added to the "high_runway_displaced_threshold" field in this mutation.
func (m *RunwayMutation) AddedHighRunwayDisplacedThreshold() (r int, exists bool) {
	v := m.addhigh_runway_displaced_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ClearHighRunwayDisplacedThreshold clears the value of the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) ClearHighRunwayDisplacedThreshold() {
	m.high_runway_displaced_threshold = nil
	m.addhigh_runway_displaced_threshold = nil
	m.clearedFields[runway.FieldHighRunwayDisplacedThreshold] = struct{}{}
}

// HighRunwayDisplacedThresholdCleared returns if the "high_runway_displaced_threshold" field was cleared in this mutation.
func (m *RunwayMutation) HighRunwayDisplacedThresholdCleared() bool {
	_, ok := m.clearedFields[runway.FieldHighRunwayDisplacedThreshold]
	return ok
}

// ResetHighRunwayDisplacedThreshold resets all changes to the "high_runway_displaced_threshold" field.
func (m *RunwayMutation) ResetHighRunwayDisplacedThreshold() {
	m.high_runway_displaced_threshold = nil
	m.addhigh_runway_displaced_threshold = nil
	delete(m.clearedFields, runway.FieldHighRunwayDisplacedThreshold)
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *RunwayMutation) SetAirportID(id uuid.UUID) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *RunwayMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *RunwayMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *RunwayMutation) AirportID() (id uuid.UUID, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *RunwayMutation) AirportIDs() (ids []uuid.UUID) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *RunwayMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// Where appends a list predicates to the RunwayMutation builder.
func (m *RunwayMutation) Where(ps ...predicate.Runway) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RunwayMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RunwayMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Runway, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RunwayMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RunwayMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Runway).
func (m *RunwayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RunwayMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.import_id != nil {
		fields = append(fields, runway.FieldImportID)
	}
	if m.hash != nil {
		fields = append(fields, runway.FieldHash)
	}
	if m.import_flag != nil {
		fields = append(fields, runway.FieldImportFlag)
	}
	if m.last_updated != nil {
		fields = append(fields, runway.FieldLastUpdated)
	}
	if m.length != nil {
		fields = append(fields, runway.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, runway.FieldWidth)
	}
	if m.surface != nil {
		fields = append(fields, runway.FieldSurface)
	}
	if m.lighted != nil {
		fields = append(fields, runway.FieldLighted)
	}
	if m.closed != nil {
		fields = append(fields, runway.FieldClosed)
	}
	if m.low_runway_identifier != nil {
		fields = append(fields, runway.FieldLowRunwayIdentifier)
	}
	if m.low_runway_latitude != nil {
		fields = append(fields, runway.FieldLowRunwayLatitude)
	}
	if m.low_runway_longitude != nil {
		fields = append(fields, runway.FieldLowRunwayLongitude)
	}
	if m.low_runway_elevation != nil {
		fields = append(fields, runway.FieldLowRunwayElevation)
	}
	if m.low_runway_heading != nil {
		fields = append(fields, runway.FieldLowRunwayHeading)
	}
	if m.low_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldLowRunwayDisplacedThreshold)
	}
	if m.high_runway_identifier != nil {
		fields = append(fields, runway.FieldHighRunwayIdentifier)
	}
	if m.high_runway_latitude != nil {
		fields = append(fields, runway.FieldHighRunwayLatitude)
	}
	if m.high_runway_longitude != nil {
		fields = append(fields, runway.FieldHighRunwayLongitude)
	}
	if m.high_runway_elevation != nil {
		fields = append(fields, runway.FieldHighRunwayElevation)
	}
	if m.high_runway_heading != nil {
		fields = append(fields, runway.FieldHighRunwayHeading)
	}
	if m.high_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldHighRunwayDisplacedThreshold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RunwayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case runway.FieldImportID:
		return m.ImportID()
	case runway.FieldHash:
		return m.Hash()
	case runway.FieldImportFlag:
		return m.ImportFlag()
	case runway.FieldLastUpdated:
		return m.LastUpdated()
	case runway.FieldLength:
		return m.Length()
	case runway.FieldWidth:
		return m.Width()
	case runway.FieldSurface:
		return m.Surface()
	case runway.FieldLighted:
		return m.Lighted()
	case runway.FieldClosed:
		return m.Closed()
	case runway.FieldLowRunwayIdentifier:
		return m.LowRunwayIdentifier()
	case runway.FieldLowRunwayLatitude:
		return m.LowRunwayLatitude()
	case runway.FieldLowRunwayLongitude:
		return m.LowRunwayLongitude()
	case runway.FieldLowRunwayElevation:
		return m.LowRunwayElevation()
	case runway.FieldLowRunwayHeading:
		return m.LowRunwayHeading()
	case runway.FieldLowRunwayDisplacedThreshold:
		return m.LowRunwayDisplacedThreshold()
	case runway.FieldHighRunwayIdentifier:
		return m.HighRunwayIdentifier()
	case runway.FieldHighRunwayLatitude:
		return m.HighRunwayLatitude()
	case runway.FieldHighRunwayLongitude:
		return m.HighRunwayLongitude()
	case runway.FieldHighRunwayElevation:
		return m.HighRunwayElevation()
	case runway.FieldHighRunwayHeading:
		return m.HighRunwayHeading()
	case runway.FieldHighRunwayDisplacedThreshold:
		return m.HighRunwayDisplacedThreshold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RunwayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case runway.FieldImportID:
		return m.OldImportID(ctx)
	case runway.FieldHash:
		return m.OldHash(ctx)
	case runway.FieldImportFlag:
		return m.OldImportFlag(ctx)
	case runway.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case runway.FieldLength:
		return m.OldLength(ctx)
	case runway.FieldWidth:
		return m.OldWidth(ctx)
	case runway.FieldSurface:
		return m.OldSurface(ctx)
	case runway.FieldLighted:
		return m.OldLighted(ctx)
	case runway.FieldClosed:
		return m.OldClosed(ctx)
	case runway.FieldLowRunwayIdentifier:
		return m.OldLowRunwayIdentifier(ctx)
	case runway.FieldLowRunwayLatitude:
		return m.OldLowRunwayLatitude(ctx)
	case runway.FieldLowRunwayLongitude:
		return m.OldLowRunwayLongitude(ctx)
	case runway.FieldLowRunwayElevation:
		return m.OldLowRunwayElevation(ctx)
	case runway.FieldLowRunwayHeading:
		return m.OldLowRunwayHeading(ctx)
	case runway.FieldLowRunwayDisplacedThreshold:
		return m.OldLowRunwayDisplacedThreshold(ctx)
	case runway.FieldHighRunwayIdentifier:
		return m.OldHighRunwayIdentifier(ctx)
	case runway.FieldHighRunwayLatitude:
		return m.OldHighRunwayLatitude(ctx)
	case runway.FieldHighRunwayLongitude:
		return m.OldHighRunwayLongitude(ctx)
	case runway.FieldHighRunwayElevation:
		return m.OldHighRunwayElevation(ctx)
	case runway.FieldHighRunwayHeading:
		return m.OldHighRunwayHeading(ctx)
	case runway.FieldHighRunwayDisplacedThreshold:
		return m.OldHighRunwayDisplacedThreshold(ctx)
	}
	return nil, fmt.Errorf("unknown Runway field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunwayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case runway.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportID(v)
		return nil
	case runway.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case runway.FieldImportFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFlag(v)
		return nil
	case runway.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case runway.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case runway.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case runway.FieldSurface:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurface(v)
		return nil
	case runway.FieldLighted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLighted(v)
		return nil
	case runway.FieldClosed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosed(v)
		return nil
	case runway.FieldLowRunwayIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayIdentifier(v)
		return nil
	case runway.FieldLowRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayLatitude(v)
		return nil
	case runway.FieldLowRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayLongitude(v)
		return nil
	case runway.FieldLowRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayElevation(v)
		return nil
	case runway.FieldLowRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayHeading(v)
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowRunwayDisplacedThreshold(v)
		return nil
	case runway.FieldHighRunwayIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayIdentifier(v)
		return nil
	case runway.FieldHighRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayLatitude(v)
		return nil
	case runway.FieldHighRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayLongitude(v)
		return nil
	case runway.FieldHighRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayElevation(v)
		return nil
	case runway.FieldHighRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayHeading(v)
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighRunwayDisplacedThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown Runway field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RunwayMutation) AddedFields() []string {
	var fields []string
	if m.addimport_id != nil {
		fields = append(fields, runway.FieldImportID)
	}
	if m.addlength != nil {
		fields = append(fields, runway.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, runway.FieldWidth)
	}
	if m.addlow_runway_latitude != nil {
		fields = append(fields, runway.FieldLowRunwayLatitude)
	}
	if m.addlow_runway_longitude != nil {
		fields = append(fields, runway.FieldLowRunwayLongitude)
	}
	if m.addlow_runway_elevation != nil {
		fields = append(fields, runway.FieldLowRunwayElevation)
	}
	if m.addlow_runway_heading != nil {
		fields = append(fields, runway.FieldLowRunwayHeading)
	}
	if m.addlow_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldLowRunwayDisplacedThreshold)
	}
	if m.addhigh_runway_latitude != nil {
		fields = append(fields, runway.FieldHighRunwayLatitude)
	}
	if m.addhigh_runway_longitude != nil {
		fields = append(fields, runway.FieldHighRunwayLongitude)
	}
	if m.addhigh_runway_elevation != nil {
		fields = append(fields, runway.FieldHighRunwayElevation)
	}
	if m.addhigh_runway_heading != nil {
		fields = append(fields, runway.FieldHighRunwayHeading)
	}
	if m.addhigh_runway_displaced_threshold != nil {
		fields = append(fields, runway.FieldHighRunwayDisplacedThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RunwayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case runway.FieldImportID:
		return m.AddedImportID()
	case runway.FieldLength:
		return m.AddedLength()
	case runway.FieldWidth:
		return m.AddedWidth()
	case runway.FieldLowRunwayLatitude:
		return m.AddedLowRunwayLatitude()
	case runway.FieldLowRunwayLongitude:
		return m.AddedLowRunwayLongitude()
	case runway.FieldLowRunwayElevation:
		return m.AddedLowRunwayElevation()
	case runway.FieldLowRunwayHeading:
		return m.AddedLowRunwayHeading()
	case runway.FieldLowRunwayDisplacedThreshold:
		return m.AddedLowRunwayDisplacedThreshold()
	case runway.FieldHighRunwayLatitude:
		return m.AddedHighRunwayLatitude()
	case runway.FieldHighRunwayLongitude:
		return m.AddedHighRunwayLongitude()
	case runway.FieldHighRunwayElevation:
		return m.AddedHighRunwayElevation()
	case runway.FieldHighRunwayHeading:
		return m.AddedHighRunwayHeading()
	case runway.FieldHighRunwayDisplacedThreshold:
		return m.AddedHighRunwayDisplacedThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunwayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case runway.FieldImportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportID(v)
		return nil
	case runway.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case runway.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case runway.FieldLowRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayLatitude(v)
		return nil
	case runway.FieldLowRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayLongitude(v)
		return nil
	case runway.FieldLowRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayElevation(v)
		return nil
	case runway.FieldLowRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayHeading(v)
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLowRunwayDisplacedThreshold(v)
		return nil
	case runway.FieldHighRunwayLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayLatitude(v)
		return nil
	case runway.FieldHighRunwayLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayLongitude(v)
		return nil
	case runway.FieldHighRunwayElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayElevation(v)
		return nil
	case runway.FieldHighRunwayHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayHeading(v)
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighRunwayDisplacedThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown Runway numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RunwayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(runway.FieldSurface) {
		fields = append(fields, runway.FieldSurface)
	}
	if m.FieldCleared(runway.FieldLowRunwayLatitude) {
		fields = append(fields, runway.FieldLowRunwayLatitude)
	}
	if m.FieldCleared(runway.FieldLowRunwayLongitude) {
		fields = append(fields, runway.FieldLowRunwayLongitude)
	}
	if m.FieldCleared(runway.FieldLowRunwayElevation) {
		fields = append(fields, runway.FieldLowRunwayElevation)
	}
	if m.FieldCleared(runway.FieldLowRunwayHeading) {
		fields = append(fields, runway.FieldLowRunwayHeading)
	}
	if m.FieldCleared(runway.FieldLowRunwayDisplacedThreshold) {
		fields = append(fields, runway.FieldLowRunwayDisplacedThreshold)
	}
	if m.FieldCleared(runway.FieldHighRunwayLatitude) {
		fields = append(fields, runway.FieldHighRunwayLatitude)
	}
	if m.FieldCleared(runway.FieldHighRunwayLongitude) {
		fields = append(fields, runway.FieldHighRunwayLongitude)
	}
	if m.FieldCleared(runway.FieldHighRunwayElevation) {
		fields = append(fields, runway.FieldHighRunwayElevation)
	}
	if m.FieldCleared(runway.FieldHighRunwayHeading) {
		fields = append(fields, runway.FieldHighRunwayHeading)
	}
	if m.FieldCleared(runway.FieldHighRunwayDisplacedThreshold) {
		fields = append(fields, runway.FieldHighRunwayDisplacedThreshold)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RunwayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunwayMutation) ClearField(name string) error {
	switch name {
	case runway.FieldSurface:
		m.ClearSurface()
		return nil
	case runway.FieldLowRunwayLatitude:
		m.ClearLowRunwayLatitude()
		return nil
	case runway.FieldLowRunwayLongitude:
		m.ClearLowRunwayLongitude()
		return nil
	case runway.FieldLowRunwayElevation:
		m.ClearLowRunwayElevation()
		return nil
	case runway.FieldLowRunwayHeading:
		m.ClearLowRunwayHeading()
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		m.ClearLowRunwayDisplacedThreshold()
		return nil
	case runway.FieldHighRunwayLatitude:
		m.ClearHighRunwayLatitude()
		return nil
	case runway.FieldHighRunwayLongitude:
		m.ClearHighRunwayLongitude()
		return nil
	case runway.FieldHighRunwayElevation:
		m.ClearHighRunwayElevation()
		return nil
	case runway.FieldHighRunwayHeading:
		m.ClearHighRunwayHeading()
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		m.ClearHighRunwayDisplacedThreshold()
		return nil
	}
	return fmt.Errorf("unknown Runway nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RunwayMutation) ResetField(name string) error {
	switch name {
	case runway.FieldImportID:
		m.ResetImportID()
		return nil
	case runway.FieldHash:
		m.ResetHash()
		return nil
	case runway.FieldImportFlag:
		m.ResetImportFlag()
		return nil
	case runway.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case runway.FieldLength:
		m.ResetLength()
		return nil
	case runway.FieldWidth:
		m.ResetWidth()
		return nil
	case runway.FieldSurface:
		m.ResetSurface()
		return nil
	case runway.FieldLighted:
		m.ResetLighted()
		return nil
	case runway.FieldClosed:
		m.ResetClosed()
		return nil
	case runway.FieldLowRunwayIdentifier:
		m.ResetLowRunwayIdentifier()
		return nil
	case runway.FieldLowRunwayLatitude:
		m.ResetLowRunwayLatitude()
		return nil
	case runway.FieldLowRunwayLongitude:
		m.ResetLowRunwayLongitude()
		return nil
	case runway.FieldLowRunwayElevation:
		m.ResetLowRunwayElevation()
		return nil
	case runway.FieldLowRunwayHeading:
		m.ResetLowRunwayHeading()
		return nil
	case runway.FieldLowRunwayDisplacedThreshold:
		m.ResetLowRunwayDisplacedThreshold()
		return nil
	case runway.FieldHighRunwayIdentifier:
		m.ResetHighRunwayIdentifier()
		return nil
	case runway.FieldHighRunwayLatitude:
		m.ResetHighRunwayLatitude()
		return nil
	case runway.FieldHighRunwayLongitude:
		m.ResetHighRunwayLongitude()
		return nil
	case runway.FieldHighRunwayElevation:
		m.ResetHighRunwayElevation()
		return nil
	case runway.FieldHighRunwayHeading:
		m.ResetHighRunwayHeading()
		return nil
	case runway.FieldHighRunwayDisplacedThreshold:
		m.ResetHighRunwayDisplacedThreshold()
		return nil
	}
	return fmt.Errorf("unknown Runway field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RunwayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.airport != nil {
		edges = append(edges, runway.EdgeAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RunwayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case runway.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RunwayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RunwayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RunwayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedairport {
		edges = append(edges, runway.EdgeAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RunwayMutation) EdgeCleared(name string) bool {
	switch name {
	case runway.EdgeAirport:
		return m.clearedairport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RunwayMutation) ClearEdge(name string) error {
	switch name {
	case runway.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown Runway unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RunwayMutation) ResetEdge(name string) error {
	switch name {
	case runway.EdgeAirport:
		m.ResetAirport()
		return nil
	}
	return fmt.Errorf("unknown Runway edge %s", name)
}

// SkyConditionMutation represents an operation that mutates the SkyCondition nodes in the graph.
type SkyConditionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	sky_cover     *skycondition.SkyCover
	cloud_base    *int
	addcloud_base *int
	cloud_type    *skycondition.CloudType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SkyCondition, error)
	predicates    []predicate.SkyCondition
}

var _ ent.Mutation = (*SkyConditionMutation)(nil)

// skyconditionOption allows management of the mutation configuration using functional options.
type skyconditionOption func(*SkyConditionMutation)

// newSkyConditionMutation creates new mutation for the SkyCondition entity.
func newSkyConditionMutation(c config, op Op, opts ...skyconditionOption) *SkyConditionMutation {
	m := &SkyConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeSkyCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkyConditionID sets the ID field of the mutation.
func withSkyConditionID(id uuid.UUID) skyconditionOption {
	return func(m *SkyConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *SkyCondition
		)
		m.oldValue = func(ctx context.Context) (*SkyCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkyCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkyCondition sets the old SkyCondition of the mutation.
func withSkyCondition(node *SkyCondition) skyconditionOption {
	return func(m *SkyConditionMutation) {
		m.oldValue = func(context.Context) (*SkyCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkyConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkyConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SkyCondition entities.
func (m *SkyConditionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkyConditionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkyConditionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SkyCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSkyCover sets the "sky_cover" field.
func (m *SkyConditionMutation) SetSkyCover(sc skycondition.SkyCover) {
	m.sky_cover = &sc
}

// SkyCover returns the value of the "sky_cover" field in the mutation.
func (m *SkyConditionMutation) SkyCover() (r skycondition.SkyCover, exists bool) {
	v := m.sky_cover
	if v == nil {
		return
	}
	return *v, true
}

// OldSkyCover returns the old "sky_cover" field's value of the SkyCondition entity.
// If the SkyCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkyConditionMutation) OldSkyCover(ctx context.Context) (v skycondition.SkyCover, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkyCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkyCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkyCover: %w", err)
	}
	return oldValue.SkyCover, nil
}

// ResetSkyCover resets all changes to the "sky_cover" field.
func (m *SkyConditionMutation) ResetSkyCover() {
	m.sky_cover = nil
}

// SetCloudBase sets the "cloud_base" field.
func (m *SkyConditionMutation) SetCloudBase(i int) {
	m.cloud_base = &i
	m.addcloud_base = nil
}

// CloudBase returns the value of the "cloud_base" field in the mutation.
func (m *SkyConditionMutation) CloudBase() (r int, exists bool) {
	v := m.cloud_base
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudBase returns the old "cloud_base" field's value of the SkyCondition entity.
// If the SkyCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkyConditionMutation) OldCloudBase(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudBase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudBase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudBase: %w", err)
	}
	return oldValue.CloudBase, nil
}

// AddCloudBase adds i to the "cloud_base" field.
func (m *SkyConditionMutation) AddCloudBase(i int) {
	if m.addcloud_base != nil {
		*m.addcloud_base += i
	} else {
		m.addcloud_base = &i
	}
}

// AddedCloudBase returns the value that was added to the "cloud_base" field in this mutation.
func (m *SkyConditionMutation) AddedCloudBase() (r int, exists bool) {
	v := m.addcloud_base
	if v == nil {
		return
	}
	return *v, true
}

// ClearCloudBase clears the value of the "cloud_base" field.
func (m *SkyConditionMutation) ClearCloudBase() {
	m.cloud_base = nil
	m.addcloud_base = nil
	m.clearedFields[skycondition.FieldCloudBase] = struct{}{}
}

// CloudBaseCleared returns if the "cloud_base" field was cleared in this mutation.
func (m *SkyConditionMutation) CloudBaseCleared() bool {
	_, ok := m.clearedFields[skycondition.FieldCloudBase]
	return ok
}

// ResetCloudBase resets all changes to the "cloud_base" field.
func (m *SkyConditionMutation) ResetCloudBase() {
	m.cloud_base = nil
	m.addcloud_base = nil
	delete(m.clearedFields, skycondition.FieldCloudBase)
}

// SetCloudType sets the "cloud_type" field.
func (m *SkyConditionMutation) SetCloudType(st skycondition.CloudType) {
	m.cloud_type = &st
}

// CloudType returns the value of the "cloud_type" field in the mutation.
func (m *SkyConditionMutation) CloudType() (r skycondition.CloudType, exists bool) {
	v := m.cloud_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudType returns the old "cloud_type" field's value of the SkyCondition entity.
// If the SkyCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkyConditionMutation) OldCloudType(ctx context.Context) (v *skycondition.CloudType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudType: %w", err)
	}
	return oldValue.CloudType, nil
}

// ClearCloudType clears the value of the "cloud_type" field.
func (m *SkyConditionMutation) ClearCloudType() {
	m.cloud_type = nil
	m.clearedFields[skycondition.FieldCloudType] = struct{}{}
}

// CloudTypeCleared returns if the "cloud_type" field was cleared in this mutation.
func (m *SkyConditionMutation) CloudTypeCleared() bool {
	_, ok := m.clearedFields[skycondition.FieldCloudType]
	return ok
}

// ResetCloudType resets all changes to the "cloud_type" field.
func (m *SkyConditionMutation) ResetCloudType() {
	m.cloud_type = nil
	delete(m.clearedFields, skycondition.FieldCloudType)
}

// Where appends a list predicates to the SkyConditionMutation builder.
func (m *SkyConditionMutation) Where(ps ...predicate.SkyCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkyConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkyConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SkyCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkyConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkyConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SkyCondition).
func (m *SkyConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkyConditionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.sky_cover != nil {
		fields = append(fields, skycondition.FieldSkyCover)
	}
	if m.cloud_base != nil {
		fields = append(fields, skycondition.FieldCloudBase)
	}
	if m.cloud_type != nil {
		fields = append(fields, skycondition.FieldCloudType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkyConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skycondition.FieldSkyCover:
		return m.SkyCover()
	case skycondition.FieldCloudBase:
		return m.CloudBase()
	case skycondition.FieldCloudType:
		return m.CloudType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkyConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skycondition.FieldSkyCover:
		return m.OldSkyCover(ctx)
	case skycondition.FieldCloudBase:
		return m.OldCloudBase(ctx)
	case skycondition.FieldCloudType:
		return m.OldCloudType(ctx)
	}
	return nil, fmt.Errorf("unknown SkyCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkyConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skycondition.FieldSkyCover:
		v, ok := value.(skycondition.SkyCover)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkyCover(v)
		return nil
	case skycondition.FieldCloudBase:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudBase(v)
		return nil
	case skycondition.FieldCloudType:
		v, ok := value.(skycondition.CloudType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudType(v)
		return nil
	}
	return fmt.Errorf("unknown SkyCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkyConditionMutation) AddedFields() []string {
	var fields []string
	if m.addcloud_base != nil {
		fields = append(fields, skycondition.FieldCloudBase)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkyConditionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case skycondition.FieldCloudBase:
		return m.AddedCloudBase()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkyConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case skycondition.FieldCloudBase:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCloudBase(v)
		return nil
	}
	return fmt.Errorf("unknown SkyCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkyConditionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skycondition.FieldCloudBase) {
		fields = append(fields, skycondition.FieldCloudBase)
	}
	if m.FieldCleared(skycondition.FieldCloudType) {
		fields = append(fields, skycondition.FieldCloudType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkyConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkyConditionMutation) ClearField(name string) error {
	switch name {
	case skycondition.FieldCloudBase:
		m.ClearCloudBase()
		return nil
	case skycondition.FieldCloudType:
		m.ClearCloudType()
		return nil
	}
	return fmt.Errorf("unknown SkyCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkyConditionMutation) ResetField(name string) error {
	switch name {
	case skycondition.FieldSkyCover:
		m.ResetSkyCover()
		return nil
	case skycondition.FieldCloudBase:
		m.ResetCloudBase()
		return nil
	case skycondition.FieldCloudType:
		m.ResetCloudType()
		return nil
	}
	return fmt.Errorf("unknown SkyCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkyConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkyConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkyConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkyConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkyConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkyConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkyConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SkyCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkyConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SkyCondition edge %s", name)
}

// TafMutation represents an operation that mutates the Taf nodes in the graph.
type TafMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	raw_text        *string
	issue_time      *time.Time
	import_time     *time.Time
	bulletin_time   *time.Time
	valid_from_time *time.Time
	valid_to_time   *time.Time
	remarks         *string
	hash            *string
	clearedFields   map[string]struct{}
	station         *uuid.UUID
	clearedstation  bool
	forecast        map[uuid.UUID]struct{}
	removedforecast map[uuid.UUID]struct{}
	clearedforecast bool
	done            bool
	oldValue        func(context.Context) (*Taf, error)
	predicates      []predicate.Taf
}

var _ ent.Mutation = (*TafMutation)(nil)

// tafOption allows management of the mutation configuration using functional options.
type tafOption func(*TafMutation)

// newTafMutation creates new mutation for the Taf entity.
func newTafMutation(c config, op Op, opts ...tafOption) *TafMutation {
	m := &TafMutation{
		config:        c,
		op:            op,
		typ:           TypeTaf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTafID sets the ID field of the mutation.
func withTafID(id uuid.UUID) tafOption {
	return func(m *TafMutation) {
		var (
			err   error
			once  sync.Once
			value *Taf
		)
		m.oldValue = func(ctx context.Context) (*Taf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Taf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaf sets the old Taf of the mutation.
func withTaf(node *Taf) tafOption {
	return func(m *TafMutation) {
		m.oldValue = func(context.Context) (*Taf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TafMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TafMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Taf entities.
func (m *TafMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TafMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TafMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Taf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRawText sets the "raw_text" field.
func (m *TafMutation) SetRawText(s string) {
	m.raw_text = &s
}

// RawText returns the value of the "raw_text" field in the mutation.
func (m *TafMutation) RawText() (r string, exists bool) {
	v := m.raw_text
	if v == nil {
		return
	}
	return *v, true
}

// OldRawText returns the old "raw_text" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldRawText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawText: %w", err)
	}
	return oldValue.RawText, nil
}

// ResetRawText resets all changes to the "raw_text" field.
func (m *TafMutation) ResetRawText() {
	m.raw_text = nil
}

// SetIssueTime sets the "issue_time" field.
func (m *TafMutation) SetIssueTime(t time.Time) {
	m.issue_time = &t
}

// IssueTime returns the value of the "issue_time" field in the mutation.
func (m *TafMutation) IssueTime() (r time.Time, exists bool) {
	v := m.issue_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueTime returns the old "issue_time" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldIssueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueTime: %w", err)
	}
	return oldValue.IssueTime, nil
}

// ResetIssueTime resets all changes to the "issue_time" field.
func (m *TafMutation) ResetIssueTime() {
	m.issue_time = nil
}

// SetImportTime sets the "import_time" field.
func (m *TafMutation) SetImportTime(t time.Time) {
	m.import_time = &t
}

// ImportTime returns the value of the "import_time" field in the mutation.
func (m *TafMutation) ImportTime() (r time.Time, exists bool) {
	v := m.import_time
	if v == nil {
		return
	}
	return *v, true
}

// OldImportTime returns the old "import_time" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldImportTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportTime: %w", err)
	}
	return oldValue.ImportTime, nil
}

// ResetImportTime resets all changes to the "import_time" field.
func (m *TafMutation) ResetImportTime() {
	m.import_time = nil
}

// SetBulletinTime sets the "bulletin_time" field.
func (m *TafMutation) SetBulletinTime(t time.Time) {
	m.bulletin_time = &t
}

// BulletinTime returns the value of the "bulletin_time" field in the mutation.
func (m *TafMutation) BulletinTime() (r time.Time, exists bool) {
	v := m.bulletin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBulletinTime returns the old "bulletin_time" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldBulletinTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBulletinTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBulletinTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBulletinTime: %w", err)
	}
	return oldValue.BulletinTime, nil
}

// ResetBulletinTime resets all changes to the "bulletin_time" field.
func (m *TafMutation) ResetBulletinTime() {
	m.bulletin_time = nil
}

// SetValidFromTime sets the "valid_from_time" field.
func (m *TafMutation) SetValidFromTime(t time.Time) {
	m.valid_from_time = &t
}

// ValidFromTime returns the value of the "valid_from_time" field in the mutation.
func (m *TafMutation) ValidFromTime() (r time.Time, exists bool) {
	v := m.valid_from_time
	if v == nil {
		return
	}
	return *v, true
}

// OldValidFromTime returns the old "valid_from_time" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldValidFromTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidFromTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidFromTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidFromTime: %w", err)
	}
	return oldValue.ValidFromTime, nil
}

// ResetValidFromTime resets all changes to the "valid_from_time" field.
func (m *TafMutation) ResetValidFromTime() {
	m.valid_from_time = nil
}

// SetValidToTime sets the "valid_to_time" field.
func (m *TafMutation) SetValidToTime(t time.Time) {
	m.valid_to_time = &t
}

// ValidToTime returns the value of the "valid_to_time" field in the mutation.
func (m *TafMutation) ValidToTime() (r time.Time, exists bool) {
	v := m.valid_to_time
	if v == nil {
		return
	}
	return *v, true
}

// OldValidToTime returns the old "valid_to_time" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldValidToTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidToTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidToTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidToTime: %w", err)
	}
	return oldValue.ValidToTime, nil
}

// ResetValidToTime resets all changes to the "valid_to_time" field.
func (m *TafMutation) ResetValidToTime() {
	m.valid_to_time = nil
}

// SetRemarks sets the "remarks" field.
func (m *TafMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *TafMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *TafMutation) ResetRemarks() {
	m.remarks = nil
}

// SetHash sets the "hash" field.
func (m *TafMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *TafMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Taf entity.
// If the Taf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TafMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *TafMutation) ResetHash() {
	m.hash = nil
}

// SetStationID sets the "station" edge to the WeatherStation entity by id.
func (m *TafMutation) SetStationID(id uuid.UUID) {
	m.station = &id
}

// ClearStation clears the "station" edge to the WeatherStation entity.
func (m *TafMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the WeatherStation entity was cleared.
func (m *TafMutation) StationCleared() bool {
	return m.clearedstation
}

// StationID returns the "station" edge ID in the mutation.
func (m *TafMutation) StationID() (id uuid.UUID, exists bool) {
	if m.station != nil {
		return *m.station, true
	}
	return
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *TafMutation) StationIDs() (ids []uuid.UUID) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *TafMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// AddForecastIDs adds the "forecast" edge to the Forecast entity by ids.
func (m *TafMutation) AddForecastIDs(ids ...uuid.UUID) {
	if m.forecast == nil {
		m.forecast = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.forecast[ids[i]] = struct{}{}
	}
}

// ClearForecast clears the "forecast" edge to the Forecast entity.
func (m *TafMutation) ClearForecast() {
	m.clearedforecast = true
}

// ForecastCleared reports if the "forecast" edge to the Forecast entity was cleared.
func (m *TafMutation) ForecastCleared() bool {
	return m.clearedforecast
}

// RemoveForecastIDs removes the "forecast" edge to the Forecast entity by IDs.
func (m *TafMutation) RemoveForecastIDs(ids ...uuid.UUID) {
	if m.removedforecast == nil {
		m.removedforecast = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.forecast, ids[i])
		m.removedforecast[ids[i]] = struct{}{}
	}
}

// RemovedForecast returns the removed IDs of the "forecast" edge to the Forecast entity.
func (m *TafMutation) RemovedForecastIDs() (ids []uuid.UUID) {
	for id := range m.removedforecast {
		ids = append(ids, id)
	}
	return
}

// ForecastIDs returns the "forecast" edge IDs in the mutation.
func (m *TafMutation) ForecastIDs() (ids []uuid.UUID) {
	for id := range m.forecast {
		ids = append(ids, id)
	}
	return
}

// ResetForecast resets all changes to the "forecast" edge.
func (m *TafMutation) ResetForecast() {
	m.forecast = nil
	m.clearedforecast = false
	m.removedforecast = nil
}

// Where appends a list predicates to the TafMutation builder.
func (m *TafMutation) Where(ps ...predicate.Taf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TafMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TafMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Taf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TafMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TafMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Taf).
func (m *TafMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TafMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.raw_text != nil {
		fields = append(fields, taf.FieldRawText)
	}
	if m.issue_time != nil {
		fields = append(fields, taf.FieldIssueTime)
	}
	if m.import_time != nil {
		fields = append(fields, taf.FieldImportTime)
	}
	if m.bulletin_time != nil {
		fields = append(fields, taf.FieldBulletinTime)
	}
	if m.valid_from_time != nil {
		fields = append(fields, taf.FieldValidFromTime)
	}
	if m.valid_to_time != nil {
		fields = append(fields, taf.FieldValidToTime)
	}
	if m.remarks != nil {
		fields = append(fields, taf.FieldRemarks)
	}
	if m.hash != nil {
		fields = append(fields, taf.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TafMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taf.FieldRawText:
		return m.RawText()
	case taf.FieldIssueTime:
		return m.IssueTime()
	case taf.FieldImportTime:
		return m.ImportTime()
	case taf.FieldBulletinTime:
		return m.BulletinTime()
	case taf.FieldValidFromTime:
		return m.ValidFromTime()
	case taf.FieldValidToTime:
		return m.ValidToTime()
	case taf.FieldRemarks:
		return m.Remarks()
	case taf.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TafMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taf.FieldRawText:
		return m.OldRawText(ctx)
	case taf.FieldIssueTime:
		return m.OldIssueTime(ctx)
	case taf.FieldImportTime:
		return m.OldImportTime(ctx)
	case taf.FieldBulletinTime:
		return m.OldBulletinTime(ctx)
	case taf.FieldValidFromTime:
		return m.OldValidFromTime(ctx)
	case taf.FieldValidToTime:
		return m.OldValidToTime(ctx)
	case taf.FieldRemarks:
		return m.OldRemarks(ctx)
	case taf.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown Taf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TafMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taf.FieldRawText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawText(v)
		return nil
	case taf.FieldIssueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueTime(v)
		return nil
	case taf.FieldImportTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportTime(v)
		return nil
	case taf.FieldBulletinTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBulletinTime(v)
		return nil
	case taf.FieldValidFromTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidFromTime(v)
		return nil
	case taf.FieldValidToTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidToTime(v)
		return nil
	case taf.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case taf.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown Taf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TafMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TafMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TafMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Taf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TafMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TafMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TafMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Taf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TafMutation) ResetField(name string) error {
	switch name {
	case taf.FieldRawText:
		m.ResetRawText()
		return nil
	case taf.FieldIssueTime:
		m.ResetIssueTime()
		return nil
	case taf.FieldImportTime:
		m.ResetImportTime()
		return nil
	case taf.FieldBulletinTime:
		m.ResetBulletinTime()
		return nil
	case taf.FieldValidFromTime:
		m.ResetValidFromTime()
		return nil
	case taf.FieldValidToTime:
		m.ResetValidToTime()
		return nil
	case taf.FieldRemarks:
		m.ResetRemarks()
		return nil
	case taf.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown Taf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TafMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.station != nil {
		edges = append(edges, taf.EdgeStation)
	}
	if m.forecast != nil {
		edges = append(edges, taf.EdgeForecast)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TafMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taf.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case taf.EdgeForecast:
		ids := make([]ent.Value, 0, len(m.forecast))
		for id := range m.forecast {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TafMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedforecast != nil {
		edges = append(edges, taf.EdgeForecast)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TafMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taf.EdgeForecast:
		ids := make([]ent.Value, 0, len(m.removedforecast))
		for id := range m.removedforecast {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TafMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstation {
		edges = append(edges, taf.EdgeStation)
	}
	if m.clearedforecast {
		edges = append(edges, taf.EdgeForecast)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TafMutation) EdgeCleared(name string) bool {
	switch name {
	case taf.EdgeStation:
		return m.clearedstation
	case taf.EdgeForecast:
		return m.clearedforecast
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TafMutation) ClearEdge(name string) error {
	switch name {
	case taf.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Taf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TafMutation) ResetEdge(name string) error {
	switch name {
	case taf.EdgeStation:
		m.ResetStation()
		return nil
	case taf.EdgeForecast:
		m.ResetForecast()
		return nil
	}
	return fmt.Errorf("unknown Taf edge %s", name)
}

// TemperatureDataMutation represents an operation that mutates the TemperatureData nodes in the graph.
type TemperatureDataMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	valid_time         *time.Time
	temperature        *float64
	addtemperature     *float64
	min_temperature    *float64
	addmin_temperature *float64
	max_temperature    *float64
	addmax_temperature *float64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*TemperatureData, error)
	predicates         []predicate.TemperatureData
}

var _ ent.Mutation = (*TemperatureDataMutation)(nil)

// temperaturedataOption allows management of the mutation configuration using functional options.
type temperaturedataOption func(*TemperatureDataMutation)

// newTemperatureDataMutation creates new mutation for the TemperatureData entity.
func newTemperatureDataMutation(c config, op Op, opts ...temperaturedataOption) *TemperatureDataMutation {
	m := &TemperatureDataMutation{
		config:        c,
		op:            op,
		typ:           TypeTemperatureData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemperatureDataID sets the ID field of the mutation.
func withTemperatureDataID(id uuid.UUID) temperaturedataOption {
	return func(m *TemperatureDataMutation) {
		var (
			err   error
			once  sync.Once
			value *TemperatureData
		)
		m.oldValue = func(ctx context.Context) (*TemperatureData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemperatureData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemperatureData sets the old TemperatureData of the mutation.
func withTemperatureData(node *TemperatureData) temperaturedataOption {
	return func(m *TemperatureDataMutation) {
		m.oldValue = func(context.Context) (*TemperatureData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemperatureDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemperatureDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemperatureData entities.
func (m *TemperatureDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemperatureDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemperatureDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemperatureData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValidTime sets the "valid_time" field.
func (m *TemperatureDataMutation) SetValidTime(t time.Time) {
	m.valid_time = &t
}

// ValidTime returns the value of the "valid_time" field in the mutation.
func (m *TemperatureDataMutation) ValidTime() (r time.Time, exists bool) {
	v := m.valid_time
	if v == nil {
		return
	}
	return *v, true
}

// OldValidTime returns the old "valid_time" field's value of the TemperatureData entity.
// If the TemperatureData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemperatureDataMutation) OldValidTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidTime: %w", err)
	}
	return oldValue.ValidTime, nil
}

// ResetValidTime resets all changes to the "valid_time" field.
func (m *TemperatureDataMutation) ResetValidTime() {
	m.valid_time = nil
}

// SetTemperature sets the "temperature" field.
func (m *TemperatureDataMutation) SetTemperature(f float64) {
	m.temperature = &f
	m.addtemperature = nil
}

// Temperature returns the value of the "temperature" field in the mutation.
func (m *TemperatureDataMutation) Temperature() (r float64, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old "temperature" field's value of the TemperatureData entity.
// If the TemperatureData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemperatureDataMutation) OldTemperature(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds f to the "temperature" field.
func (m *TemperatureDataMutation) AddTemperature(f float64) {
	if m.addtemperature != nil {
		*m.addtemperature += f
	} else {
		m.addtemperature = &f
	}
}

// AddedTemperature returns the value that was added to the "temperature" field in this mutation.
func (m *TemperatureDataMutation) AddedTemperature() (r float64, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemperature resets all changes to the "temperature" field.
func (m *TemperatureDataMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
}

// SetMinTemperature sets the "min_temperature" field.
func (m *TemperatureDataMutation) SetMinTemperature(f float64) {
	m.min_temperature = &f
	m.addmin_temperature = nil
}

// MinTemperature returns the value of the "min_temperature" field in the mutation.
func (m *TemperatureDataMutation) MinTemperature() (r float64, exists bool) {
	v := m.min_temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemperature returns the old "min_temperature" field's value of the TemperatureData entity.
// If the TemperatureData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemperatureDataMutation) OldMinTemperature(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemperature: %w", err)
	}
	return oldValue.MinTemperature, nil
}

// AddMinTemperature adds f to the "min_temperature" field.
func (m *TemperatureDataMutation) AddMinTemperature(f float64) {
	if m.addmin_temperature != nil {
		*m.addmin_temperature += f
	} else {
		m.addmin_temperature = &f
	}
}

// AddedMinTemperature returns the value that was added to the "min_temperature" field in this mutation.
func (m *TemperatureDataMutation) AddedMinTemperature() (r float64, exists bool) {
	v := m.addmin_temperature
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinTemperature clears the value of the "min_temperature" field.
func (m *TemperatureDataMutation) ClearMinTemperature() {
	m.min_temperature = nil
	m.addmin_temperature = nil
	m.clearedFields[temperaturedata.FieldMinTemperature] = struct{}{}
}

// MinTemperatureCleared returns if the "min_temperature" field was cleared in this mutation.
func (m *TemperatureDataMutation) MinTemperatureCleared() bool {
	_, ok := m.clearedFields[temperaturedata.FieldMinTemperature]
	return ok
}

// ResetMinTemperature resets all changes to the "min_temperature" field.
func (m *TemperatureDataMutation) ResetMinTemperature() {
	m.min_temperature = nil
	m.addmin_temperature = nil
	delete(m.clearedFields, temperaturedata.FieldMinTemperature)
}

// SetMaxTemperature sets the "max_temperature" field.
func (m *TemperatureDataMutation) SetMaxTemperature(f float64) {
	m.max_temperature = &f
	m.addmax_temperature = nil
}

// MaxTemperature returns the value of the "max_temperature" field in the mutation.
func (m *TemperatureDataMutation) MaxTemperature() (r float64, exists bool) {
	v := m.max_temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemperature returns the old "max_temperature" field's value of the TemperatureData entity.
// If the TemperatureData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemperatureDataMutation) OldMaxTemperature(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemperature: %w", err)
	}
	return oldValue.MaxTemperature, nil
}

// AddMaxTemperature adds f to the "max_temperature" field.
func (m *TemperatureDataMutation) AddMaxTemperature(f float64) {
	if m.addmax_temperature != nil {
		*m.addmax_temperature += f
	} else {
		m.addmax_temperature = &f
	}
}

// AddedMaxTemperature returns the value that was added to the "max_temperature" field in this mutation.
func (m *TemperatureDataMutation) AddedMaxTemperature() (r float64, exists bool) {
	v := m.addmax_temperature
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTemperature clears the value of the "max_temperature" field.
func (m *TemperatureDataMutation) ClearMaxTemperature() {
	m.max_temperature = nil
	m.addmax_temperature = nil
	m.clearedFields[temperaturedata.FieldMaxTemperature] = struct{}{}
}

// MaxTemperatureCleared returns if the "max_temperature" field was cleared in this mutation.
func (m *TemperatureDataMutation) MaxTemperatureCleared() bool {
	_, ok := m.clearedFields[temperaturedata.FieldMaxTemperature]
	return ok
}

// ResetMaxTemperature resets all changes to the "max_temperature" field.
func (m *TemperatureDataMutation) ResetMaxTemperature() {
	m.max_temperature = nil
	m.addmax_temperature = nil
	delete(m.clearedFields, temperaturedata.FieldMaxTemperature)
}

// Where appends a list predicates to the TemperatureDataMutation builder.
func (m *TemperatureDataMutation) Where(ps ...predicate.TemperatureData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemperatureDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemperatureDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemperatureData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemperatureDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemperatureDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemperatureData).
func (m *TemperatureDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemperatureDataMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.valid_time != nil {
		fields = append(fields, temperaturedata.FieldValidTime)
	}
	if m.temperature != nil {
		fields = append(fields, temperaturedata.FieldTemperature)
	}
	if m.min_temperature != nil {
		fields = append(fields, temperaturedata.FieldMinTemperature)
	}
	if m.max_temperature != nil {
		fields = append(fields, temperaturedata.FieldMaxTemperature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemperatureDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case temperaturedata.FieldValidTime:
		return m.ValidTime()
	case temperaturedata.FieldTemperature:
		return m.Temperature()
	case temperaturedata.FieldMinTemperature:
		return m.MinTemperature()
	case temperaturedata.FieldMaxTemperature:
		return m.MaxTemperature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemperatureDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case temperaturedata.FieldValidTime:
		return m.OldValidTime(ctx)
	case temperaturedata.FieldTemperature:
		return m.OldTemperature(ctx)
	case temperaturedata.FieldMinTemperature:
		return m.OldMinTemperature(ctx)
	case temperaturedata.FieldMaxTemperature:
		return m.OldMaxTemperature(ctx)
	}
	return nil, fmt.Errorf("unknown TemperatureData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemperatureDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case temperaturedata.FieldValidTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidTime(v)
		return nil
	case temperaturedata.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case temperaturedata.FieldMinTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemperature(v)
		return nil
	case temperaturedata.FieldMaxTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemperature(v)
		return nil
	}
	return fmt.Errorf("unknown TemperatureData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemperatureDataMutation) AddedFields() []string {
	var fields []string
	if m.addtemperature != nil {
		fields = append(fields, temperaturedata.FieldTemperature)
	}
	if m.addmin_temperature != nil {
		fields = append(fields, temperaturedata.FieldMinTemperature)
	}
	if m.addmax_temperature != nil {
		fields = append(fields, temperaturedata.FieldMaxTemperature)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemperatureDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case temperaturedata.FieldTemperature:
		return m.AddedTemperature()
	case temperaturedata.FieldMinTemperature:
		return m.AddedMinTemperature()
	case temperaturedata.FieldMaxTemperature:
		return m.AddedMaxTemperature()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemperatureDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case temperaturedata.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case temperaturedata.FieldMinTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemperature(v)
		return nil
	case temperaturedata.FieldMaxTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemperature(v)
		return nil
	}
	return fmt.Errorf("unknown TemperatureData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemperatureDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(temperaturedata.FieldMinTemperature) {
		fields = append(fields, temperaturedata.FieldMinTemperature)
	}
	if m.FieldCleared(temperaturedata.FieldMaxTemperature) {
		fields = append(fields, temperaturedata.FieldMaxTemperature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemperatureDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemperatureDataMutation) ClearField(name string) error {
	switch name {
	case temperaturedata.FieldMinTemperature:
		m.ClearMinTemperature()
		return nil
	case temperaturedata.FieldMaxTemperature:
		m.ClearMaxTemperature()
		return nil
	}
	return fmt.Errorf("unknown TemperatureData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemperatureDataMutation) ResetField(name string) error {
	switch name {
	case temperaturedata.FieldValidTime:
		m.ResetValidTime()
		return nil
	case temperaturedata.FieldTemperature:
		m.ResetTemperature()
		return nil
	case temperaturedata.FieldMinTemperature:
		m.ResetMinTemperature()
		return nil
	case temperaturedata.FieldMaxTemperature:
		m.ResetMaxTemperature()
		return nil
	}
	return fmt.Errorf("unknown TemperatureData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemperatureDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemperatureDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemperatureDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemperatureDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemperatureDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemperatureDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemperatureDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TemperatureData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemperatureDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TemperatureData edge %s", name)
}

// TurbulenceConditionMutation represents an operation that mutates the TurbulenceCondition nodes in the graph.
type TurbulenceConditionMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	intensity       *string
	min_altitude    *int
	addmin_altitude *int
	max_altitude    *int
	addmax_altitude *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TurbulenceCondition, error)
	predicates      []predicate.TurbulenceCondition
}

var _ ent.Mutation = (*TurbulenceConditionMutation)(nil)

// turbulenceconditionOption allows management of the mutation configuration using functional options.
type turbulenceconditionOption func(*TurbulenceConditionMutation)

// newTurbulenceConditionMutation creates new mutation for the TurbulenceCondition entity.
func newTurbulenceConditionMutation(c config, op Op, opts ...turbulenceconditionOption) *TurbulenceConditionMutation {
	m := &TurbulenceConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeTurbulenceCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTurbulenceConditionID sets the ID field of the mutation.
func withTurbulenceConditionID(id uuid.UUID) turbulenceconditionOption {
	return func(m *TurbulenceConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *TurbulenceCondition
		)
		m.oldValue = func(ctx context.Context) (*TurbulenceCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TurbulenceCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTurbulenceCondition sets the old TurbulenceCondition of the mutation.
func withTurbulenceCondition(node *TurbulenceCondition) turbulenceconditionOption {
	return func(m *TurbulenceConditionMutation) {
		m.oldValue = func(context.Context) (*TurbulenceCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TurbulenceConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TurbulenceConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TurbulenceCondition entities.
func (m *TurbulenceConditionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TurbulenceConditionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TurbulenceConditionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TurbulenceCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIntensity sets the "intensity" field.
func (m *TurbulenceConditionMutation) SetIntensity(s string) {
	m.intensity = &s
}

// Intensity returns the value of the "intensity" field in the mutation.
func (m *TurbulenceConditionMutation) Intensity() (r string, exists bool) {
	v := m.intensity
	if v == nil {
		return
	}
	return *v, true
}

// OldIntensity returns the old "intensity" field's value of the TurbulenceCondition entity.
// If the TurbulenceCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TurbulenceConditionMutation) OldIntensity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntensity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntensity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntensity: %w", err)
	}
	return oldValue.Intensity, nil
}

// ResetIntensity resets all changes to the "intensity" field.
func (m *TurbulenceConditionMutation) ResetIntensity() {
	m.intensity = nil
}

// SetMinAltitude sets the "min_altitude" field.
func (m *TurbulenceConditionMutation) SetMinAltitude(i int) {
	m.min_altitude = &i
	m.addmin_altitude = nil
}

// MinAltitude returns the value of the "min_altitude" field in the mutation.
func (m *TurbulenceConditionMutation) MinAltitude() (r int, exists bool) {
	v := m.min_altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldMinAltitude returns the old "min_altitude" field's value of the TurbulenceCondition entity.
// If the TurbulenceCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TurbulenceConditionMutation) OldMinAltitude(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinAltitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinAltitude: %w", err)
	}
	return oldValue.MinAltitude, nil
}

// AddMinAltitude adds i to the "min_altitude" field.
func (m *TurbulenceConditionMutation) AddMinAltitude(i int) {
	if m.addmin_altitude != nil {
		*m.addmin_altitude += i
	} else {
		m.addmin_altitude = &i
	}
}

// AddedMinAltitude returns the value that was added to the "min_altitude" field in this mutation.
func (m *TurbulenceConditionMutation) AddedMinAltitude() (r int, exists bool) {
	v := m.addmin_altitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinAltitude resets all changes to the "min_altitude" field.
func (m *TurbulenceConditionMutation) ResetMinAltitude() {
	m.min_altitude = nil
	m.addmin_altitude = nil
}

// SetMaxAltitude sets the "max_altitude" field.
func (m *TurbulenceConditionMutation) SetMaxAltitude(i int) {
	m.max_altitude = &i
	m.addmax_altitude = nil
}

// MaxAltitude returns the value of the "max_altitude" field in the mutation.
func (m *TurbulenceConditionMutation) MaxAltitude() (r int, exists bool) {
	v := m.max_altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAltitude returns the old "max_altitude" field's value of the TurbulenceCondition entity.
// If the TurbulenceCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TurbulenceConditionMutation) OldMaxAltitude(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAltitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAltitude: %w", err)
	}
	return oldValue.MaxAltitude, nil
}

// AddMaxAltitude adds i to the "max_altitude" field.
func (m *TurbulenceConditionMutation) AddMaxAltitude(i int) {
	if m.addmax_altitude != nil {
		*m.addmax_altitude += i
	} else {
		m.addmax_altitude = &i
	}
}

// AddedMaxAltitude returns the value that was added to the "max_altitude" field in this mutation.
func (m *TurbulenceConditionMutation) AddedMaxAltitude() (r int, exists bool) {
	v := m.addmax_altitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxAltitude resets all changes to the "max_altitude" field.
func (m *TurbulenceConditionMutation) ResetMaxAltitude() {
	m.max_altitude = nil
	m.addmax_altitude = nil
}

// Where appends a list predicates to the TurbulenceConditionMutation builder.
func (m *TurbulenceConditionMutation) Where(ps ...predicate.TurbulenceCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TurbulenceConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TurbulenceConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TurbulenceCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TurbulenceConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TurbulenceConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TurbulenceCondition).
func (m *TurbulenceConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TurbulenceConditionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.intensity != nil {
		fields = append(fields, turbulencecondition.FieldIntensity)
	}
	if m.min_altitude != nil {
		fields = append(fields, turbulencecondition.FieldMinAltitude)
	}
	if m.max_altitude != nil {
		fields = append(fields, turbulencecondition.FieldMaxAltitude)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TurbulenceConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case turbulencecondition.FieldIntensity:
		return m.Intensity()
	case turbulencecondition.FieldMinAltitude:
		return m.MinAltitude()
	case turbulencecondition.FieldMaxAltitude:
		return m.MaxAltitude()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TurbulenceConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case turbulencecondition.FieldIntensity:
		return m.OldIntensity(ctx)
	case turbulencecondition.FieldMinAltitude:
		return m.OldMinAltitude(ctx)
	case turbulencecondition.FieldMaxAltitude:
		return m.OldMaxAltitude(ctx)
	}
	return nil, fmt.Errorf("unknown TurbulenceCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TurbulenceConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case turbulencecondition.FieldIntensity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntensity(v)
		return nil
	case turbulencecondition.FieldMinAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinAltitude(v)
		return nil
	case turbulencecondition.FieldMaxAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAltitude(v)
		return nil
	}
	return fmt.Errorf("unknown TurbulenceCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TurbulenceConditionMutation) AddedFields() []string {
	var fields []string
	if m.addmin_altitude != nil {
		fields = append(fields, turbulencecondition.FieldMinAltitude)
	}
	if m.addmax_altitude != nil {
		fields = append(fields, turbulencecondition.FieldMaxAltitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TurbulenceConditionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case turbulencecondition.FieldMinAltitude:
		return m.AddedMinAltitude()
	case turbulencecondition.FieldMaxAltitude:
		return m.AddedMaxAltitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TurbulenceConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case turbulencecondition.FieldMinAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinAltitude(v)
		return nil
	case turbulencecondition.FieldMaxAltitude:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAltitude(v)
		return nil
	}
	return fmt.Errorf("unknown TurbulenceCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TurbulenceConditionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TurbulenceConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TurbulenceConditionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TurbulenceCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TurbulenceConditionMutation) ResetField(name string) error {
	switch name {
	case turbulencecondition.FieldIntensity:
		m.ResetIntensity()
		return nil
	case turbulencecondition.FieldMinAltitude:
		m.ResetMinAltitude()
		return nil
	case turbulencecondition.FieldMaxAltitude:
		m.ResetMaxAltitude()
		return nil
	}
	return fmt.Errorf("unknown TurbulenceCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TurbulenceConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TurbulenceConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TurbulenceConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TurbulenceConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TurbulenceConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TurbulenceConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TurbulenceConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TurbulenceCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TurbulenceConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TurbulenceCondition edge %s", name)
}

// WeatherStationMutation represents an operation that mutates the WeatherStation nodes in the graph.
type WeatherStationMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	station_id     *string
	latitude       *float64
	addlatitude    *float64
	longitude      *float64
	addlongitude   *float64
	elevation      *float64
	addelevation   *float64
	hash           *string
	clearedFields  map[string]struct{}
	airport        *uuid.UUID
	clearedairport bool
	metars         map[uuid.UUID]struct{}
	removedmetars  map[uuid.UUID]struct{}
	clearedmetars  bool
	tafs           map[uuid.UUID]struct{}
	removedtafs    map[uuid.UUID]struct{}
	clearedtafs    bool
	done           bool
	oldValue       func(context.Context) (*WeatherStation, error)
	predicates     []predicate.WeatherStation
}

var _ ent.Mutation = (*WeatherStationMutation)(nil)

// weatherstationOption allows management of the mutation configuration using functional options.
type weatherstationOption func(*WeatherStationMutation)

// newWeatherStationMutation creates new mutation for the WeatherStation entity.
func newWeatherStationMutation(c config, op Op, opts ...weatherstationOption) *WeatherStationMutation {
	m := &WeatherStationMutation{
		config:        c,
		op:            op,
		typ:           TypeWeatherStation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWeatherStationID sets the ID field of the mutation.
func withWeatherStationID(id uuid.UUID) weatherstationOption {
	return func(m *WeatherStationMutation) {
		var (
			err   error
			once  sync.Once
			value *WeatherStation
		)
		m.oldValue = func(ctx context.Context) (*WeatherStation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WeatherStation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWeatherStation sets the old WeatherStation of the mutation.
func withWeatherStation(node *WeatherStation) weatherstationOption {
	return func(m *WeatherStationMutation) {
		m.oldValue = func(context.Context) (*WeatherStation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WeatherStationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WeatherStationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WeatherStation entities.
func (m *WeatherStationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WeatherStationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WeatherStationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WeatherStation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStationID sets the "station_id" field.
func (m *WeatherStationMutation) SetStationID(s string) {
	m.station_id = &s
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *WeatherStationMutation) StationID() (r string, exists bool) {
	v := m.station_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the WeatherStation entity.
// If the WeatherStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeatherStationMutation) OldStationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ResetStationID resets all changes to the "station_id" field.
func (m *WeatherStationMutation) ResetStationID() {
	m.station_id = nil
}

// SetLatitude sets the "latitude" field.
func (m *WeatherStationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *WeatherStationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the WeatherStation entity.
// If the WeatherStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeatherStationMutation) OldLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *WeatherStationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *WeatherStationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *WeatherStationMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[weatherstation.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *WeatherStationMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[weatherstation.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *WeatherStationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, weatherstation.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *WeatherStationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *WeatherStationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the WeatherStation entity.
// If the WeatherStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeatherStationMutation) OldLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *WeatherStationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *WeatherStationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *WeatherStationMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[weatherstation.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *WeatherStationMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[weatherstation.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *WeatherStationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, weatherstation.FieldLongitude)
}

// SetElevation sets the "elevation" field.
func (m *WeatherStationMutation) SetElevation(f float64) {
	m.elevation = &f
	m.addelevation = nil
}

// Elevation returns the value of the "elevation" field in the mutation.
func (m *WeatherStationMutation) Elevation() (r float64, exists bool) {
	v := m.elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldElevation returns the old "elevation" field's value of the WeatherStation entity.
// If the WeatherStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeatherStationMutation) OldElevation(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElevation: %w", err)
	}
	return oldValue.Elevation, nil
}

// AddElevation adds f to the "elevation" field.
func (m *WeatherStationMutation) AddElevation(f float64) {
	if m.addelevation != nil {
		*m.addelevation += f
	} else {
		m.addelevation = &f
	}
}

// AddedElevation returns the value that was added to the "elevation" field in this mutation.
func (m *WeatherStationMutation) AddedElevation() (r float64, exists bool) {
	v := m.addelevation
	if v == nil {
		return
	}
	return *v, true
}

// ClearElevation clears the value of the "elevation" field.
func (m *WeatherStationMutation) ClearElevation() {
	m.elevation = nil
	m.addelevation = nil
	m.clearedFields[weatherstation.FieldElevation] = struct{}{}
}

// ElevationCleared returns if the "elevation" field was cleared in this mutation.
func (m *WeatherStationMutation) ElevationCleared() bool {
	_, ok := m.clearedFields[weatherstation.FieldElevation]
	return ok
}

// ResetElevation resets all changes to the "elevation" field.
func (m *WeatherStationMutation) ResetElevation() {
	m.elevation = nil
	m.addelevation = nil
	delete(m.clearedFields, weatherstation.FieldElevation)
}

// SetHash sets the "hash" field.
func (m *WeatherStationMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *WeatherStationMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the WeatherStation entity.
// If the WeatherStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeatherStationMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *WeatherStationMutation) ResetHash() {
	m.hash = nil
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *WeatherStationMutation) SetAirportID(id uuid.UUID) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *WeatherStationMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *WeatherStationMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *WeatherStationMutation) AirportID() (id uuid.UUID, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *WeatherStationMutation) AirportIDs() (ids []uuid.UUID) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *WeatherStationMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// AddMetarIDs adds the "metars" edge to the Metar entity by ids.
func (m *WeatherStationMutation) AddMetarIDs(ids ...uuid.UUID) {
	if m.metars == nil {
		m.metars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metars[ids[i]] = struct{}{}
	}
}

// ClearMetars clears the "metars" edge to the Metar entity.
func (m *WeatherStationMutation) ClearMetars() {
	m.clearedmetars = true
}

// MetarsCleared reports if the "metars" edge to the Metar entity was cleared.
func (m *WeatherStationMutation) MetarsCleared() bool {
	return m.clearedmetars
}

// RemoveMetarIDs removes the "metars" edge to the Metar entity by IDs.
func (m *WeatherStationMutation) RemoveMetarIDs(ids ...uuid.UUID) {
	if m.removedmetars == nil {
		m.removedmetars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metars, ids[i])
		m.removedmetars[ids[i]] = struct{}{}
	}
}

// RemovedMetars returns the removed IDs of the "metars" edge to the Metar entity.
func (m *WeatherStationMutation) RemovedMetarsIDs() (ids []uuid.UUID) {
	for id := range m.removedmetars {
		ids = append(ids, id)
	}
	return
}

// MetarsIDs returns the "metars" edge IDs in the mutation.
func (m *WeatherStationMutation) MetarsIDs() (ids []uuid.UUID) {
	for id := range m.metars {
		ids = append(ids, id)
	}
	return
}

// ResetMetars resets all changes to the "metars" edge.
func (m *WeatherStationMutation) ResetMetars() {
	m.metars = nil
	m.clearedmetars = false
	m.removedmetars = nil
}

// AddTafIDs adds the "tafs" edge to the Taf entity by ids.
func (m *WeatherStationMutation) AddTafIDs(ids ...uuid.UUID) {
	if m.tafs == nil {
		m.tafs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tafs[ids[i]] = struct{}{}
	}
}

// ClearTafs clears the "tafs" edge to the Taf entity.
func (m *WeatherStationMutation) ClearTafs() {
	m.clearedtafs = true
}

// TafsCleared reports if the "tafs" edge to the Taf entity was cleared.
func (m *WeatherStationMutation) TafsCleared() bool {
	return m.clearedtafs
}

// RemoveTafIDs removes the "tafs" edge to the Taf entity by IDs.
func (m *WeatherStationMutation) RemoveTafIDs(ids ...uuid.UUID) {
	if m.removedtafs == nil {
		m.removedtafs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tafs, ids[i])
		m.removedtafs[ids[i]] = struct{}{}
	}
}

// RemovedTafs returns the removed IDs of the "tafs" edge to the Taf entity.
func (m *WeatherStationMutation) RemovedTafsIDs() (ids []uuid.UUID) {
	for id := range m.removedtafs {
		ids = append(ids, id)
	}
	return
}

// TafsIDs returns the "tafs" edge IDs in the mutation.
func (m *WeatherStationMutation) TafsIDs() (ids []uuid.UUID) {
	for id := range m.tafs {
		ids = append(ids, id)
	}
	return
}

// ResetTafs resets all changes to the "tafs" edge.
func (m *WeatherStationMutation) ResetTafs() {
	m.tafs = nil
	m.clearedtafs = false
	m.removedtafs = nil
}

// Where appends a list predicates to the WeatherStationMutation builder.
func (m *WeatherStationMutation) Where(ps ...predicate.WeatherStation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WeatherStationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WeatherStationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WeatherStation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WeatherStationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WeatherStationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WeatherStation).
func (m *WeatherStationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WeatherStationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.station_id != nil {
		fields = append(fields, weatherstation.FieldStationID)
	}
	if m.latitude != nil {
		fields = append(fields, weatherstation.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, weatherstation.FieldLongitude)
	}
	if m.elevation != nil {
		fields = append(fields, weatherstation.FieldElevation)
	}
	if m.hash != nil {
		fields = append(fields, weatherstation.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WeatherStationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case weatherstation.FieldStationID:
		return m.StationID()
	case weatherstation.FieldLatitude:
		return m.Latitude()
	case weatherstation.FieldLongitude:
		return m.Longitude()
	case weatherstation.FieldElevation:
		return m.Elevation()
	case weatherstation.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WeatherStationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case weatherstation.FieldStationID:
		return m.OldStationID(ctx)
	case weatherstation.FieldLatitude:
		return m.OldLatitude(ctx)
	case weatherstation.FieldLongitude:
		return m.OldLongitude(ctx)
	case weatherstation.FieldElevation:
		return m.OldElevation(ctx)
	case weatherstation.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown WeatherStation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeatherStationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case weatherstation.FieldStationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case weatherstation.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case weatherstation.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case weatherstation.FieldElevation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElevation(v)
		return nil
	case weatherstation.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown WeatherStation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WeatherStationMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, weatherstation.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, weatherstation.FieldLongitude)
	}
	if m.addelevation != nil {
		fields = append(fields, weatherstation.FieldElevation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WeatherStationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case weatherstation.FieldLatitude:
		return m.AddedLatitude()
	case weatherstation.FieldLongitude:
		return m.AddedLongitude()
	case weatherstation.FieldElevation:
		return m.AddedElevation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeatherStationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case weatherstation.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case weatherstation.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case weatherstation.FieldElevation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElevation(v)
		return nil
	}
	return fmt.Errorf("unknown WeatherStation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WeatherStationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(weatherstation.FieldLatitude) {
		fields = append(fields, weatherstation.FieldLatitude)
	}
	if m.FieldCleared(weatherstation.FieldLongitude) {
		fields = append(fields, weatherstation.FieldLongitude)
	}
	if m.FieldCleared(weatherstation.FieldElevation) {
		fields = append(fields, weatherstation.FieldElevation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WeatherStationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WeatherStationMutation) ClearField(name string) error {
	switch name {
	case weatherstation.FieldLatitude:
		m.ClearLatitude()
		return nil
	case weatherstation.FieldLongitude:
		m.ClearLongitude()
		return nil
	case weatherstation.FieldElevation:
		m.ClearElevation()
		return nil
	}
	return fmt.Errorf("unknown WeatherStation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WeatherStationMutation) ResetField(name string) error {
	switch name {
	case weatherstation.FieldStationID:
		m.ResetStationID()
		return nil
	case weatherstation.FieldLatitude:
		m.ResetLatitude()
		return nil
	case weatherstation.FieldLongitude:
		m.ResetLongitude()
		return nil
	case weatherstation.FieldElevation:
		m.ResetElevation()
		return nil
	case weatherstation.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown WeatherStation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WeatherStationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.airport != nil {
		edges = append(edges, weatherstation.EdgeAirport)
	}
	if m.metars != nil {
		edges = append(edges, weatherstation.EdgeMetars)
	}
	if m.tafs != nil {
		edges = append(edges, weatherstation.EdgeTafs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WeatherStationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case weatherstation.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	case weatherstation.EdgeMetars:
		ids := make([]ent.Value, 0, len(m.metars))
		for id := range m.metars {
			ids = append(ids, id)
		}
		return ids
	case weatherstation.EdgeTafs:
		ids := make([]ent.Value, 0, len(m.tafs))
		for id := range m.tafs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WeatherStationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmetars != nil {
		edges = append(edges, weatherstation.EdgeMetars)
	}
	if m.removedtafs != nil {
		edges = append(edges, weatherstation.EdgeTafs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WeatherStationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case weatherstation.EdgeMetars:
		ids := make([]ent.Value, 0, len(m.removedmetars))
		for id := range m.removedmetars {
			ids = append(ids, id)
		}
		return ids
	case weatherstation.EdgeTafs:
		ids := make([]ent.Value, 0, len(m.removedtafs))
		for id := range m.removedtafs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WeatherStationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedairport {
		edges = append(edges, weatherstation.EdgeAirport)
	}
	if m.clearedmetars {
		edges = append(edges, weatherstation.EdgeMetars)
	}
	if m.clearedtafs {
		edges = append(edges, weatherstation.EdgeTafs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WeatherStationMutation) EdgeCleared(name string) bool {
	switch name {
	case weatherstation.EdgeAirport:
		return m.clearedairport
	case weatherstation.EdgeMetars:
		return m.clearedmetars
	case weatherstation.EdgeTafs:
		return m.clearedtafs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WeatherStationMutation) ClearEdge(name string) error {
	switch name {
	case weatherstation.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown WeatherStation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WeatherStationMutation) ResetEdge(name string) error {
	switch name {
	case weatherstation.EdgeAirport:
		m.ResetAirport()
		return nil
	case weatherstation.EdgeMetars:
		m.ResetMetars()
		return nil
	case weatherstation.EdgeTafs:
		m.ResetTafs()
		return nil
	}
	return fmt.Errorf("unknown WeatherStation edge %s", name)
}
