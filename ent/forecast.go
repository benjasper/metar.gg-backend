// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"metar.gg/ent/forecast"
)

// Forecast is the model entity for the Forecast schema.
type Forecast struct {
	config `json:"-"`
	// ID of the ent.
	// The unique identifier of the record.
	ID uuid.UUID `json:"id,omitempty"`
	// The start time of the forecast period.
	FromTime time.Time `json:"from_time,omitempty"`
	// The end time of the forecast period.
	ToTime time.Time `json:"to_time,omitempty"`
	// The change indicator.
	ChangeIndicator *forecast.ChangeIndicator `json:"change_indicator,omitempty"`
	// The time of the change.
	ChangeTime *time.Time `json:"change_time,omitempty"`
	// The probability of the change.
	ChangeProbability *int `json:"change_probability,omitempty"`
	// The wind direction in degrees.
	WindDirection *int `json:"wind_direction,omitempty"`
	// Whether the wind direction is variable (VRB)
	WindDirectionVariable bool `json:"wind_direction_variable,omitempty"`
	// The wind speed in knots.
	WindSpeed *int `json:"wind_speed,omitempty"`
	// The wind gust in knots.
	WindGust *int `json:"wind_gust,omitempty"`
	// The height of the wind shear in feet above ground level.
	WindShearHeight *int `json:"wind_shear_height,omitempty"`
	// The wind shear direction in degrees.
	WindShearDirection *int `json:"wind_shear_direction,omitempty"`
	// The wind shear speed in knots.
	WindShearSpeed *int `json:"wind_shear_speed,omitempty"`
	// The visibility in statute miles.
	VisibilityHorizontal *float64 `json:"visibility_horizontal,omitempty"`
	// Whether the visibility is more than it's assigned value (+)
	VisibilityHorizontalIsMoreThan bool `json:"visibility_horizontal_is_more_than,omitempty"`
	// The vertical visibility in feet.
	VisibilityVertical *int `json:"visibility_vertical,omitempty"`
	// The altimeter in inches of mercury.
	Altimeter *float64 `json:"altimeter,omitempty"`
	// The weather string.
	Weather string `json:"weather,omitempty"`
	// The not decoded string.
	NotDecoded string `json:"not_decoded,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ForecastQuery when eager-loading is set.
	Edges        ForecastEdges `json:"edges"`
	taf_forecast *uuid.UUID
	selectValues sql.SelectValues
}

// ForecastEdges holds the relations/edges for other nodes in the graph.
type ForecastEdges struct {
	// The sky conditions.
	SkyConditions []*SkyCondition `json:"sky_conditions,omitempty"`
	// The turbulence conditions.
	TurbulenceConditions []*TurbulenceCondition `json:"turbulence_conditions,omitempty"`
	// The icing conditions.
	IcingConditions []*IcingCondition `json:"icing_conditions,omitempty"`
	// The temperature data.
	TemperatureData []*TemperatureData `json:"temperature_data,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [4]bool
	// totalCount holds the count of the edges above.
	totalCount [4]map[string]int

	namedSkyConditions        map[string][]*SkyCondition
	namedTurbulenceConditions map[string][]*TurbulenceCondition
	namedIcingConditions      map[string][]*IcingCondition
	namedTemperatureData      map[string][]*TemperatureData
}

// SkyConditionsOrErr returns the SkyConditions value or an error if the edge
// was not loaded in eager-loading.
func (e ForecastEdges) SkyConditionsOrErr() ([]*SkyCondition, error) {
	if e.loadedTypes[0] {
		return e.SkyConditions, nil
	}
	return nil, &NotLoadedError{edge: "sky_conditions"}
}

// TurbulenceConditionsOrErr returns the TurbulenceConditions value or an error if the edge
// was not loaded in eager-loading.
func (e ForecastEdges) TurbulenceConditionsOrErr() ([]*TurbulenceCondition, error) {
	if e.loadedTypes[1] {
		return e.TurbulenceConditions, nil
	}
	return nil, &NotLoadedError{edge: "turbulence_conditions"}
}

// IcingConditionsOrErr returns the IcingConditions value or an error if the edge
// was not loaded in eager-loading.
func (e ForecastEdges) IcingConditionsOrErr() ([]*IcingCondition, error) {
	if e.loadedTypes[2] {
		return e.IcingConditions, nil
	}
	return nil, &NotLoadedError{edge: "icing_conditions"}
}

// TemperatureDataOrErr returns the TemperatureData value or an error if the edge
// was not loaded in eager-loading.
func (e ForecastEdges) TemperatureDataOrErr() ([]*TemperatureData, error) {
	if e.loadedTypes[3] {
		return e.TemperatureData, nil
	}
	return nil, &NotLoadedError{edge: "temperature_data"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Forecast) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case forecast.FieldWindDirectionVariable, forecast.FieldVisibilityHorizontalIsMoreThan:
			values[i] = new(sql.NullBool)
		case forecast.FieldVisibilityHorizontal, forecast.FieldAltimeter:
			values[i] = new(sql.NullFloat64)
		case forecast.FieldChangeProbability, forecast.FieldWindDirection, forecast.FieldWindSpeed, forecast.FieldWindGust, forecast.FieldWindShearHeight, forecast.FieldWindShearDirection, forecast.FieldWindShearSpeed, forecast.FieldVisibilityVertical:
			values[i] = new(sql.NullInt64)
		case forecast.FieldChangeIndicator, forecast.FieldWeather, forecast.FieldNotDecoded:
			values[i] = new(sql.NullString)
		case forecast.FieldFromTime, forecast.FieldToTime, forecast.FieldChangeTime:
			values[i] = new(sql.NullTime)
		case forecast.FieldID:
			values[i] = new(uuid.UUID)
		case forecast.ForeignKeys[0]: // taf_forecast
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Forecast fields.
func (f *Forecast) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case forecast.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				f.ID = *value
			}
		case forecast.FieldFromTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field from_time", values[i])
			} else if value.Valid {
				f.FromTime = value.Time
			}
		case forecast.FieldToTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field to_time", values[i])
			} else if value.Valid {
				f.ToTime = value.Time
			}
		case forecast.FieldChangeIndicator:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field change_indicator", values[i])
			} else if value.Valid {
				f.ChangeIndicator = new(forecast.ChangeIndicator)
				*f.ChangeIndicator = forecast.ChangeIndicator(value.String)
			}
		case forecast.FieldChangeTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field change_time", values[i])
			} else if value.Valid {
				f.ChangeTime = new(time.Time)
				*f.ChangeTime = value.Time
			}
		case forecast.FieldChangeProbability:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field change_probability", values[i])
			} else if value.Valid {
				f.ChangeProbability = new(int)
				*f.ChangeProbability = int(value.Int64)
			}
		case forecast.FieldWindDirection:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field wind_direction", values[i])
			} else if value.Valid {
				f.WindDirection = new(int)
				*f.WindDirection = int(value.Int64)
			}
		case forecast.FieldWindDirectionVariable:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field wind_direction_variable", values[i])
			} else if value.Valid {
				f.WindDirectionVariable = value.Bool
			}
		case forecast.FieldWindSpeed:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field wind_speed", values[i])
			} else if value.Valid {
				f.WindSpeed = new(int)
				*f.WindSpeed = int(value.Int64)
			}
		case forecast.FieldWindGust:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field wind_gust", values[i])
			} else if value.Valid {
				f.WindGust = new(int)
				*f.WindGust = int(value.Int64)
			}
		case forecast.FieldWindShearHeight:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field wind_shear_height", values[i])
			} else if value.Valid {
				f.WindShearHeight = new(int)
				*f.WindShearHeight = int(value.Int64)
			}
		case forecast.FieldWindShearDirection:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field wind_shear_direction", values[i])
			} else if value.Valid {
				f.WindShearDirection = new(int)
				*f.WindShearDirection = int(value.Int64)
			}
		case forecast.FieldWindShearSpeed:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field wind_shear_speed", values[i])
			} else if value.Valid {
				f.WindShearSpeed = new(int)
				*f.WindShearSpeed = int(value.Int64)
			}
		case forecast.FieldVisibilityHorizontal:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field visibility_horizontal", values[i])
			} else if value.Valid {
				f.VisibilityHorizontal = new(float64)
				*f.VisibilityHorizontal = value.Float64
			}
		case forecast.FieldVisibilityHorizontalIsMoreThan:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field visibility_horizontal_is_more_than", values[i])
			} else if value.Valid {
				f.VisibilityHorizontalIsMoreThan = value.Bool
			}
		case forecast.FieldVisibilityVertical:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field visibility_vertical", values[i])
			} else if value.Valid {
				f.VisibilityVertical = new(int)
				*f.VisibilityVertical = int(value.Int64)
			}
		case forecast.FieldAltimeter:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field altimeter", values[i])
			} else if value.Valid {
				f.Altimeter = new(float64)
				*f.Altimeter = value.Float64
			}
		case forecast.FieldWeather:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field weather", values[i])
			} else if value.Valid {
				f.Weather = value.String
			}
		case forecast.FieldNotDecoded:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field not_decoded", values[i])
			} else if value.Valid {
				f.NotDecoded = value.String
			}
		case forecast.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field taf_forecast", values[i])
			} else if value.Valid {
				f.taf_forecast = new(uuid.UUID)
				*f.taf_forecast = *value.S.(*uuid.UUID)
			}
		default:
			f.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Forecast.
// This includes values selected through modifiers, order, etc.
func (f *Forecast) Value(name string) (ent.Value, error) {
	return f.selectValues.Get(name)
}

// QuerySkyConditions queries the "sky_conditions" edge of the Forecast entity.
func (f *Forecast) QuerySkyConditions() *SkyConditionQuery {
	return NewForecastClient(f.config).QuerySkyConditions(f)
}

// QueryTurbulenceConditions queries the "turbulence_conditions" edge of the Forecast entity.
func (f *Forecast) QueryTurbulenceConditions() *TurbulenceConditionQuery {
	return NewForecastClient(f.config).QueryTurbulenceConditions(f)
}

// QueryIcingConditions queries the "icing_conditions" edge of the Forecast entity.
func (f *Forecast) QueryIcingConditions() *IcingConditionQuery {
	return NewForecastClient(f.config).QueryIcingConditions(f)
}

// QueryTemperatureData queries the "temperature_data" edge of the Forecast entity.
func (f *Forecast) QueryTemperatureData() *TemperatureDataQuery {
	return NewForecastClient(f.config).QueryTemperatureData(f)
}

// Update returns a builder for updating this Forecast.
// Note that you need to call Forecast.Unwrap() before calling this method if this Forecast
// was returned from a transaction, and the transaction was committed or rolled back.
func (f *Forecast) Update() *ForecastUpdateOne {
	return NewForecastClient(f.config).UpdateOne(f)
}

// Unwrap unwraps the Forecast entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (f *Forecast) Unwrap() *Forecast {
	_tx, ok := f.config.driver.(*txDriver)
	if !ok {
		panic("ent: Forecast is not a transactional entity")
	}
	f.config.driver = _tx.drv
	return f
}

// String implements the fmt.Stringer.
func (f *Forecast) String() string {
	var builder strings.Builder
	builder.WriteString("Forecast(")
	builder.WriteString(fmt.Sprintf("id=%v, ", f.ID))
	builder.WriteString("from_time=")
	builder.WriteString(f.FromTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("to_time=")
	builder.WriteString(f.ToTime.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := f.ChangeIndicator; v != nil {
		builder.WriteString("change_indicator=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.ChangeTime; v != nil {
		builder.WriteString("change_time=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := f.ChangeProbability; v != nil {
		builder.WriteString("change_probability=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.WindDirection; v != nil {
		builder.WriteString("wind_direction=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("wind_direction_variable=")
	builder.WriteString(fmt.Sprintf("%v", f.WindDirectionVariable))
	builder.WriteString(", ")
	if v := f.WindSpeed; v != nil {
		builder.WriteString("wind_speed=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.WindGust; v != nil {
		builder.WriteString("wind_gust=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.WindShearHeight; v != nil {
		builder.WriteString("wind_shear_height=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.WindShearDirection; v != nil {
		builder.WriteString("wind_shear_direction=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.WindShearSpeed; v != nil {
		builder.WriteString("wind_shear_speed=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.VisibilityHorizontal; v != nil {
		builder.WriteString("visibility_horizontal=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("visibility_horizontal_is_more_than=")
	builder.WriteString(fmt.Sprintf("%v", f.VisibilityHorizontalIsMoreThan))
	builder.WriteString(", ")
	if v := f.VisibilityVertical; v != nil {
		builder.WriteString("visibility_vertical=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := f.Altimeter; v != nil {
		builder.WriteString("altimeter=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("weather=")
	builder.WriteString(f.Weather)
	builder.WriteString(", ")
	builder.WriteString("not_decoded=")
	builder.WriteString(f.NotDecoded)
	builder.WriteByte(')')
	return builder.String()
}

// NamedSkyConditions returns the SkyConditions named value or an error if the edge was not
// loaded in eager-loading with this name.
func (f *Forecast) NamedSkyConditions(name string) ([]*SkyCondition, error) {
	if f.Edges.namedSkyConditions == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := f.Edges.namedSkyConditions[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (f *Forecast) appendNamedSkyConditions(name string, edges ...*SkyCondition) {
	if f.Edges.namedSkyConditions == nil {
		f.Edges.namedSkyConditions = make(map[string][]*SkyCondition)
	}
	if len(edges) == 0 {
		f.Edges.namedSkyConditions[name] = []*SkyCondition{}
	} else {
		f.Edges.namedSkyConditions[name] = append(f.Edges.namedSkyConditions[name], edges...)
	}
}

// NamedTurbulenceConditions returns the TurbulenceConditions named value or an error if the edge was not
// loaded in eager-loading with this name.
func (f *Forecast) NamedTurbulenceConditions(name string) ([]*TurbulenceCondition, error) {
	if f.Edges.namedTurbulenceConditions == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := f.Edges.namedTurbulenceConditions[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (f *Forecast) appendNamedTurbulenceConditions(name string, edges ...*TurbulenceCondition) {
	if f.Edges.namedTurbulenceConditions == nil {
		f.Edges.namedTurbulenceConditions = make(map[string][]*TurbulenceCondition)
	}
	if len(edges) == 0 {
		f.Edges.namedTurbulenceConditions[name] = []*TurbulenceCondition{}
	} else {
		f.Edges.namedTurbulenceConditions[name] = append(f.Edges.namedTurbulenceConditions[name], edges...)
	}
}

// NamedIcingConditions returns the IcingConditions named value or an error if the edge was not
// loaded in eager-loading with this name.
func (f *Forecast) NamedIcingConditions(name string) ([]*IcingCondition, error) {
	if f.Edges.namedIcingConditions == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := f.Edges.namedIcingConditions[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (f *Forecast) appendNamedIcingConditions(name string, edges ...*IcingCondition) {
	if f.Edges.namedIcingConditions == nil {
		f.Edges.namedIcingConditions = make(map[string][]*IcingCondition)
	}
	if len(edges) == 0 {
		f.Edges.namedIcingConditions[name] = []*IcingCondition{}
	} else {
		f.Edges.namedIcingConditions[name] = append(f.Edges.namedIcingConditions[name], edges...)
	}
}

// NamedTemperatureData returns the TemperatureData named value or an error if the edge was not
// loaded in eager-loading with this name.
func (f *Forecast) NamedTemperatureData(name string) ([]*TemperatureData, error) {
	if f.Edges.namedTemperatureData == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := f.Edges.namedTemperatureData[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (f *Forecast) appendNamedTemperatureData(name string, edges ...*TemperatureData) {
	if f.Edges.namedTemperatureData == nil {
		f.Edges.namedTemperatureData = make(map[string][]*TemperatureData)
	}
	if len(edges) == 0 {
		f.Edges.namedTemperatureData[name] = []*TemperatureData{}
	} else {
		f.Edges.namedTemperatureData[name] = append(f.Edges.namedTemperatureData[name], edges...)
	}
}

// Forecasts is a parsable slice of Forecast.
type Forecasts []*Forecast
